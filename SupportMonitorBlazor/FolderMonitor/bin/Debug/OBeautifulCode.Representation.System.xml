<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OBeautifulCode.Representation.System</name>
    </assembly>
    <members>
        <member name="T:OBeautifulCode.Cloning.Recipes.CloningExtensions">
            <summary>
            Extension methods to clone objects of various types.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone``1(``0)">
            <summary>
            Deep clones an arbitrary value.
            </summary>
            <typeparam name="T">The type of the value to deep clone.</typeparam>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.  If value is null, returns null.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.String)">
            <summary>
            Deep clones a <see cref="T:System.String"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.Version)">
            <summary>
            Deep clones a <see cref="T:System.Version"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.Uri)">
            <summary>
            Deep clones a <see cref="T:System.Uri"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause">
            <summary>
            Standard justifications for analysis suppression.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_SeeOtherSuppressionMessages">
            <summary>
            See the other suppression message(s) applied within the same context.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_AgreeWithAssessmentAndNeedsRefactoring">
            <summary>
            We agree with the assessment.  This code needs refactoring but we cannot justify spending time on this right now.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_NatureOfTypeNecessitatesIgnoringAllWarnings">
            <summary>
            The nature of this type necessitates that we ignore all warnings.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_NotApplicable">
            <summary>
            This warning detects a situation that is not applicable to this code.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1000_DoNotDeclareStaticMembersOnGenericTypes_StaticPropertyReturnsInstanceOfContainingGenericClassAndIsConvenientAndMostDiscoverableWhereDeclared">
            <summary>
            A static property returns an instance of the generic class that contains the property.  The property exists for convenience in creating and configuring the instance.  It is most discoverable where it is, in-context of the class being instantiated.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1002_DoNotExposeGenericLists_GenericListRequiredForTesting">
            <summary>
            A generic list is required in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1004_GenericMethodsShouldProvideTypeParameter_OnlyInputsToMethodAreTypesAndItsMoreConciseToCallMethodUseGenericTypeParameters">
            <summary>
            The only input(s) to the method are Types.  It's more concise to call the method using generic types parameters instead of a parameter signature with parameters of type Type (e.g. MyMethod&lt;MyType&gt;() instead of MyMethod(Type myType)).
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1005_AvoidExcessiveParametersOnGenericTypes_SpecifiedParametersRequiredForNeededFunctionality">
            <summary>
            The specified paramters are required to achieve the needed functionality.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1014_MarkAssembliesWithClsCompliant_ConsoleExeDoesNotNeedToBeClsCompliant">
            <summary>
            Console executable does not need the [assembly: CLSCompliant(true)] as it should not be shared as an assembly for reference.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1020_AvoidNamespacesWithFewTypes_OptimizeForLogicalGroupingOfTypes">
            <summary>
            We are optimizing for the logical grouping of types rather than the number of types in a namepace.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1021_AvoidOutParameters_OutParameterRequiredForTryMethod">
            <summary>
            An out parameter is required for a Try...() method that attempts to perform some operation, returning true when successful and setting the out parameter to the result of the operation or returning false and leaving the out parameter uninitialized (e.g. dictionary.TryGetValue(key, int out result) ).
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1027_MarkEnumsWithFlags_EnumValuesArePurposefullyNonContiguous">
            <summary>
            This is not a flags enum.  Enum values are purposefully non-contiguous.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1032_ImplementStandardExceptionConstructors_ExceptionUsedInternallyAndConstructorsEnsureRequiredInfoAvailableWhenCaught">
            <summary>
            This Exception is only used internally and the constructor(s) ensure that when the Exception is caught, it contains the required information.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1034_NestedTypesShouldNotBeVisible_VisibleNestedTypeRequiredForTesting">
            <summary>
            A visible nested type is required in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1036_OverrideMethodsOnComparableTypes_TypeCreatedForTestsThatRequireComparableTypeButDoNotUseTypeToPerformComparisons">
            <summary>
            The type exists for unit tests that require a comparable type, but do not use the type to perform any comparisons.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1040_AvoidEmptyInterfaces_NeedToIdentifyGroupOfTypesAndPreferInterfaceOverAttribute">
            <summary>
            When we need to identify a group of types, we prefer the use of an empty interface over an attribute because it's easier to use and results in cleaner code.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1051_DoNotDeclareVisibleInstanceFields_TypeUsedInTestingThatRequiresInstanceFieldToBeVisible">
            <summary>
            The type is used for test code that requires the instance field to be visible.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1054_UriParametersShouldNotBeStrings_PreferToRepresentUrlAsString">
            <summary>
            In this case we prefer to represent the URL as a string.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1056_UriPropertiesShouldNotBeStrings_PreferToRepresentUrlAsString">
            <summary>
            In this case we prefer to represent the URL as a string.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1065_DoNotRaiseExceptionsInUnexpectedLocations_ThrowNotSupportedExceptionForUnreachableCodePath">
            <summary>
            It's ok to throw NotSupportedException for an unreachable code path.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1065_DoNotRaiseExceptionsInUnexpectedLocations_ThrowNotImplementedExceptionWhenForcedToSpecifyMemberThatWillNeverBeUsedInTesting">
            <summary>
            It's ok to throw NotImplementedException when a base type or implementing an interface forces us to create a member that will never be used in testing.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1308_NormalizeStringsToUppercase_PreferGuidLowercase">
            <summary>
            We prefer to read <see cref="T:System.Guid" />'s string representation as lowercase.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1502_AvoidExcessiveComplexity_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment that this method as excessively complex.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1505_AvoidUnmaintainableCode_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment that this code is unmaintainable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1506_AvoidExcessiveClassCoupling_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment this type or method is excessively coupled.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1702_CompoundWordsShouldBeCasedCorrectly_AnalyzerIsIncorrectlyDetectingCompoundWords">
            <summary>
            The analyzer is incorrectly detecting compound words.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1704_IdentifiersShouldBeSpelledCorrectly_SpellingIsCorrectInContextOfTheDomain">
            <summary>
            The spelling of the identifier is correct in-context of the domain.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1709_IdentifiersShouldBeCasedCorrectly_CasingIsAsPreferred">
            <summary>
            The casing is as preferred.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1710_IdentifiersShouldHaveCorrectSuffix_ExceptionBaseClassShouldEndWithBase">
            <summary>
            An Exception base class should end in 'Base' (as is the convention for all base classes), not 'Exception'.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1710_IdentifiersShouldHaveCorrectSuffix_NameDirectlyExtendedOrImplementedTypeAddedAsSuffixForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier is suffixed with the name of the Type that it directly extends or implements to improves readability and comprehension of unit tests whre the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1711_IdentifiersShouldNotHaveIncorrectSuffix_TypeNameAddedAsSuffixForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier is suffixed with it's Type name to improve readability and comprehension of unit tests where the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1714_FlagsEnumsShouldHavePluralNames_TheNameIsPlural">
            <summary>
            The name is plural.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndNoGoodAlternative">
            <summary>
            The type name adds clarity to the identifier and there is no good alternative.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity">
            <summary>
            The type name adds clarity to the identifier and the alternatives degrade the clarity of the identifier.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddedToIdentifierForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier includes it's Type name to improve readability and comprehension of unit tests where the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1726_UsePreferredTerms_FlagsAddedForTestsWhereEnumKindIsPrimaryConcern">
            <summary>
            The identifier includes 'Flags' to improve readability and comprehension of unit tests where the kind of Enum is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags">
            <summary>
            The name of the Type of the identifier uses the term 'Flags' and so it's appropriate to use that term in the the name of the identifier.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1804_RemoveUnusedLocals_UsedAsWorkaroundForConditionalBreakpointThatCannotBeSet">
            <summary>
            In some cases, the debugger raises an error because it cannot set a conditional breakpoint.  A local is introduced to simplify the evaluation of the breakpoint's condition.  It's only purpose is to allow a conditional breakpoint in proximity of the breakpoint that cannot be set.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1810_InitializeReferenceTypeStaticFieldsInline_FieldsDeclaredInCodeGeneratedPartialTestClass">
            <summary>
            The static field(s) are declared in a code generated partial test class that should not be alterated.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1811_AvoidUncalledPrivateCode_MethodIsWiredIntoClapAsVerb">
            <summary>
            The method is wired into CLAP, a framework for command-line parsing, as a verb.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1811_AvoidUncalledPrivateCode_PropertyExistsForCompleteness">
            <summary>
            The property exists for completeness.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_ClassIsWiredIntoClapInProgramCs">
            <summary>
            The class is wired into CLAP, a framework for command-line parsing, in Program.cs.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_SerializationConfigurationClassInstantedBySerializer">
            <summary>
            The class derives from SerializationConfigurationBase and is instantiated by a Serializer that is configured using the type of that class.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_ClassExistsToUseItsTypeInUnitTests">
            <summary>
            The class exists because it's Type is used in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1815_OverrideEqualsAndOperatorEqualsOnValueTypes_TypeUsedForTestsThatRequireTypeToNotBeEquatable">
            <summary>
            The type is being used in testing and we explicitly do not want the type to be equatable because it has bearing on the tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1819_PropertiesShouldNotReturnArrays_DataPayloadsAreCommonlyRepresentedAsByteArrays">
            <summary>
            Data payloads are commonly represented as a byte arrays.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1819_PropertiesShouldNotReturnArrays_ArrayPropertyRequiredForTesting">
            <summary>
            An array property is required for unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2000_DisposeObjectsBeforeLosingScope_DisposableObjectIsMethodReturnObject">
            <summary>
            The disposable object is the method's return object.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2000_DisposeObjectsBeforeLosingScope_MethodCreatesDisposableObjectButItCannotBeDisposedBecauseReturnObjectRequiresDisposableObjectToBeFullyIntact">
            <summary>
            The method creates a dispoable object, but it cannot be disposed because the return object requires the disposable object to be fully intact.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2104_DoNotDeclareReadOnlyMutableReferenceTypes_TypeIsImmutable">
            <summary>
            The type is immutable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2201_DoNotRaiseReservedExceptionTypes_UsedForUnitTesting">
            <summary>
            The reserved exception is being used in unit test code; there is no real caller that will be impacted.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2202_DoNotDisposeObjectsMultipleTimes_AnalyzerIsIncorrectlyFlaggingObjectAsBeingDisposedMultipleTimes">
            <summary>
            The analyzer is incorectly flagging an object as being disposed multiple times.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2214_DoNotCallOverridableMethodsInConstructors_OverriddenMethodDoesNotRelyOnInitializationNorOtherConfigurationInConstructor">
            <summary>
            The overridden method does not relies on initialization nor other configuration in the constructor.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2227_CollectionPropertiesShouldBeReadOnly_PublicInterfaceNeverExposesTheObject">
            <summary>
            The public interface of the system associated with this object never exposes this object.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2227_CollectionPropertiesShouldBeReadOnly_SetterIsRequiredForTesting">
            <summary>
            A setter is required for unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2237_MarkISerializableTypesWithSerializable_UsedForTestingWithNoIntentionToSerialize">
            <summary>
            The type is used in unit tests with no intention to serialize.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2237_MarkISerializableTypesWithSerializable_ExceptionOnlyUsedInternallyAndWillNeverBeSerialized">
            <summary>
            The Exception is only used internally; it will never be serialized.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Collection.Recipes.CollectionExtensions">
            <summary>
            Helper methods for operating on objects of type <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.CollectionExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds the elements of the specified <see cref="T:System.Collections.IEnumerable"/> to an <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
            <param name="collection">The collection to add to.</param>
            <param name="valuesToAdd">
            The <see cref="T:System.Collections.IEnumerable"/> whose elements should be added to the <see cref="T:System.Collections.ICollection"/>.
            The <see cref="T:System.Collections.IEnumerable"/> itself cannot be a null reference, but it can contain elements that are a null reference.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="valuesToAdd"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.Collection.Recipes.EnumerableExtensions">
            <summary>
            Helper methods for operating on objects of type <see cref="T:System.Collections.IEnumerable"/> and <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.GetCombinations``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Gets all combinations of items in a specified set of items.
            </summary>
            <remarks>
            Adapted from <a href="https://stackoverflow.com/a/41642733/356790" />.
            </remarks>
            <typeparam name="T">The type of items in the set.</typeparam>
            <param name="values">The set of values.</param>
            <param name="minimumItems">Optional minimum number of items in each combination.  Default is 1.</param>
            <param name="maximumItems">Optional maximum number of items in each combination.  Default is no maximum limit.</param>
            <returns>
            All possible combinations for the input set, constrained by the specified <paramref name="maximumItems"/> and <paramref name="minimumItems"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minimumItems"/> is less than 1.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumItems"/> is less than <paramref name="minimumItems"/>"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.GetLongestCommonPrefix(System.Collections.Generic.IReadOnlyCollection{System.String})">
            <summary>
            Gets the longest string that is a prefix of all of the specified strings.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/58265152/356790" />.
            </remarks>
            <param name="values">The value to evaluate for a common prefix.</param>
            <returns>
            The longest string that is a prefix of all of the specified strings.
            If any value is null, returns null as the common prefix.
            Otherwise, if there is no common prefix, returns an empty string.
            If only one value is specified, then the value itself is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="values"/> is empty.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.RandomizeElements``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Puts the elements of a specified enumerable into a new enumerable, in random order.
            </summary>
            <param name="value">The enumerable.</param>
            <returns>
            A new enumerable having all of the elements of the specified enumerable, but in random order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.SymmetricDifference(System.Collections.IEnumerable,System.Collections.IEnumerable)">
            <summary>
            Gets the symmetric difference of two sets using the default equality comparer.
            The symmetric difference is defined as the set of elements which are in one of the sets, but not in both.
            </summary>
            <remarks>
            If one set has duplicate items when evaluated using the comparer, then the resulting symmetric difference will only
            contain one copy of the the duplicate item and only if it doesn't appear in the other set.
            </remarks>
            <param name="value">The first enumerable.</param>
            <param name="secondSet">The second enumerable to compare against the first.</param>
            <returns>IEnumerable(T) with the symmetric difference of the two sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="secondSet"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.SymmetricDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets the symmetric difference of two sets using an equality comparer.
            The symmetric difference is defined as the set of elements which are in one of the sets, but not in both.
            </summary>
            <remarks>
            If one set has duplicate items when evaluated using the comparer, then the resulting symmetric difference will only
            contain one copy of the the duplicate item and only if it doesn't appear in the other set.
            </remarks>
            <typeparam name="TSource">The type of elements in the collection.</typeparam>
            <param name="value">The first enumerable.</param>
            <param name="secondSet">The second enumerable to compare against the first.</param>
            <param name="comparer">Optional equality comparer to use to compare elements.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the symmetric difference of the two sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="secondSet"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.ToCsv(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a common separated values (CSV) string from the individual strings in an <see cref="T:System.Collections.IEnumerable"/>,
            making CSV treatments where needed (double quotes around strings with commas, etc.).
            </summary>
            <param name="value">The enumerable to transform into a CSV string.</param>
            <param name="nullValueEncoding">Optional value to use when encoding null elements.  Defaults to the empty string.</param>
            <remarks>
            CSV treatments: <a href="http://en.wikipedia.org/wiki/Comma-separated_values"/>.
            </remarks>
            <returns>
            Returns a string that contains each element in the input enumerable,
            separated by a comma and with the proper escaping.
            If the enumerable is empty, returns null.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.ToDelimitedString(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Concatenates the individual values in an <see cref="T:System.Collections.IEnumerable"/> with a given delimiter
            separating the individual values.
            </summary>
            <param name="value">The enumerable to concatenate.</param>
            <param name="delimiter">The delimiter to use between elements in the enumerable.</param>
            <remarks>
            If an element of the IEnumerable is null, then its treated like an empty string.
            </remarks>
            <returns>
            Returns a string that contains each element in the input enumerable, separated by the given delimiter.
            If the enumerable is empty, then this method returns null.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="delimiter"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.ToNewLineDelimited(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a string with the values in a given <see cref="T:System.Collections.IEnumerable"/>, separated by a newline.
            </summary>
            <param name="value">The enumerable to concatenate.</param>
            <remarks>
            If an element of the IEnumerable is null, then its treated like an empty string.
            </remarks>
            <returns>
            Returns a string that contains each element in the input enumerable, separated by a newline.
            If the enumerable is empty, then this method returns null.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.ToNonGenericDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Converts a generic dictionary to a non-generic dictionary.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <param name="value">The dictionary to convert.</param>
            <returns>
            The specified generic dictionary converted to a non-generic dictionary.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/>is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> contains duplicate keys.</exception>
        </member>
        <member name="T:OBeautifulCode.Enum.Recipes.EnumExtensions">
            <summary>
            Adds some convenient extension methods to enums.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetDefinedEnumValues``1">
            <summary>
            Gets the members/values of a specified enum.
            </summary>
            <typeparam name="TEnum">The type of enum.</typeparam>
            <returns>
            The members/values of the specified enum.
            For flags enums, returns all individual flags and all combined flags that are defined in the enum.
            </returns>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetDefinedEnumValues(System.Type)">
            <summary>
            Gets the members/values of a specified enum.
            </summary>
            <param name="enumType">The enum type.</param>
            <returns>
            The members/values of the specified enum.
            For flags enums, returns all individual flags and all combined flags that are defined in the enum.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.IsFlagsEnum``1">
            <summary>
            Determines if the specified enum is a flags enum.
            </summary>
            <typeparam name="TEnum">The type of enum.</typeparam>
            <returns>
            true if the specified enum is a flags enum, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.IsFlagsEnum(System.Type)">
            <summary>
            Determines if the specified enum is a flags enum.
            </summary>
            <param name="enumType">The enum type.</param>
            <returns>
            true if the specified enum is a flags enum, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetAllPossibleEnumValues``1">
            <summary>
            Gets all possible enum values.
            For a flags enum, this means all possible combination of flags,
            regardless of whether the combination is defined in the enum itself.
            </summary>
            <typeparam name="TEnum">The type of enum.</typeparam>
            <returns>
            All possible enum values.
            </returns>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetAllPossibleEnumValues(System.Type)">
            <summary>
            Gets all possible enum values.
            For a flags enum, this means all possible combination of flags,
            regardless of whether the combination is defined in the enum itself.
            </summary>
            <param name="enumType">The enum type.</param>
            <returns>
            All possible enum values.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetFlagsCombinedWherePossible(System.Enum)">
            <summary>
            Gets the flags of a flags enum, with a preference for returning combined flags
            instead of individual flags where the enum value uses combined flags.
            </summary>
            <param name="value">The enum value to decompose into it's flags.</param>
            <remarks>
            Adapted from: <a href="http://stackoverflow.com/a/4171168/356790" />.
            </remarks>
            <returns>
            The flags of the specified enum, with combined flags instead of individual flags where possible.
            No bit will be repeated.  Thus, if two combined flags are represented in the value and they
            have an overlapping individual flag, only one of those combined flags will be returned and
            the other will be decomposed into it's non-overlapping individual flags.
            If value is 0, then a collection with only the 0 value is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetFlagsCombinedWherePossible``1(System.Enum)">
            <summary>
            Gets the flags of a flags enum, with a preference for returning combined flags
            instead of individual flags where the enum value uses combined flags.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The enum value to decompose into it's flags.</param>
            <remarks>
            Adapted from: <a href="http://stackoverflow.com/a/4171168/356790" />.
            </remarks>
            <returns>
            The flags of the specified enum, with combined flags instead of individual flags where possible.
            No bit will be repeated.  Thus, if two combined flags are represented in the value and they
            have an overlapping individual flag, only one of those combined flags will be returned and
            the other will be decomposed into it's non-overlapping individual flags.
            If value is 0, then a collection with only the 0 value is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.HasFlagOverlap(System.Enum,System.Enum)">
            <summary>
            Checks if there is any overlap between the two <see cref="T:System.FlagsAttribute" /> enumerations.
            </summary>
            <param name="first">First to check.</param>
            <param name="second">Second to check.</param>
            <returns>Value indicating whether there is any overlap.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="second"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetIndividualFlags(System.Type)">
            <summary>
            Gets the individual flags of a flags enum type.
            </summary>
            <param name="enumType">The enum type.</param>
            <returns>
            The individuals flags of the specified flags enum type (includes 0).
            If <paramref name="enumType"/> is not a flags enum then all enum values are returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetIndividualFlags``1">
            <summary>
            Gets the individual flags of a flags enum type.
            </summary>
            <typeparam name="TEnum">The type of enum.</typeparam>
            <returns>
            The individuals flags of the specified flags enum type (includes 0).
            If <typeparamref name="TEnum"/> is not a flags enum then all enum values are returned.
            </returns>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetIndividualFlags(System.Enum)">
            <summary>
            Gets the individual flags of a flags enum value.
            </summary>
            <param name="value">The enum value to decompose into it's individual flags.</param>
            <remarks>
            Adapted from: <a href="http://stackoverflow.com/a/4171168/356790" />.
            </remarks>
            <returns>
            The individuals flags of the specified flags enum value.
            If value is 0, then a collection with only the 0 value is returned.
            If the enum is not a flags enum then a collection with the enum value itself is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetIndividualFlags``1(System.Enum)">
            <summary>
            Gets the individual flags of a flags enum value.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The enum value to decompose into it's individual flags.</param>
            <remarks>
            Adapted from: <a href="http://stackoverflow.com/a/4171168/356790" />.
            </remarks>
            <returns>
            The individuals flags of the specified flags enum value.
            If value is 0, then a collection with only the 0 value is returned.
            If the enum is not a flags enum then a collection with the enum value itself is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.ToEnum``1(System.String,System.Boolean)">
            <summary>
            Parses and converts to the specified string to an enum value.
            </summary>
            <remarks>
            [Flags] Colors { None=0, Red = 1, Green = 2, Blue = 4 }
            '0'          => None
            '2'          => Green
            '7'          => Red | Green | Blue
            'Blue'       => Blue
            'blue'       => Blue (if ignoreCase = true)
            'Red, Green' => Red | Green
            'Red,Green'  => Red | Green
            'red,green'  => Red | Green (if ignoreCase = true)
            </remarks>
            <typeparam name="TEnum">The type of enum.</typeparam>
            <param name="value">The string value to convert.</param>
            <param name="ignoreCase">
            Optional value indicating whether to operate in case sensitive or case insensitive mode.
            Default is operate in case sensitive mode.
            Use <c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.
            </param>
            <returns>
            The enum member/value that corresponds to the specified string value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> is white space.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> does not represent an enumeration.</exception>
            <exception cref="T:System.ArgumentException">Cannot convert the specified value to an enum member of the <typeparamref name="TEnum"/> enum.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.ToEnum(System.String,System.Type,System.Boolean)">
            <summary>
            Parses and converts to the specified string to an enum value.
            </summary>
            <remarks>
            [Flags] Colors { None=0, Red = 1, Green = 2, Blue = 4 }
            '0'          => None
            '2'          => Green
            '7'          => Red | Green | Blue
            'Blue'       => Blue
            'blue'       => Blue (if ignoreCase = true)
            'Red, Green' => Red | Green
            'Red,Green'  => Red | Green
            'red,green'  => Red | Green (if ignoreCase = true)
            </remarks>
            <param name="value">The string value to convert.</param>
            <param name="enumType">The type of the enum.</param>
            <param name="ignoreCase">
            Optional value indicating whether to operate in case sensitive or case insensitive mode.
            Default is operate in case sensitive mode.
            Use <c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.
            </param>
            <returns>
            The enum member/value that corresponds to the specified string value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> is white space.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> does not represent an enumeration.</exception>
            <exception cref="T:System.ArgumentException">Cannot convert the specified value to an enum member of the <paramref name="enumType"/> enum.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.BitwiseOr(System.Enum,System.Enum)">
            <summary>
            Performs a bitwise OR on the specified enum values.
            </summary>
            <param name="value1">The first enum value.</param>
            <param name="value2">The second enum value.</param>
            <returns>
            The result of performing a bitwise OR operation on the specified enum values.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value1"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="value2"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value1"/> is not a flags enum.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value1"/> Type != <paramref name="value2"/> Type.</exception>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer">
            <summary>
            Compares two byte arrays for equality.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer.Equals(System.Byte[],System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer.GetHashCode(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer">
            <summary>
            Compares two <see cref="T:System.DateTime"/>, fixing .NET's default implementation where two objects
            having the same <see cref="P:System.DateTime.Ticks"/> but different <see cref="P:System.DateTime.Kind"/> are
            considered equal.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer.Equals(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer.GetHashCode(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of dictionary keys.</typeparam>
            <typeparam name="TValue">The type of dictionary values.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2.Equals(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2.GetHashCode(System.Collections.Generic.IDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/14675741/356790" />.
            </remarks>
            <typeparam name="T">The type of objects to enumerate.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.#ctor(OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1"/> class.
            </summary>
            <param name="enumerableEqualityComparerStrategy">The strategy to use when comparing two <see cref="T:System.Collections.Generic.IEnumerable`1"/> for equality.</param>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.Equals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy">
            <summary>
            Determines the strategy to use when comparing two <see cref="T:System.Collections.Generic.IEnumerable`1"/> for equality.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy.SequenceEqual">
            <summary>
            Use <see cref="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsSequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy.UnorderedEqual">
            <summary>
            Use <see cref="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsUnorderedEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EqualityComparerHelper">
            <summary>
            Helper methods related to <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets the equality comparer to use for the specified type.
            </summary>
            <typeparam name="T">The type of the objects being compared.</typeparam>
            <param name="comparer">Optional comparer passed into the calling method.  Default is null, which instructs this method to determine the comparer.  If not null, then the specified comparer is returned.</param>
            <returns>
            The equality comparer to use for the specified type.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EqualityExtensions">
            <summary>
            Extension methods that test for equality between two objects.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsEqualTo``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares objects for equality.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
            <param name="item1">The first object to compare.</param>
            <param name="item2">The second object to compare.</param>
            <param name="comparer">Optional equality comparer to use to compare the objects.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two objects are equal
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsDictionaryEqualTo``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionaries.</typeparam>
            <typeparam name="TValue">The type of values in the dictionaries.</typeparam>
            <param name="item1">The first <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="item2">The second <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="valueComparer">Optional equality comparer to use to compare values.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source dictionaries are null.
            - false if one or the other is null.
            - false if the dictionaries are of different length.
            - true if the two dictionaries are of equal length and their values are equal for the same keys.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsReadOnlyDictionaryEqualTo``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionaries.</typeparam>
            <typeparam name="TValue">The type of values in the dictionaries.</typeparam>
            <param name="item1">The first <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="item2">The second <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="valueComparer">Optional equality comparer to use to compare values.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source dictionaries are null.
            - false if one or the other is null.
            - false if the dictionaries are of different length.
            - true if the two dictionaries are of equal length and their values are equal for the same keys.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsSequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TElement">The type of the elements of the input sequences.</typeparam>
            <param name="item1">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to <paramref name="item2"/>.</param>
            <param name="item2">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to the first sequence.</param>
            <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source sequences are null.
            - false if one or the other is null.
            - true if the two sequences are of equal length and their corresponding elements are equal according to <paramref name="elementComparer"/>.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsUnorderedEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if two enumerables have the exact same elements in any order.
            Every unique element in the first set has to appear in the second set the same number of times it appears in the first.
            </summary>
            <typeparam name="TElement">The type of the elements of the input sequences.</typeparam>
            <param name="item1">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to <paramref name="item2"/>.</param>
            <param name="item2">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to the first sequence.</param>
            <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source sequences are null.
            - false if one or the other is null.
            - false if there is any symmetric difference.
            - true if the two sequences both contain the same number of elements for each unique element.
            - otherwise, false.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.HashCodeHelper">
            <summary>
            Provides methods to help with generating hash codes for structures and classes. This handles
            value types, nullable type, and objects.
            </summary>
            <remarks>
            Adapted from NodaTime: <a href="https://github.com/nodatime/nodatime/blob/master/src/NodaTime/Utility/HashCodeHelper.cs"/>.
            The basic usage pattern is as follows.
            <example>
            <code>
             public override int GetHashCode() => HashCodeHelper.Initialize().Hash(Field1).Hash(Field2).Hash(Field3).Value;
            </code>
            </example>
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.HashCodeHelper.HashCodeMultiplier">
            <summary>
            The multiplier for each value.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.HashCodeHelper.HashCodeInitializer">
            <summary>
            The initial hash value.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> class.
            </summary>
            <param name="value">The hash code value.</param>
        </member>
        <member name="P:OBeautifulCode.Equality.Recipes.HashCodeHelper.Value">
            <summary>
            Gets the hash code value.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Initialize">
            <summary>
            Returns the initial value for a hash code.
            </summary>
            <returns>The initial integer wrapped in a <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> value.</returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Initialize(System.Int32)">
            <summary>
            Returns the initial value for a hash code.
            </summary>
            <param name="seedValue">Seed value to initialize with (often the hash code from a base class using it's base properties).</param>
            <returns>The initial integer wrapped in a <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> value.</returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Hash``1(``0)">
            <summary>
            Adds the hash code for the given item to the current hash code and returns the new hash code.
            </summary>
            <typeparam name="T">The type of the item being hashed.</typeparam>
            <param name="item">The item to hash.</param>
            <returns>The new hash code.</returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1">
            <summary>
            An equality comparer backed by a lambda.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1"/> class.
            </summary>
            <param name="equalsFunc">The function to use to determine whether two objects of type <typeparamref name="T"/> are equal.</param>
            <param name="getHashCodeFunc">OPTIONAL function to get the hash code for an object of type <typeparamref name="T"/> in context of this equality comparer.  DEFAULT is to have <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"/> throw <see cref="T:System.NotSupportedException"/>.</param>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.NativeMethods">
            <summary>
            P/invoke method.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NativeMethods.memcmp(System.Byte[],System.Byte[],System.Int64)">
            <summary>
            Compares two byte arrays.
            </summary>
            <param name="b1">The first byte array.</param>
            <param name="b2">The second byte array.</param>
            <param name="count">The length of the bytes.</param>
            <returns>
            0 if the byte arrays are equal.
            Less than 0 if the first byte array is less than the second byte array.
            Greater than 0 if the first byte array is greater than the second byte array.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer">
            <summary>
            Compares two <see cref="T:System.Nullable`1"/>, fixing .NET's default implementation where two objects
            having the same <see cref="P:System.DateTime.Ticks"/> but different <see cref="P:System.DateTime.Kind"/> are
            considered equal.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer.Equals(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer.GetHashCode(System.Nullable{System.DateTime})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer">
            <summary>
            Compares two objects equality.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer.Equals(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer.GetHashCode(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of dictionary keys.</typeparam>
            <typeparam name="TValue">The type of dictionary values.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2.Equals(System.Collections.Generic.IReadOnlyDictionary{`0,`1},System.Collections.Generic.IReadOnlyDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2.GetHashCode(System.Collections.Generic.IReadOnlyDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Math.Recipes.ThreadSafeRandom">
            <summary>
            Represents a thread-safe pseudo-random number generator,
            a device that produces a sequence of numbers that meet
            certain statistical requirements for randomness.
            </summary>
            <remarks>
            Adapted from:
            <a href="http://blogs.msdn.com/b/pfxteam/archive/2009/02/19/9434171.aspx"/>
            <a href="http://codeblog.jonskeet.uk/2009/11/04/revisiting-randomness/"/>
            System.Random is not thread-safe, hence the need for this class.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Lock">
            <summary>
            Lock object for access to global random number generator.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Math.Recipes.ThreadSafeRandom.random">
            <summary>
            A single random number generator for the app domain,
            used to seed thread-specific random number generators.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Reseed(System.Int32)">
            <summary>
            Reseeds the random number generator.
            </summary>
            <param name="seed">
            A number used to calculate a starting value for the pseudo-random number sequence.
            If a negative number is specified, the absolute value of the number is used.
            </param>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Next">
            <summary>
            Returns a nonnegative random integer.
            </summary>
            <remarks>
            Random.Next generates a random number whose value ranges from zero to less than <see cref="F:System.Int32.MaxValue"/>.
            To generate a random number whose value ranges from zero to some other positive number, use the <see cref="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Next(System.Int32)"/> method overload.
            To generate a random number within a different range, use the <see cref="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Next(System.Int32,System.Int32)"/> method overload.
            </remarks>
            <returns>
            A 32-bit signed integer greater than or equal to zero and less than MaxValue.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Next(System.Int32)">
            <summary>
            Returns a nonnegative random integer that is less than the specified maximum.
            </summary>
            <param name="maxValue">The exclusive upper bound of the random number to be generated. maxValue must be greater than or equal to zero.</param>
            <returns>
            A 32-bit signed integer greater than or equal to zero, and less than maxValue; that is, the range of return values
            ordinarily includes zero but not maxValue. However, if maxValue equals zero, maxValue is returned.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than zero.</exception>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random integer that is within a specified range.
            </summary>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The exclusive upper bound of the random number returned. maxValue must be greater than or equal to minValue.</param>
            <remarks>
            Unlike the other overloads of the Next method, which return only non-negative values, this method can return a negative random integer.
            </remarks>
            <returns>
            A 32-bit signed integer greater than or equal to minValue and less than maxValue; that is, the range of
            return values includes minValue but not maxValue. If minValue equals maxValue, minValue is returned.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minValue"/> is greater than <paramref name="maxValue"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers.
            </summary>
            <param name="buffer">An array of bytes to contain random numbers.</param>
            <remarks>
            Each element of the array of bytes is set to a random number greater than or equal to zero, and less than or equal to MaxValue.
            To generate a cryptographically secured random number suitable for creating a random password,
            for example, use a method such as RNGCryptoServiceProvider.GetBytes.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.NextDouble">
            <summary>
            Returns a random floating-point number between 0.0 and 1.0.
            </summary>
            <remarks>
            This method is the public version of the protected method, Sample.
            </remarks>
            <returns>
            A double-precision floating point number greater than or equal to 0.0, and less than 1.0.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.AccessModifier">
            <summary>
            The supported access modifiers, in order of least to greatest access.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.Unknown">
            <summary>
            Unknown (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.Private">
            <summary>
            Private access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private" />.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.PrivateProtected">
            <summary>
            Private protected access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private-protected" />.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.Protected">
            <summary>
            Protected access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected" />.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.ProtectedInternal">
            <summary>
            Protected internal access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal" />.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.Internal">
            <summary>
            Internal access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/internal" />.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.Public">
            <summary>
            Public access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public" />.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.AssemblyHelper">
            <summary>
            Provides useful methods for extracting information from and
            interacting with assemblies using reflection.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.GetCodeBaseAsPathInsteadOfUri(System.Reflection.Assembly)">
            <summary>
            Gets the <see cref="P:System.Reflection.Assembly.CodeBase" /> as a real file path instead of a <see cref="T:System.Uri" /> so it can be used with common <see cref="N:System.IO" /> operations.
            </summary>
            <param name="assembly">Assembly to extend functionality of.</param>
            <returns>CodeBase as real path.</returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.OpenEmbeddedResourceStream(System.Reflection.Assembly,System.String,OBeautifulCode.Reflection.Recipes.CompressionMethod)">
            <summary>
            Retrieves an embedded resource's stream.
            </summary>
            <param name="assembly">Calling assembly.</param>
            <param name="resourceName">Name of the resource in the calling assembly.</param>
            <param name="decompressionMethod">
            The compression algorithm and/or archive file format that was used to compress the resource.
            This is used to open a decompressed stream.
            </param>
            <returns>Returns the specified manifest resource as a stream.</returns>
            <exception cref="T:System.ArgumentNullException">assembly is null.</exception>
            <exception cref="T:System.ArgumentNullException">resourceName is null.</exception>
            <exception cref="T:System.ArgumentException">resourceName is whitspace.</exception>
            <exception cref="T:System.InvalidOperationException">Resource was not found in the calling assembly.</exception>
            <exception cref="T:System.InvalidOperationException">The resource was not an embedded resource (that is, non-linked).</exception>
            <exception cref="T:System.NotImplementedException">Resource length is greater than Int64.MaxValue.</exception>
            <exception cref="T:System.IO.InvalidDataException">When compression method is Gzip, but the resource was not compressed using Gzip.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.OpenEmbeddedResourceStream(System.String,System.Boolean,OBeautifulCode.Reflection.Recipes.CompressionMethod)">
            <summary>
            Retrieves a stream for an embedded resource.
            </summary>
            <param name="resourceName">Name of the resource in the calling assembly.</param>
            <param name="addCallerNamespace">
            Determines whether to add the namespace of the calling method to the resource name.
            If false, then the resource name is used as-is.
            If true, then the resource name is prepended with the fully qualified namespace of the calling method, followed by a period
            (e.g. if resource name = "MyFile.txt" then it changed to something like "MyNamespace.MySubNamespace.MyFile.txt").
            </param>
            <param name="decompressionMethod">
            The compression algorithm and/or archive file format that was used to compress the resource.
            This is used to open a decompressed stream.
            </param>
            <returns>Returns the specified manifest resource as a stream.</returns>
            <exception cref="T:System.ArgumentNullException">resourceName is null.</exception>
            <exception cref="T:System.ArgumentException">resourceName is whitspace.</exception>
            <exception cref="T:System.InvalidOperationException">Resource was not found in the calling assembly.</exception>
            <exception cref="T:System.InvalidOperationException">The resource was not an embedded resource (that is, non-linked).</exception>
            <exception cref="T:System.NotImplementedException">Resource length is greater than Int64.MaxValue.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.ReadEmbeddedResourceAsString(System.String,System.Boolean,OBeautifulCode.Reflection.Recipes.CompressionMethod)">
            <summary>
            Reads an embedded resource from the calling assembly and returns as string.
            </summary>
            <param name="resourceName">Name of the resource in the calling assembly.</param>
            <param name="addCallerNamespace">
            Determines whether to add the namespace of the calling method to the resource name.
            If false, then the resource name is used as-is.
            If true, then the resource name is prepended with the fully qualified namespace of the calling method, followed by a period
            (e.g. if resource name = "MyFile.txt" then it changed to something like "MyNamespace.MySubNamespace.MyFile.txt").
            </param>
            <param name="decompressionMethod">
            The compression algorithm and/or archive file format that was used to compress the resource.
            This is used to determine how the resource should be decompressed.
            </param>
            <remarks>
            Adapted from article "Create String Variables from Embedded Resources Files" on The Code Project
            <a href="http://www.codeproject.com/KB/cs/embeddedresourcestrings.aspx"/>
            Resource information is returned only if the resource is visible to the caller, or the caller has ReflectionPermission.
            This method returns null if a private resource in another assembly is accessed and the caller does not have ReflectionPermission with the ReflectionPermissionFlag.MemberAccess flag.
            </remarks>
            <returns>Returns the specified manifest resource as a string.</returns>
            <exception cref="T:System.ArgumentNullException">resourceName is null.</exception>
            <exception cref="T:System.ArgumentException">resourceName is white space.</exception>
            <exception cref="T:System.InvalidOperationException">Resource was not found in the calling assembly.</exception>
            <exception cref="T:System.InvalidOperationException">The resource was not an embedded resource (that is, non-linked).</exception>
            <exception cref="T:System.NotImplementedException">Resource length is greater than Int64.MaxValue.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.ReadEmbeddedResourceAsBytes(System.String,System.Boolean,OBeautifulCode.Reflection.Recipes.CompressionMethod)">
            <summary>
            Reads an embedded resource from the calling assembly and returns as a byte array.
            </summary>
            <param name="resourceName">Name of the resource in the calling assembly.</param>
            <param name="addCallerNamespace">
            Determines whether to add the namespace of the calling method to the resource name.
            If false, then the resource name is used as-is.
            If true, then the resource name is prepended with the fully qualified namespace of the calling method, followed by a period
            (e.g. if resource name = "MyFile.txt" then it changed to something like "MyNamespace.MySubNamespace.MyFile.txt").
            </param>
            <param name="decompressionMethod">
            The compression algorithm and/or archive file format that was used to compress the resource.
            This is used to determine how the resource should be decompressed.
            </param>
            <returns>
            Returns the specified manifest resource as a byte array.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="resourceName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="resourceName"/> is white space.</exception>
            <exception cref="T:System.InvalidOperationException">Resource was not found in the calling assembly.</exception>
            <exception cref="T:System.InvalidOperationException">The resource was not an embedded resource (that is, non-linked).</exception>
            <exception cref="T:System.NotImplementedException">Resource length is greater than Int64.MaxValue.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.GetTypesFromAssemblies(System.Collections.Generic.IReadOnlyCollection{System.Reflection.Assembly})">
            <summary>
            Gets all types defined within a set of assemblies.
            </summary>
            <remarks>
            If you want to get all loaded types, then pass-in the result of AssemblyLoader.GetLoadedAssemblies().
            </remarks>
            <param name="assemblies">The assemblies.</param>
            <returns>
            The types defined within the specified assemblies.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.ResolveResourceName(System.String,System.Boolean)">
            <summary>
            Resolves a resource name.
            </summary>
            <param name="resourceName">The supplied resource name.</param>
            <param name="addCallerNamespace">
            Determines whether to add the namespace of the calling method to the resource name.
            If false, then the resource name is used as-is.
            If true, then the resource name is prepended with the fully qualified namespace of the calling method, followed by a period
            (e.g. if resource name = "MyFile.txt" then it changed to something like "MyNamespace.MySubNamespace.MyFile.txt").
            </param>
            <returns>
            The resolved resource name.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.AssemblyLoader">
            <summary>
            Helper that will load all the assemblies in a directory and wire up all the necessary <see cref="T:System.AppDomain" /> logic to allow them to be reflected into.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultAssemblyFileExtensionsWithoutPeriodToLoad">
            <summary>
            Default assembly file extensions to process; ONLY the file extension not including the period e.g. "dll" NOT ".dll".
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultSymbolFileExtensionsWithoutPeriodToLoad">
            <summary>
            Default symbol file extensions to process; ONLY the file extension not including the period e.g. "pdb" NOT ".pdb".
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultAssemblyFileNameRegexBlacklist">
            <summary>
            Default list of regular expressions to evaluate against each file name and skip loading on matches.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.FilePathToAssemblyMap">
            <summary>
            Gets a map of the file paths discovered to the <see cref="T:System.Reflection.Assembly" /> loaded.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.SymbolFilePaths">
            <summary>
            Gets a list of the discovered symbol file paths.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DirectoryPath">
            <summary>
            Gets the directory path to discover assemblies in.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.LoadRecursively">
            <summary>
            Gets a value indicating whether or not to discover recursively within the directory.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.AssemblyFileExtensionsWithoutPeriodToLoad">
            <summary>
            Gets the assembly file extensions to process; ONLY the file extension not including the period e.g. "dll" NOT ".dll".
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.SymbolFileExtensionsWithoutPeriodToConsider">
            <summary>
            Gets the symbol file extensions to process; ONLY the file extension not including the period e.g. "pdb" NOT ".pdb".
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.AssemblyFileNameRegexBlacklist">
            <summary>
            Gets the list of regular expressions to evaluate against each file name and skip loading on matches.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyLoader.GetLoadedAssemblies">
            <summary>
            Gets the currently loaded assemblies (excluding dynamic ones).
            </summary>
            <remarks>
            If you want to get all types, then pass-in the result of this call into AssemblyHelper.GetTypesFromAssemblies().
            </remarks>
            <returns>Currently loaded assemblies.</returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyLoader.CreateAndLoadFromDirectory(System.String,System.Action{System.String},System.Boolean,System.Collections.Generic.IReadOnlyCollection{System.String},System.Collections.Generic.IReadOnlyCollection{System.String},System.Collections.Generic.IReadOnlyCollection{System.String},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Factory method to build an initialized <see cref="T:OBeautifulCode.Reflection.Recipes.AssemblyLoader" />.
            </summary>
            <param name="directoryPath">Directory path to discover and load assemblies from.</param>
            <param name="logger">Optional logger action to log progress and messages; DEFAULT is none.</param>
            <param name="loadRecursively">Optional value indicating whether or not to discover recursively within the directory; DEFAULT is true.</param>
            <param name="assemblyFileExtensionsWithoutDotToLoad">Optional list of assembly file extensions to process; ONLY the file extension not including the period e.g. "dll" NOT ".dll"; DEFAULT is <see cref="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultAssemblyFileExtensionsWithoutPeriodToLoad" />.</param>
            <param name="symbolFileExtensionsWithoutPeriodToConsider">Optional list of symbol file extensions to process; ONLY the file extension not including the period e.g. "pdb" NOT ".pdb"; DEFAULT is <see cref="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultSymbolFileExtensionsWithoutPeriodToLoad" />.</param>
            <param name="assemblyFileNameRegexBlacklist">Optional list of regular expressions to evaluate against each file name and skip loading on matches; DEFAULT is <see cref="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultAssemblyFileNameRegexBlacklist" />.</param>
            <param name="suppressFileLoadException">Optionally suppress <see cref="T:System.IO.FileLoadException"/>.</param>
            <param name="suppressBadImageFormatException">Optionally suppress <see cref="T:System.BadImageFormatException"/>.</param>
            <param name="suppressReflectionTypeLoadException">Optionally suppress <see cref="T:System.Reflection.ReflectionTypeLoadException"/>.</param>
            <returns>Initialized <see cref="T:OBeautifulCode.Reflection.Recipes.AssemblyLoader" /> this needs to be in scope and is disposable so keep this alive at your most top level while reflecting.</returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyLoader.Initialize(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initializes the manager by configuring <see cref="T:System.AppDomain" /> hooks and discovering then loading the assemblies in the given path.
            </summary>
            <param name="suppressFileLoadException">Optionally suppress <see cref="T:System.IO.FileLoadException"/>.</param>
            <param name="suppressBadImageFormatException">Optionally suppress <see cref="T:System.BadImageFormatException"/>.</param>
            <param name="suppressReflectionTypeLoadException">Optionally suppress <see cref="T:System.Reflection.ReflectionTypeLoadException"/>.</param>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyLoader.Dispose">
            <inheritdoc cref="T:System.IDisposable" />
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.BindingFlagsFor">
            <summary>
            Contains some pre-configured <see cref="T:System.Reflection.BindingFlags"/>.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredAndInheritedMembers">
            <summary>
            Finds all (public, protected, internal, private) instance and static members that are declared at the level of the specified type's hierarchy or inherited.
            Note that when an interface implements another interface (and so on), those implemented interfaces are NOT considered to be inherited.
            <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)"/>
            Note that private members in specified type's inheritance path are NOT inherited.  Public, internal, and protected members are.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredAndInheritedInstanceMembers">
            <summary>
            Finds all (public, protected, internal, private) instance (not static) members that are declared at the level of the specified type's hierarchy or inherited.
            Note that when an interface implements another interface (and so on), those implemented interfaces are NOT considered to be inherited.
            <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)"/>
            Note that private members in specified type's inheritance path are NOT inherited.  Public, internal, and protected members are.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredAndInheritedStaticMembers">
            <summary>
            Finds all static (not instance) members that are declared at the level of the specified type's hierarchy or inherited.
            Note that when an interface implements another interface (and so on), those implemented interfaces are NOT considered to be inherited.
            <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)"/>
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredAndInheritedMembers">
            <summary>
            Finds public (not protected, not internal, not private) instance and public static members that are declared at the level of the specified type's hierarchy or inherited.
            Note that when an interface implements another interface (and so on), those implemented interfaces are NOT considered to be inherited.
            <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)"/>
            Note that private members in specified type's inheritance path are NOT inherited.  Public, internal, and protected members are.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredAndInheritedInstanceMembers">
            <summary>
            Finds public (not protected, not internal, not private) instance (not static) members that are declared at the level of the specified type's hierarchy or inherited.
            Note that when an interface implements another interface (and so on), those implemented interfaces are NOT considered to be inherited.
            <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)"/>
            Note that private members in specified type's inheritance path are NOT inherited.  Public, internal, and protected members are.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredAndInheritedStaticMembers">
            <summary>
            Finds public (not protected, not internal, not private) static (not instance) members that are declared at the level of the specified type's hierarchy or inherited.
            Note that private members in specified type's inheritance path are NOT inherited.  Public, internal, and protected members are.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredButNotInheritedMembers">
            <summary>
            Finds all (public, protected, internal, private) instance and static members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredButNotInheritedInstanceMembers">
            <summary>
            Finds all (public, protected, internal, private) instance (not static) members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredButNotInheritedStaticMembers">
            <summary>
            Finds all (public, protected, internal, private) static (not instance) members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredButNotInheritedMembers">
            <summary>
            Finds public (not protected, not internal, not private) instance or static members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredButNotInheritedInstanceMembers">
            <summary>
            Finds public (not protected, not internal, not private) instance (not static) members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredButNotInheritedStaticMembers">
            <summary>
            Finds public (not protected, not internal, not private) static (not instance) members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.CompressionMethod">
            <summary>
            Determines the compression algorithm and/or archive file format used to compress a resource.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.CompressionMethod.None">
            <summary>
            The resource is not compressed.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.CompressionMethod.Gzip">
            <summary>
            The resource is compressed using the gzip file format,
            using the DEFLATE algorithm.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy">
            <summary>
            Specifies the strategy to use when matching constructors and properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy.Invalid">
            <summary>
            Invalid (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy.AllConstructorParametersHaveMatchingProperty">
            <summary>
            Include constructors where every constructor parameter matches to a property.
            If there a default (parameterless) constructor, it will be considered a match
            regardless of the properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy.AllConstructorParametersHaveMatchingPropertyWithNoUnmatchedProperties">
            <summary>
            Include constructors where every constructor parameter matches to a property
            and there are no unmatched properties.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers">
            <summary>
            Scopes the search for members based on access modifiers.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.Public">
            <summary>
            Include public members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.Internal">
            <summary>
            Include internal members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.ProtectedInternal">
            <summary>
            Include internal members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.Protected">
            <summary>
            Include protected members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PrivateProtected">
            <summary>
            Include private protected members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.Private">
            <summary>
            Include private members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PublicGet">
            <summary>
            Include properties with a public getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.InternalGet">
            <summary>
            Include properties with a internal getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.ProtectedInternalGet">
            <summary>
            Include properties with a protected internal getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.ProtectedGet">
            <summary>
            Include properties with a protected getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PrivateProtectedGet">
            <summary>
            Include properties with a private protected getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PrivateGet">
            <summary>
            Include properties with a private getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PublicSet">
            <summary>
            Include properties with a public setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.InternalSet">
            <summary>
            Include properties with a internal setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.ProtectedInternalSet">
            <summary>
            Include properties with a protected internal setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.ProtectedSet">
            <summary>
            Include properties with a protected setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PrivateProtectedSet">
            <summary>
            Include properties with a private protected setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PrivateSet">
            <summary>
            Include properties with a private setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.All">
            <summary>
            Include members having any supported access modifier.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberAttributes">
            <summary>
            Scopes the search for members based on the presence or absence of certain attributes on those members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAttributes.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAttributes.CompilerGenerated">
            <summary>
            Include compiler-generated members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAttributes.NotCompilerGenerated">
            <summary>
            Include members that are not compiler-generated.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAttributes.All">
            <summary>
            Include members having or not having all special attributes.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberKinds">
            <summary>
            Scopes the search for members based on the kind of member.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.Field">
            <summary>
            Include fields.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.Property">
            <summary>
            Include properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.Constructor">
            <summary>
            Include constructors.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.Method">
            <summary>
            Include methods.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.Event">
            <summary>
            Include events.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.NestedType">
            <summary>
            Include nested types.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.All">
            <summary>
            Include all kinds of members.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberMutability">
            <summary>
            Scopes the search for members based on mutability.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.Applicable">
            <summary>
            Include members where mutability is applicable (i.e. fields and properties).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.NotApplicable">
            <summary>
            Include members where mutability is not applicable (i.e. constructors, methods, events).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.Readable">
            <summary>
            Include readable properties and all fields, otherwise not applicable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.Writable">
            <summary>
            Include writable members.
            This is only applicable to fields (readonly and const fields are NOT considered writable) and properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.NotWritable">
            <summary>
            Include members that cannot be written-to.
            This is only applicable to fields (readonly and const fields are considered to be not writable) and properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.NotReadable">
            <summary>
            Include properties that are not readable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.ReadOnlyOrConst">
            <summary>
            Include members that cannot be written-to.
            This is only applicable to fields (readonly and const) and properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.WriteOnly">
            <summary>
            Include properties that are not readable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.All">
            <summary>
            Include members where mutability is not applicable and where applicable,
            include members with any kind of mutability.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberOwners">
            <summary>
            Scopes the search for members based on who owns the member.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberOwners.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberOwners.Instance">
            <summary>
            Include members owned by an object.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberOwners.Static">
            <summary>
            Include members owned by the type itself.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberOwners.All">
            <summary>
            Include members owned by an object or owned by the type itself.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberRelationships">
            <summary>
            Scopes the search for members based on their relationship to a specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInType">
            <summary>
            Include members declared in the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.InheritedByType">
            <summary>
            Include members inherited by the specified type.
            Private members of base types are not inherited and would not be
            returned when using this flag; <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInAncestorTypes"/>.
            </summary>
            <remarks>
            Inherited members' <see cref="P:System.Reflection.MemberInfo.ReflectedType"/> will be the specified type,
            NOT the <see cref="P:System.Reflection.MemberInfo.DeclaringType"/>.  There is a subtle but consequential
            difference between the members returned when this flag is set versus those returned
            when <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInAncestorTypes"/> is set
            (if both are set, then only <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInAncestorTypes"/> is used).
            Because the <see cref="P:System.Reflection.MemberInfo.ReflectedType"/> type is different, the members
            may have different property values.  For example, if a base class contains a public
            property with a private setter, the <see cref="P:System.Reflection.PropertyInfo.SetMethod"/> will be
            null using <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.InheritedByType"/>, and not null when using <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInAncestorTypes"/>.
            The property will NOT be considered <see cref="F:OBeautifulCode.Reflection.Recipes.MemberMutability.Writable"/> when
            <see cref="P:System.Reflection.PropertyInfo.SetMethod"/> is null.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInAncestorTypes">
            <summary>
            Include members declared in all ancestor types.
            This would include private members of base types.
            </summary>
            <remarks>
            This flag supersedes <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.InheritedByType"/>.
            Unlike <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.InheritedByType"/>, members declared in ancestor types will
            have a <see cref="P:System.Reflection.MemberInfo.ReflectedType"/> that equals <see cref="P:System.Reflection.MemberInfo.DeclaringType"/>
            See remarks for <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.InheritedByType"/> about why/when this matters.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInImplementedInterfaceTypes">
            <summary>
            Include members declared in all interfaces implemented by the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredOrInherited">
            <summary>
            Include members declared in or inherited by the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInTypeOrAncestorTypes">
            <summary>
            Include members that are declared in the specified type or declared in all ancestor types.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInTypeOrImplementedInterfaces">
            <summary>
            Include members that are declared in the specified type or are declared in all interfaces implemented by the specified type.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.OrderMembersBy">
            <summary>
            Specifies how to order members in a method that returns members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.OrderMembersBy.None">
            <summary>
            None (default).  No particular order.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.OrderMembersBy.MemberName">
            <summary>
            Order by member name.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.OrderMembersBy.DeclaringTypeDerivationPath">
            <summary>
            Order by the declaring type derivation path
            (e.g. members declared in type.BaseType.BaseType, followed by type.BaseType, followed by the type itself).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.OrderMembersBy.DeclaringTypeDerivationPathThenByMemberName">
            <summary>
            Order first by the declaring type derivation path
            (e.g. members declared in type.BaseType.BaseType, followed by type.BaseType, followed by the type itself)
            and then by member name within each of these.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.ReflectionHelper">
            <summary>
            Provides useful methods related to reflection.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttribute``1(System.Type)">
            <summary>
            Gets the specified type of attribute, applied to a specified type.
            </summary>
            <typeparam name="TAttribute">The type of the attribute to return.</typeparam>
            <param name="type">The type to scope the attribute search to.</param>
            <returns>
            The attribute of type <typeparamref name="TAttribute"/> that has been applied
            to <paramref name="type"/> or null if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="type"/> has multiple attributes of type <typeparamref name="TAttribute"/>.  Consider calling <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributes``1(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributes``1(System.Type)">
            <summary>
            Gets all attributes of a specified type that have been applied to some type.
            Only useful when the attribute is configured such that more one instance can be applied.
            </summary>
            <remarks>
            adapted from <a href="http://stackoverflow.com/a/2656211/356790"/>.
            </remarks>
            <typeparam name="TAttribute">The type of the attributes to return.</typeparam>
            <param name="type">The type to scope the attribute search to.</param>
            <returns>
            A collection all attributes of the specified type that have been applied to the specified
            enum value or an empty collection if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributeOnEnumValue``1(System.Object)">
            <summary>
            Gets the specified type of attribute, applied to a specific enum value.
            </summary>
            <typeparam name="TAttribute">The type of the attribute to return.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <returns>
            An attribute object of the specified type that has been applied to the specified
            enum value or null if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumValue"/> is not an Enum.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="enumValue"/> has multiple attributes of type <typeparamref name="TAttribute"/>.  Consider calling <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributesOnEnumValue``1(System.Enum)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributeOnEnumValue``1(System.Enum)">
            <summary>
            Gets the specified type of attribute, applied to a specific enum value.
            </summary>
            <typeparam name="TAttribute">The type of the attribute to return.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <returns>
            An attribute object of the specified type that has been applied to the specified
            enum value or null if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="enumValue"/> has multiple attributes of type <typeparamref name="TAttribute"/>.  Consider calling <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributesOnEnumValue``1(System.Enum)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributesOnEnumValue``1(System.Object)">
            <summary>
            Gets all attributes of the specified type that have been applied to a specific enum value.
            Only useful when the attribute is configured such that more one instance can be applied to an enum value.
            </summary>
            <typeparam name="TAttribute">The type of the attributes to return.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <returns>
            A collection all attributes of the specified type that have been applied to the specified
            enum value or an empty collection if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumValue"/> is not an Enum.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributesOnEnumValue``1(System.Enum)">
            <summary>
            Gets all attributes of the specified type that have been applied to a specific enum value.
            Only useful when the attribute is configured such that more one instance can be applied to an enum value.
            </summary>
            <remarks>
            adapted from <a href="http://stackoverflow.com/a/9276348/356790"/>.
            </remarks>
            <typeparam name="TAttribute">The type of the attributes to return.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <returns>
            A collection all attributes of the specified type that have been applied to the specified
            enum value or an empty collection if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasAttribute``1(System.Type,System.Boolean)">
            <summary>
            Determines if an attribute of a specified type that have been applied to some type.
            </summary>
            <typeparam name="TAttribute">The type of the attributes to search for.</typeparam>
            <param name="type">The type to scope the attribute search to.</param>
            <param name="throwOnMultiple">
            Optional.  Determines if method should throw when multiple instances of the specified
            attribute have been applied to the specified type.  Default is true
            (it's typically unlikely that multiple attributes of the same type are applied to a type).
            </param>
            <returns>
            True if the attribute has been applied to the specified type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="throwOnMultiple"/> is true and <paramref name="type"/> has multiple attributes of type <typeparamref name="TAttribute"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasAttributeOnEnumValue``1(System.Object,System.Boolean)">
            <summary>
            Determines if an attribute of the specified type has been applied to a specific enum value.
            </summary>
            <typeparam name="TAttribute">The type of the attributes to search for.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <param name="throwOnMultiple">
            Optional.  Determines if method should throw when multiple instances of the specified
            attribute have been applied to the specified enum value.  Default is true
            (it's typically unlikely that multiple attributes of the same type are applied to an enum value).
            </param>
            <returns>
            True if the attribute has been applied to the specified enum value, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumValue"/> is not an Enum.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="throwOnMultiple"/> is true and <paramref name="enumValue"/> has multiple attributes of type <typeparamref name="TAttribute"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasAttributeOnEnumValue``1(System.Enum,System.Boolean)">
            <summary>
            Determines if an attribute of the specified type that has been applied to a specific enum value.
            </summary>
            <typeparam name="TAttribute">The type of the attributes to search for.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <param name="throwOnMultiple">
            Optional.  Determines if method should throw when multiple instances of the specified
            attribute have been applied to the specified enum value.  Default is true
            (it's typically unlikely that multiple attributes of the same type are applied to an enum value).
            </param>
            <returns>
            True if the attribute has been applied to the specified enum value, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetConstructorsFiltered(System.Type,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberAttributes,OBeautifulCode.Reflection.Recipes.OrderMembersBy)">
            <summary>
            Gets the constructors of the specified type,
            with various options to control the scope of constructors included and optionally order the constructors.
            </summary>
            <param name="type">The type.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
            <returns>
            The constructors in the specified order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.Construct(System.Type,System.Object[])">
            <summary>
            Constructs an object of the specified type.
            </summary>
            <param name="type">The type of object to construct.</param>
            <param name="parameters">
            An array of arguments that match in number, order, and type the parameters of the constructor to invoke.
            If an empty array or null, the constructor that takes no parameters (the default constructor) is invoked.
            </param>
            <returns>
            A reference to the newly created object.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.Exception">Various exceptions thrown by <see cref="M:System.Activator.CreateInstance(System.Type,System.Object[])"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.Construct``1(System.Object[])">
            <summary>
            Constructs an object of the specified type.
            </summary>
            <typeparam name="T">The type of object to create.</typeparam>
            <param name="parameters">
            An array of arguments that match in number, order, and type the parameters of the constructor to invoke.
            If an empty array or null, the constructor that takes no parameters (the default constructor) is invoked.
            </param>
            <returns>
            A reference to the newly created object.
            </returns>
            <exception cref="T:System.Exception">Any exception thrown by <see cref="M:System.Activator.CreateInstance(System.Type,System.Object[])"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.Construct``1(System.Type,System.Object[])">
            <summary>
            Constructs an object of the specified type.
            </summary>
            <typeparam name="T">The return type.</typeparam>
            <param name="type">The type of object to construct.</param>
            <param name="parameters">
            An array of arguments that match in number, order, and type the parameters of the constructor to invoke.
            If an empty array or null, the constructor that takes no parameters (the default constructor) is invoked.
            </param>
            <returns>
            A reference to the newly created object.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.Exception">Any exception thrown by <see cref="M:System.Activator.CreateInstance(System.Type,System.Object[])"/>.</exception>
            <exception cref="T:System.InvalidCastException">The created object could not be cast to a <typeparamref name="T"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetConstructorsMatchedToProperties(System.Type,System.Collections.Generic.IReadOnlyCollection{System.Reflection.PropertyInfo},OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberRelationships)">
            <summary>
            Finds constructors having parameters that correspond to a set of properties, matching on name (case-insensitive) and type.
            </summary>
            <remarks>
            For type matching, we check that a constructor parameter type can be assigned it's corresponding property's type
            and vice-versa.  If either direction succeeds, we consider it a match.
            </remarks>
            <param name="classType">The class type.</param>
            <param name="properties">The properties.</param>
            <param name="matchStrategy">Determines which constructors will be deemed as matching.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for constructors based on access modifiers.  DEFAULT is to include public constructors.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for constructors based on their relationship to <paramref name="classType"/>.  DEFAULT is to include constructors declared on the type.</param>
            <returns>
            The matching constructors, or an empty collection if there are no matches.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="classType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="classType"/> is not a class.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="properties"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="properties"/> has a null element.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="properties"/> contains two or more members with the same name.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="matchStrategy"/> is <see cref="F:OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy.Invalid"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsDefaultConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Determines if the specified constructor is the default (parameterless) constructor.
            </summary>
            <param name="constructor">The constructor.</param>
            <returns>
            true if the specified constructor is the default (parameterless) constructor; otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetTypesHaving``1(System.Reflection.Assembly,System.Func{``0,System.Boolean})">
            <summary>
            Gets all types in an assembly that have an attribute of a specified type.
            </summary>
            <typeparam name="TAttribute">The type of attribute to search for.</typeparam>
            <param name="assembly">The assembly to search.</param>
            <param name="attributeFilter">
            Optional.  When provided, requires that this filter
            return true when attributes of the specified type are passed-in,
            before the type having the specified attribute is returned.
            </param>
            <returns>
            The types in an assembly where the specified attribute has been
            applied at least one, or an empty collection if none of the
            types in the assembly have that attribute.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetEnumValuesHaving``2(System.Func{``1,System.Boolean})">
            <summary>
            Gets all values/members of an enum that have an attribute of a specified type.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <typeparam name="TAttribute">The type of attribute to search for.</typeparam>
            <param name="attributeFilter">
            Optional.  When provided, requires that this filter
            return true when attributes of the specified type are passed-in,
            before the enum value having the specified attribute is returned.
            </param>
            <returns>
            The values/members of a specified enum values where the specified
            attribute has been applied at least one, or an empty collection if none of the specified
            enum values have that attribute.
            </returns>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not an enum.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetEnumValuesHaving``1(System.Type,System.Func{``0,System.Boolean})">
            <summary>
            Gets all values/members of an enum that have an attribute of a specified type.
            </summary>
            <typeparam name="TAttribute">The type of attribute to search for.</typeparam>
            <param name="enumType">The type of the enum.</param>
            <param name="attributeFilter">
            Optional.  When provided, requires that this filter
            return true when attributes of the specified type are passed-in,
            before the enum value having the specified attribute is returned.
            </param>
            <returns>
            The values/members of a specified enum values where the specified
            attribute has been applied at least one, or an empty collection if none of the specified
            enum values have that attribute.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> is not an enum.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetFieldsFiltered(System.Type,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes,OBeautifulCode.Reflection.Recipes.OrderMembersBy)">
            <summary>
            Gets the fields of the specified type,
            with various options to control the scope of fields included and optionally order the fields.
            </summary>
            <param name="type">The type.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
            <returns>
            The fields in the specified order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetFieldFiltered(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes,System.Boolean)">
            <summary>
            Gets the <see cref="T:System.Reflection.FieldInfo"/> for the specified field.
            </summary>
            <param name="type">The type.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="throwIfNotFound">OPTIONAL value indicating whether to throw if no fields are found.  DEFAULT is to throw..</param>
            <returns>
            The <see cref="T:System.Reflection.FieldInfo"/> or null if no fields are found and <paramref name="throwIfNotFound"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints and <paramref name="throwIfNotFound"/> is true.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetFieldValue``1(System.Object,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a field.
            </summary>
            <typeparam name="T">The type of the field.</typeparam>
            <param name="item">The object.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the field.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The field does not have a get method.</exception>
            <exception cref="T:System.InvalidCastException">The field is not of the specified type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetFieldValue(System.Object,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a field.
            </summary>
            <param name="item">The object.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the field.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The field does not have a get method.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetStaticFieldValue``1(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a static field.
            </summary>
            <typeparam name="T">The type of the field.</typeparam>
            <param name="type">The type that contains the field.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the field.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The field does not have a get method.</exception>
            <exception cref="T:System.InvalidCastException">The field is not of the specified type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetStaticFieldValue(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a field on a static type.
            </summary>
            <param name="type">The type that contains the field.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the field.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The field does not have a get method.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasField(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Determines if a type has a field of the specified field name.
            </summary>
            <param name="type">The type to check.</param>
            <param name="fieldName">The name of the field to check for.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            true if the type has a field of the specified field name, false if not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsConstField(System.Reflection.FieldInfo)">
            <summary>
            Determines if the specified field is const (not readonly).
            </summary>
            <param name="fieldInfo">The field.</param>
            <returns>
            true if the specified field is const (not readonly), otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsNotWritableField(System.Reflection.FieldInfo)">
            <summary>
            Determines if the specified field is not writable (is readonly or const).
            </summary>
            <param name="fieldInfo">The field.</param>
            <returns>
            true if the specified field is not writable, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsReadOnlyField(System.Reflection.FieldInfo)">
            <summary>
            Determines if the specified field is readonly (not const).
            </summary>
            <param name="fieldInfo">The field.</param>
            <returns>
            true if the specified field is readonly (not const), otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsReadOnlyOrConstField(System.Reflection.FieldInfo)">
            <summary>
            Determines if the specified field is readonly or const.
            </summary>
            <param name="fieldInfo">The field.</param>
            <returns>
            true if the specified field is readonly or const, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsWritableField(System.Reflection.FieldInfo)">
            <summary>
            Determines if the specified field is writable (not readonly and not const).
            </summary>
            <param name="fieldInfo">The field.</param>
            <returns>
            true if the specified field is writable, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.SetFieldValue(System.Object,System.String,System.Object,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Sets a field's value.
            </summary>
            <param name="item">The object.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="value">The value to set the field to.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign null to the field's type.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign <paramref name="value"/> type to the field's type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.SetStaticFieldValue(System.Type,System.String,System.Object,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Sets a static field's value.
            </summary>
            <param name="type">The type that contains the field.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="value">The value to set the field to.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign null to the field's type.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign <paramref name="value"/> type to the field's type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetMembersFiltered(System.Type,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberKinds,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes,OBeautifulCode.Reflection.Recipes.OrderMembersBy)">
            <summary>
            Gets the members (fields, properties, constructors, methods, and events) of the specified type,
            with various options to control the scope of members included and optionally order the members.
            </summary>
            <param name="type">The type.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberKinds">OPTIONAL value that scopes the search for members based on the kind of member.  DEFAULT is to include all kinds of members.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
            <returns>
            The members in the specified order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsCompilerGenerated(System.Reflection.MemberInfo)">
            <summary>
            Determines if the specified member is compiler-generated.
            </summary>
            <param name="memberInfo">The member info.</param>
            <returns>
            True if the member is compiler-generated, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetUnderlyingType(System.Reflection.MemberInfo)">
            <summary>
            Gets the underlying type of the specified <see cref="T:System.Reflection.MemberInfo"/>.
            </summary>
            <param name="memberInfo">The member info.</param>
            <returns>
            The underlying type of the specified <see cref="T:System.Reflection.MemberInfo"/>.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetMethodsFiltered(System.Type,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberAttributes,OBeautifulCode.Reflection.Recipes.OrderMembersBy)">
            <summary>
            Gets the methods of the specified type,
            with various options to control the scope of methods included and optionally order the methods.
            </summary>
            <param name="type">The type.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
            <returns>
            The methods in the specified order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)">
            <summary>
            Gets the specified interface type's methods along with the methods of all implemented interfaces.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <returns>
            The methods declared on the specified interface along with the methods of all implemented interfaces.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="interfaceType"/> is not an interface type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetMethodFiltered(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberAttributes,System.Boolean)">
            <summary>
            Gets the <see cref="T:System.Reflection.MethodInfo"/> for the specified method.
            </summary>
            <param name="type">The type.</param>
            <param name="methodName">The name of the method.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="throwIfNotFound">OPTIONAL value indicating whether to throw if no methods are found.  DEFAULT is to throw..</param>
            <returns>
            The <see cref="T:System.Reflection.MethodInfo"/> or null if no methods are found and <paramref name="throwIfNotFound"/> is false
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="methodName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="methodName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no method named <paramref name="methodName"/> on the object type using the specified binding constraints and <paramref name="throwIfNotFound"/> is true.</exception>
            <exception cref="T:System.ArgumentException">There is more than one method named <paramref name="methodName"/> on the object type using the specified binding constraints.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasMethod(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Determines if a type has a method of the specified method name.
            </summary>
            <param name="type">The type to check.</param>
            <param name="methodName">The name of the method to check for.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            true if the type has a method of the specified method name, false if not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="methodName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="methodName"/> is whitespace.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetPropertiesFiltered(System.Type,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes,OBeautifulCode.Reflection.Recipes.OrderMembersBy)">
            <summary>
            Gets the properties of the specified type,
            with various options to control the scope of properties included and optionally order the properties.
            </summary>
            <param name="type">The type.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
            <returns>
            The properties in the specified order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetPropertyFiltered(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes,System.Boolean)">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the specified property.
            </summary>
            <param name="type">The type.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="throwIfNotFound">OPTIONAL value indicating whether to throw if no properties are found.  DEFAULT is to throw..</param>
            <returns>
            The <see cref="T:System.Reflection.PropertyInfo"/> or null if no properties are found and <paramref name="throwIfNotFound"/> is false
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints and <paramref name="throwIfNotFound"/> is true.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetPropertyValue``1(System.Object,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a property.
            </summary>
            <typeparam name="T">The type of the property.</typeparam>
            <param name="item">The object.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the property.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The property does not have a get method.</exception>
            <exception cref="T:System.InvalidCastException">The property is not of the specified type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetPropertyValue(System.Object,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a property.
            </summary>
            <param name="item">The object.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the property.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The property does not have a get method.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetStaticPropertyValue``1(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a static property.
            </summary>
            <typeparam name="T">The type of the property.</typeparam>
            <param name="type">The type that contains the property.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the property.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The property does not have a get method.</exception>
            <exception cref="T:System.InvalidCastException">The property is not of the specified type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetStaticPropertyValue(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a property on a static type.
            </summary>
            <param name="type">The type that contains the property.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the property.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The property does not have a get method.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasProperty(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Determines if a type has a property of the specified property name.
            </summary>
            <param name="type">The type to check.</param>
            <param name="propertyName">The name of the property to check for.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            true if the type has a property of the specified property name, false if not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsNotWritableProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is not writable (is read-only).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is not writable, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsNotReadableProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is not readable (is write-only).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is not readable, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsReadableProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is readable (has a getter).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is readable, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsReadOnlyProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is a read-only (has no setter).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is read-only, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsReadOnlyAutoProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is a read-only auto property
            (i.e. MyProperty { get; }).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is a read-only auto-property, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsWritableProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is writable (has a setter).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is writable, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsWriteOnlyProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is a write-only (has no getter).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is write-only, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.SetPropertyValue(System.Object,System.String,System.Object,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Sets a property's value.
            </summary>
            <param name="item">The object.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="value">The value to set the property to.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign null to the property's type.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign <paramref name="value"/> type to the property's type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.SetStaticPropertyValue(System.Type,System.String,System.Object,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Sets a static property's value.
            </summary>
            <param name="type">The type that contains the property.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="value">The value to set the property to.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign null to the property's type.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign <paramref name="value"/> type to the property's type.</exception>
        </member>
        <member name="T:OBeautifulCode.String.Recipes.StringExtensions">
            <summary>
            Adds some convenient extension methods to strings.
            </summary>
        </member>
        <member name="F:OBeautifulCode.String.Recipes.StringExtensions.DateTimeKindToPreferredFormatStringMap">
            <summary>
            Specifies a map of <see cref="T:System.DateTimeKind"/> to the preferred format string to use for that kind.
            </summary>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.AppendMissing(System.String,System.String)">
            <summary>
            Appends one string to the another (base) if the base string
            doesn't already end with the string to append.
            </summary>
            <param name="value">The base string.</param>
            <param name="shouldEndWith">The string to append.</param>
            <remarks>
            If the string to append is the empty string, this method will always return the base string.
            </remarks>
            <returns>
            The inputted string where the last character is a backslash.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="shouldEndWith"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.FromCsv(System.String,System.String)">
            <summary>
            Parses a CSV string and returns the values.
            </summary>
            <param name="value">The CSV to parse.</param>
            <param name="nullValueEncoding">Optional value indicating how nulls are encoded.  Defaulted to null, which results in a list that never contains null.</param>
            <returns>
            Returns the values contained within a CSV.
            If <paramref name="value"/> is null, returns an empty list.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.IsAlphanumeric(System.String)">
            <summary>
            Determines if a string is alpha numeric.
            </summary>
            <param name="value">The string to evaluate.</param>
            <remarks>
            An empty string ("") is considered alpha-numeric.
            </remarks>
            <returns>
            Returns true if the string is alpha-numeric, false if not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.IsAlphabetic(System.String)">
            <summary>
            Determines if a string is alphabetic.
            </summary>
            <param name="value">The string to evaluate.</param>
            <remarks>
            An empty string ("") is considered alphabetic.
            </remarks>
            <returns>
            Returns true if the string is alphabetic, false if not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.IsAsciiPrintable(System.String)">
            <summary>
            Determines if a string is in the ASCII printable character set.
            </summary>
            <param name="value">The string to evaluate.</param>
            <remarks>
            An empty string ("") is considered to be in the printable set.
            </remarks>
            <returns>
            Returns true if all of the characters in the string are printable; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ReplaceCaseInsensitive(System.String,System.String,System.String)">
            <summary>
            Performs a fast case-insensitive string replacement.
            </summary>
            <remarks>
            adapted from <a href="http://www.codeproject.com/KB/string/fastestcscaseinsstringrep.aspx"/>
            If newValue is null, all occurrences of oldValue are removed.
            </remarks>
            <param name="value">the string being searched.</param>
            <param name="oldValue">string to be replaced.</param>
            <param name="newValue">string to replace all occurrences of oldValue.</param>
            <returns>
            A string where the case-insensitive string replacement has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="oldValue"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="oldValue"/> is an empty string.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ReplaceTokens(System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Replaces tokens in a specified string value with the specified replacement values.
            </summary>
            <remarks>
            DO NOT use this method if your replacement values contain tokens themselves.
            This method does not process tokens in any guaranteed order.
            </remarks>
            <param name="value">The string containing tokens to replace.</param>
            <param name="tokenToReplacementValueMap">
            A map of the case-sensitive tokens to their replacement values.
            If a replacement value is null, an empty string will be used.
            </param>
            <returns>
            The result of replacing all tokens in <paramref name="value"/> with their replacement value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="tokenToReplacementValueMap"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.SplitIntoChunksOfLength(System.String,System.Int32)">
            <summary>
            Splits a string into chunks of a specified length.
            </summary>
            <param name="value">The string to split.</param>
            <param name="lengthPerChunk">The length of each chunk when splitting the specified string.</param>
            <returns>
            <paramref name="value"/> split into an ordered list of chunks, where each chunk is of length <paramref name="lengthPerChunk"/>.
            If the length of <paramref name="value"/> cannot be evenly divided by <paramref name="lengthPerChunk"/>, then the last
            chunk will contain less characters.  No characters are truncated.  If <paramref name="value"/> is the empty string
            then an empty list is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengthPerChunk"/> is &lt;= 0.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToAlphanumeric(System.String)">
            <summary>
            Converts the specified string to an alpha-numeric string
            by removing all non-alpha-numeric characters.
            </summary>
            <param name="value">The string to convert.</param>
            <remarks>
            An empty string ("") is considered alpha-numeric.
            </remarks>
            <returns>
            The specified string with all non-alpha-numeric characters removed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToAsciiBytes(System.String)">
            <summary>
            Encodes all characters in a given string to an array of bytes encoded in ASCII.
            </summary>
            <param name="value">The string to encode.</param>
            <returns>byte array representing the string in ASCII.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToBytes(System.String,System.Text.Encoding)">
            <summary>
            Converts a string to a byte-array with a given encoding.
            </summary>
            <param name="value">The string to encode.</param>
            <param name="encoding">The encoding to use.</param>
            <returns>byte array representing the string in a given encoding.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="encoding"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToCsvSafe(System.String)">
            <summary>
            Makes a string safe to insert as a value into a
            comma separated values (CSV) object such as a file.
            </summary>
            <remarks>
            Here are the rules for making a string CSV safe:
            <a href="http://en.wikipedia.org/wiki/Comma-separated_values" />.
            </remarks>
            <param name="value">The string to make safe.</param>
            <returns>
            Returns a string that is safe to insert into a CSV object.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToLowerTrimmed(System.String)">
            <summary>
            Converts a string to lower-case and removes all leading and
            trailing white-space characters, using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <returns>The string converted to lower-case with all leading and trailing white-space characters removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToLowerTrimmed(System.String,System.Globalization.CultureInfo)">
            <summary>
            Converts a string to lower-case and removes all leading and
            trailing white-space characters, using the specified <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <param name="cultureInfo">Provides information about the specific culture.</param>
            <returns>The string converted to lower-case with all leading and trailing white-space characters removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="cultureInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUpperTrimmed(System.String)">
            <summary>
            Converts a string to upper-case and removes all leading and
            trailing white-space characters, using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <returns>The string converted to upper-case with all leading and trailing white-space characters removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUpperTrimmed(System.String,System.Globalization.CultureInfo)">
            <summary>
            Converts a string to upper-case and removes all leading and
            trailing white-space characters, using the specified <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <param name="cultureInfo">Provides information about the specific culture.</param>
            <returns>The string converted to upper-case with all leading and trailing white-space characters removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="cultureInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToLowerFirstCharacter(System.String)">
            <summary>
            Converts the first character of the specified string to lower-case, using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <returns>The string with the first character converted to lower-case.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToLowerFirstCharacter(System.String,System.Globalization.CultureInfo)">
            <summary>
            Converts the first character of the specified string to lower-case, using the specified <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <param name="cultureInfo">Provides information about the specific culture.</param>
            <returns>The string with the first character converted to lower-case.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="cultureInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.SByte)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.SByte},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Byte)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Byte},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Int16)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Int16},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.UInt16)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.UInt16},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Int32)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.UInt32)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.UInt32},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Int64)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Int64},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.UInt64)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.UInt64},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Single)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Single},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Double)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Double},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Decimal)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Decimal},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Guid)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Guid},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.DateTime)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.DateTime},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUpperFirstCharacter(System.String)">
            <summary>
            Converts the first character of the specified string to upper-case, using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <returns>The string with the first character converted to upper-case.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUpperFirstCharacter(System.String,System.Globalization.CultureInfo)">
            <summary>
            Converts the first character of the specified string to upper-case, using the specified <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <param name="cultureInfo">Provides information about the specific culture.</param>
            <returns>The string with the first character converted to upper-case.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="cultureInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUnicodeBytes(System.String)">
            <summary>
            Encodes all characters in a given string to an array of bytes encoded in unicode.
            </summary>
            <param name="value">The string to encode.</param>
            <returns>byte array representing the string in unicode.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUtf8Bytes(System.String)">
            <summary>
            Encodes all characters in a given string to an array of bytes encoded in UTF-8.
            </summary>
            <param name="value">The string to encode.</param>
            <returns>byte array representing the string in UTF-8.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.ArrayKind">
            <summary>
            Specifies the kind of array.
            </summary>
            <remarks>
            See <a href="https://stackoverflow.com/questions/60859850/how-to-determine-if-rank-1-array-is-a-vector-or-multidimensional-array?noredirect=1#comment107679655_60859850"/>.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.None">
            <summary>
            Not an array.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.Vector">
            <summary>
            A vector array.  Can only have a single dimension.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.Multidimensional">
            <summary>
            A multidimensional array.  Can have 1 to 32 dimensions.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.ToStringReadableOptions">
            <summary>
            Options for generating a readability-optimized string representation of a type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.None">
            <summary>
            None (default).
            Use this option to generate the most succinct representation of the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.IncludeNamespace">
            <summary>
            Include the namespace of the type.
            If the type is generic then also include the namespace of all generic argument types.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.IncludeAssemblyDetails">
            <summary>
            Include details (name and version) about the assembly that contains the type.
            If the type is generic then also include details about the assembly that contains
            all of the generic argument types.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions">
            <summary>
            Options for generating a XML doc compatible string representation of a type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions.None">
            <summary>
            None (default).
            Use this option to generate the most succinct representation of the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions.IncludeNamespace">
            <summary>
            Include the namespace of the type.
            If the type is generic then also include the namespace of all generic argument types.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.TypeExtensions">
            <summary>
            Extension methods on type <see cref="T:System.Type"/>.
            </summary>
            <remarks>
            These resources helped:
            <a href="https://stackoverflow.com/questions/13012733/difference-between-type-isgenerictypedefinition-and-type-containsgenericparamete" />.
            <a href="https://stackoverflow.com/questions/2173107/what-exactly-is-an-open-generic-type-in-net" />.
            <a href="https://stackoverflow.com/questions/1735035/generics-open-and-closed-constructed-types" />.
            <a href="https://stackoverflow.com/questions/25811514/detect-if-a-generic-type-is-open" />.
            <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
            <a href="https://stackoverflow.com/questions/31772922/difference-between-isgenerictype-and-isgenerictypedefinition" />.
            <a href="https://stackoverflow.com/questions/59144791/if-type-isgenericparameter-true-will-type-containsgenericparameters-true?noredirect=1#comment104515860_59144791" />.
            <a href="https://stackoverflow.com/questions/59141721/why-is-the-basetype-of-a-generic-type-definition-not-itself-a-generic-type-defin?noredirect=1#comment104515814_59141721" />.
            </remarks>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetArrayKind(System.Type)">
            <summary>
            Determines the kind of array that the specified type is.
            </summary>
            <param name="type">The type.</param>
            <returns>
            The kind of array of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedEnumerableElementType(System.Type)">
            <summary>
            Gets the type of the elements of a specified closed Enumerable type.
            </summary>
            <param name="type">The closed Enumerable type.</param>
            <returns>
            The type of the elements of the specified closed Enumerable type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Enumerable type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedDictionaryKeyType(System.Type)">
            <summary>
            Gets the type of the keys of a specified closed Dictionary type.
            </summary>
            <param name="type">The closed Dictionary type.</param>
            <returns>
            The type of the keys of the specified closed Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Dictionary type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedDictionaryValueType(System.Type)">
            <summary>
            Gets the type of the values of a specified closed Dictionary type.
            </summary>
            <param name="type">The closed Dictionary type.</param>
            <returns>
            The type of the values of the specified closed Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Dictionary type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemCollectionElementType(System.Type)">
            <summary>
            Gets the type of the elements of the specified closed <see cref="N:System"/> Collection type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Collection type.</param>
            <returns>
            The type of the elements of the specified closed <see cref="N:System"/> Collection type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Collection type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemCollectionType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemDictionaryKeyType(System.Type)">
            <summary>
            Gets the type of the keys of the specified closed <see cref="N:System"/> Dictionary type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Dictionary type.</param>
            <returns>
            The type of the keys of the specified closed <see cref="N:System"/> Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Dictionary type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemDictionaryValueType(System.Type)">
            <summary>
            Gets the type of the values of the specified closed <see cref="N:System"/> Dictionary type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Dictionary type.</param>
            <returns>
            The type of the values of the specified closed <see cref="N:System"/> Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Dictionary type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetGenericTypeDefinitionOrSpecifiedType(System.Type)">
            <summary>
            Gets the generic type definition of a specified type if the type is generic
            but not a generic type definition, otherwise returns the specified type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            If the specified type is a generic type but not a generic type definition then the
            generic type definition is returned, otherwise the specified type is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetInheritancePath(System.Type)">
            <summary>
            Gets the types in the inheritance path starting from the specified type's
            <see cref="P:System.Type.BaseType"/> and ending in a type with no <see cref="P:System.Type.BaseType"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            The <see cref="P:System.Type.BaseType"/> of <paramref name="type"/>, followed by that type's
            <see cref="P:System.Type.BaseType"/>, and so on until a type has no <see cref="P:System.Type.BaseType"/>
            (that property returns null).
            If <paramref name="type"/> has no <see cref="P:System.Type.BaseType"/>, then this method returns
            an empty list.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not assignable to <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.EnumerableInterfaceType"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasDefaultConstructor(System.Type)">
            <summary>
            Determines if the specified type has a default (public parameterless) constructor.
            </summary>
            <param name="type">Type to check.</param>
            <returns>
            A value indicating whether or not the type has a default (public parameterless) constructor.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasBaseType(System.Type)">
            <summary>
            Determines if the specified type has a base type.
            </summary>
            <returns>
            true if the specified type has a base type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasObjectAsBaseType(System.Type)">
            <summary>
            Determines if the base type of the specified type is object.
            </summary>
            <returns>
            true if the base type of the specified type is object, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer``1">
            <summary>
            Determines if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> will return a
            working (non-throwing) comparer for the specified type.
            </summary>
            <remarks>
            See remarks in <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer(System.Type)"/>.
            </remarks>
            <typeparam name="T">The type.</typeparam>
            <returns>
            true if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> returns a working (non-throwing)
            comparer for the specified type, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer(System.Type)">
            <summary>
            Determines if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> will return a
            working (non-throwing) comparer for the specified type.
            </summary>
            <remarks>
            <see cref="P:System.Collections.Generic.Comparer`1.Default" /> will always return some comparer for
            any given closed type.  However, that comparer, when used, will or will no
            throw based on the type itself.  If the type implements or inherits <see cref="T:System.IComparable`1"/>
            where T is itself, then the comparer will ultimately use that implementation.
            We say "ultimately" here and below because a wrapper object is used.
            If the type is nullable and the underlying type implements or inherits <see cref="T:System.IComparable`1"/>
            where T is the underlying type, then the comparer will ultimately use that implementation.
            Finally, if the the type, when boxed, implements or inherits <see cref="T:System.IComparable"/> then the comparer
            will ultimately use that implementation.  If not, then, upon using the comparer to compare two
            objects, an exception will be thrown.
            It's further important to note that this method is NOT simply checking whether the specified
            type is assignable to <see cref="T:System.IComparable`1"/>.  For example:
            typeof(IComparable&lt;string&gt;).HasWorkingDefaultComparer() == false
            That's because that type doesn't implement IComparable&lt;IComparable&lt;string&gt;&gt;
            per the heuristic described above.  That said, any type that is assignable to <see cref="T:System.IComparable"/>
            will return true per the heuristic above.  For example:
            typeof(IComparable).HasWorkingDefaultComparer() == true.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> returns a working (non-throwing)
            comparer for the specified type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="type"/> is an open type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsAssignableTo(System.Type,System.Type,System.Boolean)">
            <summary>
            Determines if a type if assignable to another type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/questions/74616/how-to-detect-if-type-is-another-generic-type/1075059#1075059" />.
            </remarks>
            <param name="type">The current type.</param>
            <param name="otherType">The type to check for ability to assign to.</param>
            <param name="treatGenericTypeDefinitionAsAssignableTo">If <paramref name="otherType"/> is a generic type definition, specifies whether the method should treat that type as if a closed type can be assigned to it (e.g. IsAssignableTo(List&lt;int&gt;, List&lt;&gt;)).</param>
            <returns>
            true if <paramref name="type"/> can be assigned to <paramref name="otherType"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherType"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="type"/> is an open type.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="otherType"/> is an open type, but not a generic type definition.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedTypeAssignableToNull(System.Type)">
            <summary>
            Determines if the specified type is closed and assignable to null.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/1770232/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is closed and assignable to null, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousType(System.Type)">
            <summary>
            Determines if a type is a closed anonymous type.
            </summary>
            <param name="type">Type to check.</param>
            <returns>A value indicating whether or not the type provided is a closed anonymous type.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousTypeFastCheck(System.Type)">
            <summary>
            Determines if a type is a closed anonymous type using a faster, but potentially
            less accurate heuristic than <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousType(System.Type)"/>.
            </summary>
            <param name="type">Type to check.</param>
            <returns>A value indicating whether or not the type provided is a closed anonymous type.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedGenericType(System.Type)">
            <summary>
            Determines if the specified type is a closed generic type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed generic type; otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedNonAnonymousClassType(System.Type)">
            <summary>
            Determines if the specified type is a class type, that's not anonymous, and is closed.
            </summary>
            <remarks>
            This is basically asking, "Is this a class type that can be constructed/new-ed up?".
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a class type, non-anonymous, and closed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedNullableType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Nullable`1"/> type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Nullable`1"/> type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="N:System"/> collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)">
            <summary>
            Determines if the specified type is a closed version one of one of the
            following <see cref="N:System"/> Dictionary generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemDictionaryGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="N:System"/> dictionary type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemEnumerableType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemKeyValuePairType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemOrderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following ordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemOrderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed, ordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemUnorderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following unordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemUnorderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed, unordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsNullableType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Nullable`1"/> type.
            </summary>
            <remarks>Adapted from: <a href="https://stackoverflow.com/a/41281601/356790" />.</remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Nullable`1"/> type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemType(System.Type)">
            <summary>
            Determines if the specified type is in the <see cref="N:System"/> namespace.
            </summary>
            <remarks>
            An array is considered a system type.
            A ValueTuple is considered a system type.
            A generic type parameter is considered a system type.
            An anonymous type is not considered a system type.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is in the <see cref="N:System"/> namespace, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="N:System"/> collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemDictionaryType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version one of one of the
            following <see cref="N:System"/> Dictionary generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemDictionaryGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="N:System"/> dictionary type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemEnumerableType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemKeyValuePairType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemOrderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following ordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemOrderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed, ordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemUnorderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following unordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemUnorderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed, unordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsTypeAssignableToNull(System.Type)">
            <summary>
            Determines if the specified type is assignable to null.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/1770232/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is assignable to null, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.MakeGenericTypeOrNull(System.Type,System.Type[])">
            <summary>
            Substitutes the elements of an array of types for the type parameters of the current
            generic type definition and returns a <see cref="T:System.Type"/> object representing the resulting constructed type
            or null if the operation cannot be performed.
            </summary>
            <param name="type">The generic type definition.</param>
            <param name="typeArguments">An array of types to be substituted for the type parameters of <paramref name="type"/>.</param>
            <returns>
            A <see cref="T:System.Type"/> representing the constructed type formed by substituting the
            elements of <paramref name="typeArguments"/> for the type parameters of <paramref name="type"/> or null
            if the operation cannot be performed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringCompilable(System.Type,System.Boolean)">
            <summary>
            Gets a compilable, readability-optimized string representation of the specified type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
            Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
            </remarks>
            <param name="type">The type.</param>
            <param name="throwIfNoCompilableStringExists">Optional value indicating whether to throw a <see cref="T:System.NotSupportedException"/> if there's no compilable representation of the specified type.</param>
            <returns>
            A compilable, readability-optimized string representation of the specified type
            OR
            null if there is no compilable representation and <paramref name="throwIfNoCompilableStringExists"/> is true.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic open constructed type, which is not supported.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic parameter.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringReadable(System.Type,OBeautifulCode.Type.Recipes.ToStringReadableOptions)">
            <summary>
            Gets a readability-optimized string representation of the specified type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
            Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
            Helpful breakdown of generics: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
            </remarks>
            <param name="type">The type.</param>
            <param name="options">The options to use when generating the string representation.</param>
            <returns>
            A readability-optimized string representation of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringXmlDoc(System.Type,System.Boolean,OBeautifulCode.Type.Recipes.ToStringXmlDocOptions)">
            <summary>
            Gets an XML-doc compatible string representation of the specified type.
            </summary>
            <param name="type">The type.</param>
            <param name="throwIfNoCompatibleStringExists">Optional value indicating whether to throw a <see cref="T:System.NotSupportedException"/> if there's no compatible string representation of the specified type.</param>
            <param name="options">The options to use when generating the string representation.</param>
            <returns>
            A XML-doc compatible string representation of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringWithoutGenericComponent(System.Type)">
            <summary>
            Gets a string representation of the specified type without the generic component.
            For example, Dictionary&lt;string, string&gt; would be represented as 'Dictionary'.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6386234/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            A string representation of the specified type with the generic component stripped out.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.TryMakeGenericType(System.Type,System.Type@,System.Type[])">
            <summary>
            Substitutes the elements of an array of types for the type parameters of the current
            generic type definition and returns a <see cref="T:System.Type"/> object representing the resulting constructed type.
            </summary>
            <param name="type">The generic type definition.</param>
            <param name="genericType">A <see cref="T:System.Type"/> representing the constructed type formed by substituting the elements of <paramref name="typeArguments"/> for the type parameters of <paramref name="type"/> or null if the operation cannot be performed.</param>
            <param name="typeArguments">An array of types to be substituted for the type parameters of <paramref name="type"/>.</param>
            <returns>
            true if the type was successfully constructed; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.Representation.System.AssemblyRepresentation">
            <summary>
            Representation of <see cref="T:System.Reflection.Assembly" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.AssemblyRepresentation"/> class.
            </summary>
            <param name="name">Name of the assembly.</param>
            <param name="version">Version of the assembly.</param>
            <param name="filePath">File path of the assembly observed.</param>
            <param name="frameworkVersion">Framework of assembly.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.AssemblyRepresentation.Name">
            <summary>
            Gets the name of the assembly.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.AssemblyRepresentation.Version">
            <summary>
            Gets the version of the assembly.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.AssemblyRepresentation.FilePath">
            <summary>
            Gets the file path the assembly was observed at.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.AssemblyRepresentation.FrameworkVersion">
            <summary>
            Gets the .NET framework the assembly was build for.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.op_Equality(OBeautifulCode.Representation.System.AssemblyRepresentation,OBeautifulCode.Representation.System.AssemblyRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.AssemblyRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.op_Inequality(OBeautifulCode.Representation.System.AssemblyRepresentation,OBeautifulCode.Representation.System.AssemblyRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.AssemblyRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.Equals(OBeautifulCode.Representation.System.AssemblyRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.DeepCloneWithName(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.Name" />.
            </summary>
            <param name="name">The new <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.Name" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.AssemblyRepresentation" /> using the specified <paramref name="name" /> for <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.Name" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.DeepCloneWithVersion(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.Version" />.
            </summary>
            <param name="version">The new <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.Version" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.AssemblyRepresentation" /> using the specified <paramref name="version" /> for <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.Version" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.DeepCloneWithFilePath(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.FilePath" />.
            </summary>
            <param name="filePath">The new <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.FilePath" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.AssemblyRepresentation" /> using the specified <paramref name="filePath" /> for <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.FilePath" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.DeepCloneWithFrameworkVersion(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.FrameworkVersion" />.
            </summary>
            <param name="frameworkVersion">The new <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.FrameworkVersion" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.AssemblyRepresentation" /> using the specified <paramref name="frameworkVersion" /> for <see cref="P:OBeautifulCode.Representation.System.AssemblyRepresentation.FrameworkVersion" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.AssemblyRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.AssemblyRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentationExtensions.ToRepresentation(System.Reflection.Assembly)">
            <summary>
            Reads the assembly to create a new <see cref="T:OBeautifulCode.Representation.System.AssemblyRepresentation"/>.
            </summary>
            <param name="assembly">The assembly object to interrogate.</param>
            <returns>
            Details about an assembly.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.AssemblyRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.AssemblyRepresentation)">
            <summary>
            Converts from the Representation back to the original.
            </summary>
            <param name="assemblyRepresentation">The assembly representation.</param>
            <returns>
            The assembly.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.ElementInitRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.ElementInit" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.MethodInfoRepresentation,System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ExpressionRepresentationBase})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.ElementInitRepresentation"/> class.
            </summary>
            <param name="type">Type with method.</param>
            <param name="addMethod">The add method.</param>
            <param name="arguments">The arguments.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ElementInitRepresentation.Type">
            <summary>
            Gets the type.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ElementInitRepresentation.AddMethod">
            <summary>
            Gets the add method.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ElementInitRepresentation.Arguments">
            <summary>
            Gets the arguments.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.op_Equality(OBeautifulCode.Representation.System.ElementInitRepresentation,OBeautifulCode.Representation.System.ElementInitRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ElementInitRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.op_Inequality(OBeautifulCode.Representation.System.ElementInitRepresentation,OBeautifulCode.Representation.System.ElementInitRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ElementInitRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.Equals(OBeautifulCode.Representation.System.ElementInitRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ElementInitRepresentation.Type" />.
            </summary>
            <param name="type">The new <see cref="P:OBeautifulCode.Representation.System.ElementInitRepresentation.Type" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ElementInitRepresentation" /> using the specified <paramref name="type" /> for <see cref="P:OBeautifulCode.Representation.System.ElementInitRepresentation.Type" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.DeepCloneWithAddMethod(OBeautifulCode.Representation.System.MethodInfoRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ElementInitRepresentation.AddMethod" />.
            </summary>
            <param name="addMethod">The new <see cref="P:OBeautifulCode.Representation.System.ElementInitRepresentation.AddMethod" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ElementInitRepresentation" /> using the specified <paramref name="addMethod" /> for <see cref="P:OBeautifulCode.Representation.System.ElementInitRepresentation.AddMethod" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.DeepCloneWithArguments(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ExpressionRepresentationBase})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ElementInitRepresentation.Arguments" />.
            </summary>
            <param name="arguments">The new <see cref="P:OBeautifulCode.Representation.System.ElementInitRepresentation.Arguments" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ElementInitRepresentation" /> using the specified <paramref name="arguments" /> for <see cref="P:OBeautifulCode.Representation.System.ElementInitRepresentation.Arguments" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.ElementInitRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.ElementInitRepresentation" /> and <see cref="T:System.Linq.Expressions.ElementInit" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentationExtensions.ToRepresentation(System.Linq.Expressions.ElementInit)">
            <summary>
            Gets the representation of the specified <see cref="T:System.Linq.Expressions.ElementInit"/>.
            </summary>
            <param name="elementInit">The <see cref="T:System.Linq.Expressions.ElementInit"/>.</param>
            <returns>
            The representation of the specified <see cref="T:System.Linq.Expressions.ElementInit"/>.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.ElementInitRepresentation)">
            <summary>
            Gets an <see cref="T:System.Linq.Expressions.ElementInit"/> from its representation.
            </summary>
            <param name="elementInitRepresentation">The representation of the <see cref="T:System.Linq.Expressions.ElementInit"/>.</param>
            <returns>
            The <see cref="T:System.Linq.Expressions.ElementInit"/>.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentationExtensions.ToRepresentation(System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ElementInit})">
            <summary>
            Converts to representation.
            </summary>
            <param name="elementInitList">The list of <see cref="T:System.Linq.Expressions.ElementInit" />.</param>
            <returns>
            Converted list of <see cref="T:OBeautifulCode.Representation.System.ElementInitRepresentation" />.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ElementInitRepresentationExtensions.FromRepresentation(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ElementInitRepresentation})">
            <summary>
            From the serializable.
            </summary>
            <param name="elementInitRepresentationList">The elementInitRepresentation.</param>
            <returns>
            Converted version.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberAssignmentRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.MemberAssignment" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.MemberInfoRepresentation,OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.MemberAssignmentRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="memberInfo">The member hash.</param>
            <param name="expressionRepresentation">The expression.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.ExpressionRepresentation">
            <summary>
            Gets the expression.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.op_Equality(OBeautifulCode.Representation.System.MemberAssignmentRepresentation,OBeautifulCode.Representation.System.MemberAssignmentRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberAssignmentRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.op_Inequality(OBeautifulCode.Representation.System.MemberAssignmentRepresentation,OBeautifulCode.Representation.System.MemberAssignmentRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberAssignmentRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.Equals(OBeautifulCode.Representation.System.MemberAssignmentRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.DeepCloneWithMemberInfo(OBeautifulCode.Representation.System.MemberInfoRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.DeepCloneWithBindingType(System.Linq.Expressions.MemberBindingType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.DeepCloneWithExpressionRepresentation(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.ExpressionRepresentation" />.
            </summary>
            <param name="expressionRepresentation">The new <see cref="P:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.ExpressionRepresentation" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberAssignmentRepresentation" /> using the specified <paramref name="expressionRepresentation" /> for <see cref="P:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.ExpressionRepresentation" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberAssignmentRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.MemberAssignmentRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentationExtensions.ToRepresentation(System.Linq.Expressions.MemberAssignment)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="memberAssignment">The memberAssignment.</param>
            <returns>
            Serializable version.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberAssignmentRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.MemberAssignmentRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="memberAssignmentRepresentation">The memberAssignment.</param>
            <returns>
            Converted version.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberBindingRepresentationBase">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.MemberBinding" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.MemberInfoRepresentation,System.Linq.Expressions.MemberBindingType)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.MemberBindingRepresentationBase"/> class.
            </summary>
            <param name="type">The type with member.</param>
            <param name="memberInfo">The member info representation.</param>
            <param name="bindingType">Type of the binding.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.Type">
            <summary>
            Gets the type with member.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.MemberInfo">
            <summary>
            Gets the member info representation.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.BindingType">
            <summary>
            Gets the type of the binding.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.op_Equality(OBeautifulCode.Representation.System.MemberBindingRepresentationBase,OBeautifulCode.Representation.System.MemberBindingRepresentationBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberBindingRepresentationBase"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.op_Inequality(OBeautifulCode.Representation.System.MemberBindingRepresentationBase,OBeautifulCode.Representation.System.MemberBindingRepresentationBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberBindingRepresentationBase"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.Equals(OBeautifulCode.Representation.System.MemberBindingRepresentationBase)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.Type" />.
            </summary>
            <param name="type">The new <see cref="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.Type" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberBindingRepresentationBase" /> using the specified <paramref name="type" /> for <see cref="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.Type" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.DeepCloneWithMemberInfo(OBeautifulCode.Representation.System.MemberInfoRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.MemberInfo" />.
            </summary>
            <param name="memberInfo">The new <see cref="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.MemberInfo" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberBindingRepresentationBase" /> using the specified <paramref name="memberInfo" /> for <see cref="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.MemberInfo" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.DeepCloneWithBindingType(System.Linq.Expressions.MemberBindingType)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.BindingType" />.
            </summary>
            <param name="bindingType">The new <see cref="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.BindingType" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberBindingRepresentationBase" /> using the specified <paramref name="bindingType" /> for <see cref="P:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.BindingType" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.DeepCloneInternal">
            <summary>
            Creates a new object that is a deep clone of this instance.
            </summary>
            <returns>
            A new object that is a deep clone of this instance.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationBase.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberBindingRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.MemberBindingRepresentationBase" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationExtensions.ToRepresentation(System.Linq.Expressions.MemberBinding)">
            <summary>Converts to serializable.</summary>
            <param name="memberBinding">The memberBindings.</param>
            <returns>Serializable version.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.MemberBindingRepresentationBase)">
            <summary>
            From the serializable.
            </summary>
            <param name="memberBindingRepresentation">The memberBindings.</param>
            <returns>
            Converted version.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationExtensions.ToRepresentation(System.Collections.Generic.IReadOnlyCollection{System.Linq.Expressions.MemberBinding})">
            <summary>
            Converts to serializable.
            </summary>
            <param name="memberBindings">The memberBindings.</param>
            <returns>
            Serializable version.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberBindingRepresentationExtensions.FromRepresentation(System.Collections.Generic.IReadOnlyCollection{OBeautifulCode.Representation.System.MemberBindingRepresentationBase})">
            <summary>
            From the serializable.
            </summary>
            <param name="memberBindings">The memberBindings.</param>
            <returns>
            Converted version.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberListBindingRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.MemberListBinding" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.MemberInfoRepresentation,System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ElementInitRepresentation})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.MemberListBindingRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="memberInfo">The member hash.</param>
            <param name="initializers">The initializers.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberListBindingRepresentation.Initializers">
            <summary>
            Gets the initializers.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.op_Equality(OBeautifulCode.Representation.System.MemberListBindingRepresentation,OBeautifulCode.Representation.System.MemberListBindingRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberListBindingRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.op_Inequality(OBeautifulCode.Representation.System.MemberListBindingRepresentation,OBeautifulCode.Representation.System.MemberListBindingRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberListBindingRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.Equals(OBeautifulCode.Representation.System.MemberListBindingRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.DeepCloneWithMemberInfo(OBeautifulCode.Representation.System.MemberInfoRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.DeepCloneWithBindingType(System.Linq.Expressions.MemberBindingType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.DeepCloneWithInitializers(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ElementInitRepresentation})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberListBindingRepresentation.Initializers" />.
            </summary>
            <param name="initializers">The new <see cref="P:OBeautifulCode.Representation.System.MemberListBindingRepresentation.Initializers" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberListBindingRepresentation" /> using the specified <paramref name="initializers" /> for <see cref="P:OBeautifulCode.Representation.System.MemberListBindingRepresentation.Initializers" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberListBindingRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.MemberListBindingRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentationExtensions.ToRepresentation(System.Linq.Expressions.MemberListBinding)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="memberListBinding">The member list binding.</param>
            <returns>
            Serializable version.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberListBindingRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.MemberListBindingRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="memberListBindingRepresentation">The memberListBindingRepresentation.</param>
            <returns>
            Converted version.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.MemberInfoRepresentation,System.Collections.Generic.IReadOnlyCollection{OBeautifulCode.Representation.System.MemberBindingRepresentationBase})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="memberInfo">The member hash.</param>
            <param name="bindings">The bindings.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.Bindings">
            <summary>
            Gets the bindings.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.op_Equality(OBeautifulCode.Representation.System.MemberMemberBindingRepresentation,OBeautifulCode.Representation.System.MemberMemberBindingRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.op_Inequality(OBeautifulCode.Representation.System.MemberMemberBindingRepresentation,OBeautifulCode.Representation.System.MemberMemberBindingRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.Equals(OBeautifulCode.Representation.System.MemberMemberBindingRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.DeepCloneWithMemberInfo(OBeautifulCode.Representation.System.MemberInfoRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.DeepCloneWithBindingType(System.Linq.Expressions.MemberBindingType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.DeepCloneWithBindings(System.Collections.Generic.IReadOnlyCollection{OBeautifulCode.Representation.System.MemberBindingRepresentationBase})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.Bindings" />.
            </summary>
            <param name="bindings">The new <see cref="P:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.Bindings" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation" /> using the specified <paramref name="bindings" /> for <see cref="P:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.Bindings" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberMemberBindingRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.MemberMemberBindingRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentationExtensions.ToRepresentation(System.Linq.Expressions.MemberMemberBinding)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="memberMemberBinding">The memberMemberBindingRepresentation.</param>
            <returns>
            Serializable version.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberMemberBindingRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.MemberMemberBindingRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="memberMemberBindingRepresentation">The memberMemberBindingRepresentation.</param>
            <returns>
            Converted version.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.BinaryExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.BinaryExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,System.Linq.Expressions.ExpressionType,OBeautifulCode.Representation.System.ExpressionRepresentationBase,OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.BinaryExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type of expression.</param>
            <param name="nodeType">Type of the node.</param>
            <param name="left">The left expression.</param>
            <param name="right">The right expression.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.Left">
            <summary>
            Gets the left expression.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.Right">
            <summary>
            Gets the right expression.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.BinaryExpressionRepresentation,OBeautifulCode.Representation.System.BinaryExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.BinaryExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.BinaryExpressionRepresentation,OBeautifulCode.Representation.System.BinaryExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.BinaryExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.Equals(OBeautifulCode.Representation.System.BinaryExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.DeepCloneWithLeft(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.Left" />.
            </summary>
            <param name="left">The new <see cref="P:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.Left" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.BinaryExpressionRepresentation" /> using the specified <paramref name="left" /> for <see cref="P:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.Left" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.DeepCloneWithRight(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.Right" />.
            </summary>
            <param name="right">The new <see cref="P:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.Right" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.BinaryExpressionRepresentation" /> using the specified <paramref name="right" /> for <see cref="P:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.Right" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.BinaryExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.BinaryExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="binaryExpression">The binary expression.</param>
            <returns>
            The real expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.BinaryExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.BinaryExpressionRepresentation)">
            <summary>
            Converts from serializable.
            </summary>
            <param name="binaryExpressionRepresentation">The binary expression.</param>
            <returns>
            The real expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.ConditionalExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,System.Linq.Expressions.ExpressionType,OBeautifulCode.Representation.System.ExpressionRepresentationBase,OBeautifulCode.Representation.System.ExpressionRepresentationBase,OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type of expression.</param>
            <param name="nodeType">Type of the node.</param>
            <param name="test">The test expression.</param>
            <param name="ifTrue">If true expression.</param>
            <param name="ifFalse">If false expression.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.Test">
            <summary>Gets the test expression.</summary>
            <value>The test expression.</value>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.IfTrue">
            <summary>Gets if true expression.</summary>
            <value>If true expression.</value>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.IfFalse">
            <summary>Gets if false expression.</summary>
            <value>If false expression.</value>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.ConditionalExpressionRepresentation,OBeautifulCode.Representation.System.ConditionalExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.ConditionalExpressionRepresentation,OBeautifulCode.Representation.System.ConditionalExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.Equals(OBeautifulCode.Representation.System.ConditionalExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.DeepCloneWithTest(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.Test" />.
            </summary>
            <param name="test">The new <see cref="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.Test" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation" /> using the specified <paramref name="test" /> for <see cref="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.Test" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.DeepCloneWithIfTrue(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.IfTrue" />.
            </summary>
            <param name="ifTrue">The new <see cref="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.IfTrue" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation" /> using the specified <paramref name="ifTrue" /> for <see cref="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.IfTrue" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.DeepCloneWithIfFalse(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.IfFalse" />.
            </summary>
            <param name="ifFalse">The new <see cref="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.IfFalse" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation" /> using the specified <paramref name="ifFalse" /> for <see cref="P:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.IfFalse" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.ConditionalExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.ConditionalExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.ConditionalExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="conditionalExpression">The conditional expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConditionalExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.ConditionalExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="conditionalExpressionRepresentation">The conditional expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.ConstantExpression" />.
            </summary>
            <typeparam name="T">Type of the value.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.op_Equality(OBeautifulCode.Representation.System.ConstantExpressionRepresentation{`0},OBeautifulCode.Representation.System.ConstantExpressionRepresentation{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.op_Inequality(OBeautifulCode.Representation.System.ConstantExpressionRepresentation{`0},OBeautifulCode.Representation.System.ConstantExpressionRepresentation{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.Equals(OBeautifulCode.Representation.System.ConstantExpressionRepresentation{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.DeepCloneWithValue(`0)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.Value" />.
            </summary>
            <param name="value">The new <see cref="P:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.Value" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1" /> using the specified <paramref name="value" /> for <see cref="P:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.Value" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,System.Linq.Expressions.ExpressionType,`0)">
            <summary>Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1"/> class.</summary>
            <param name="type">The type of expression.</param>
            <param name="nodeType">The node type.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Representation.System.ProjectInfo">
            <summary>
            Project-related information.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Representation.System.ProjectInfo.Namespace">
            <summary>
            The namespace used by types in this project.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Representation.System.ProjectInfo.Assembly">
            <summary>
            The assembly produced by this project.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Representation.System.ConstructorInfoRepresentation">
            <summary>
            Representation of <see cref="T:System.Reflection.ConstructorInfo" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.op_Equality(OBeautifulCode.Representation.System.ConstructorInfoRepresentation,OBeautifulCode.Representation.System.ConstructorInfoRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ConstructorInfoRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.op_Inequality(OBeautifulCode.Representation.System.ConstructorInfoRepresentation,OBeautifulCode.Representation.System.ConstructorInfoRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ConstructorInfoRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.Equals(OBeautifulCode.Representation.System.ConstructorInfoRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.DeepCloneWithConstructorHash(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.ConstructorHash" />.
            </summary>
            <param name="constructorHash">The new <see cref="P:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.ConstructorHash" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ConstructorInfoRepresentation" /> using the specified <paramref name="constructorHash" /> for <see cref="P:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.ConstructorHash" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.Type" />.
            </summary>
            <param name="type">The new <see cref="P:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.Type" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ConstructorInfoRepresentation" /> using the specified <paramref name="type" /> for <see cref="P:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.Type" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.ConstructorInfoRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="constructorHash">The method hash.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.ConstructorHash">
            <summary>
            Gets the constructor hash.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ConstructorInfoRepresentation.Type">
            <summary>
            Gets the type.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberInfoRepresentation">
            <summary>
            Representation of <see cref="T:System.Reflection.MemberInfo" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentation.op_Equality(OBeautifulCode.Representation.System.MemberInfoRepresentation,OBeautifulCode.Representation.System.MemberInfoRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberInfoRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentation.op_Inequality(OBeautifulCode.Representation.System.MemberInfoRepresentation,OBeautifulCode.Representation.System.MemberInfoRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberInfoRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentation.Equals(OBeautifulCode.Representation.System.MemberInfoRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentation.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentation.DeepCloneWithMemberHash(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberInfoRepresentation.MemberHash" />.
            </summary>
            <param name="memberHash">The new <see cref="P:OBeautifulCode.Representation.System.MemberInfoRepresentation.MemberHash" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberInfoRepresentation" /> using the specified <paramref name="memberHash" /> for <see cref="P:OBeautifulCode.Representation.System.MemberInfoRepresentation.MemberHash" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberInfoRepresentation.Type" />.
            </summary>
            <param name="type">The new <see cref="P:OBeautifulCode.Representation.System.MemberInfoRepresentation.Type" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberInfoRepresentation" /> using the specified <paramref name="type" /> for <see cref="P:OBeautifulCode.Representation.System.MemberInfoRepresentation.Type" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.MemberInfoRepresentation" /> class.
            </summary>
            <param name="type">The type.</param>
            <param name="memberHash">The member hash.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberInfoRepresentation.MemberHash">
            <summary>
            Gets the member hash.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberInfoRepresentation.Type">
            <summary>
            Gets the type.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Representation.System.MethodInfoRepresentation">
            <summary>
            Representation of <see cref="T:System.Reflection.MethodInfo" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.op_Equality(OBeautifulCode.Representation.System.MethodInfoRepresentation,OBeautifulCode.Representation.System.MethodInfoRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MethodInfoRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.op_Inequality(OBeautifulCode.Representation.System.MethodInfoRepresentation,OBeautifulCode.Representation.System.MethodInfoRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MethodInfoRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.Equals(OBeautifulCode.Representation.System.MethodInfoRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.DeepCloneWithGenericArguments(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.TypeRepresentation})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.GenericArguments" />.
            </summary>
            <param name="genericArguments">The new <see cref="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.GenericArguments" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MethodInfoRepresentation" /> using the specified <paramref name="genericArguments" /> for <see cref="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.GenericArguments" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.DeepCloneWithMethodHash(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.MethodHash" />.
            </summary>
            <param name="methodHash">The new <see cref="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.MethodHash" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MethodInfoRepresentation" /> using the specified <paramref name="methodHash" /> for <see cref="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.MethodHash" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.Type" />.
            </summary>
            <param name="type">The new <see cref="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.Type" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MethodInfoRepresentation" /> using the specified <paramref name="type" /> for <see cref="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.Type" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,System.String,System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.TypeRepresentation})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.MethodInfoRepresentation" /> class.
            </summary>
            <param name="type">The type.</param>
            <param name="methodHash">The method hash.</param>
            <param name="genericArguments">The generic arguments.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.GenericArguments">
            <summary>
            Gets the generic arguments.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.MethodHash">
            <summary>
            Gets the method hash.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MethodInfoRepresentation.Type">
            <summary>
            Gets the type.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Representation.System.UnknownTypePlaceholder">
            <summary>
            Placeholder type to use when no <see cref="T:System.Type" /> is available.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnknownTypePlaceholder.op_Equality(OBeautifulCode.Representation.System.UnknownTypePlaceholder,OBeautifulCode.Representation.System.UnknownTypePlaceholder)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.UnknownTypePlaceholder"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnknownTypePlaceholder.op_Inequality(OBeautifulCode.Representation.System.UnknownTypePlaceholder,OBeautifulCode.Representation.System.UnknownTypePlaceholder)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.UnknownTypePlaceholder"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnknownTypePlaceholder.Equals(OBeautifulCode.Representation.System.UnknownTypePlaceholder)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnknownTypePlaceholder.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnknownTypePlaceholder.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnknownTypePlaceholder.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnknownTypePlaceholder.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnknownTypePlaceholder.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.ConstantExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.ConstantExpressionRepresentation`1" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.ConstantExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="constantExpression">The constant expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstantExpressionRepresentationExtensions.FromRepresentation``1(OBeautifulCode.Representation.System.ConstantExpressionRepresentation{``0})">
            <summary>
            From the serializable.
            </summary>
            <param name="constantExpressionRepresentation">The constant expression.</param>
            <typeparam name="T">Type of constant.</typeparam>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.ExpressionRepresentationBase">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.Expression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,System.Linq.Expressions.ExpressionType)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.ExpressionRepresentationBase"/> class.
            </summary>
            <param name="type">The type of expression.</param>
            <param name="nodeType">The node type.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ExpressionRepresentationBase.NodeType">
            <summary>
            Gets the type of the node.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ExpressionRepresentationBase.Type">
            <summary>
            Gets the type.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.op_Equality(OBeautifulCode.Representation.System.ExpressionRepresentationBase,OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ExpressionRepresentationBase"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.op_Inequality(OBeautifulCode.Representation.System.ExpressionRepresentationBase,OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ExpressionRepresentationBase"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.Equals(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ExpressionRepresentationBase.NodeType" />.
            </summary>
            <param name="nodeType">The new <see cref="P:OBeautifulCode.Representation.System.ExpressionRepresentationBase.NodeType" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ExpressionRepresentationBase" /> using the specified <paramref name="nodeType" /> for <see cref="P:OBeautifulCode.Representation.System.ExpressionRepresentationBase.NodeType" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ExpressionRepresentationBase.Type" />.
            </summary>
            <param name="type">The new <see cref="P:OBeautifulCode.Representation.System.ExpressionRepresentationBase.Type" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ExpressionRepresentationBase" /> using the specified <paramref name="type" /> for <see cref="P:OBeautifulCode.Representation.System.ExpressionRepresentationBase.Type" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.DeepCloneInternal">
            <summary>
            Creates a new object that is a deep clone of this instance.
            </summary>
            <returns>
            A new object that is a deep clone of this instance.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationBase.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.ExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.ExpressionRepresentationBase" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.Expression)">
            <summary>
            Converts to a serializable.
            </summary>
            <param name="expression">The expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Converts from serializable.
            </summary>
            <param name="expressionRepresentation">The serializable expression.</param>
            <returns>
            Converted version.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationExtensions.ToRepresentation(System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.Expression})">
            <summary>Converts to serializable.</summary>
            <param name="expressions">The expressions.</param>
            <returns>Converted expressions.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationExtensions.FromRepresentation(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ExpressionRepresentationBase})">
            <summary>Froms the serializable.</summary>
            <param name="expressions">The expressions.</param>
            <returns>Converted expressions.</returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.InvocationExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.InvocationExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.ExpressionRepresentationBase,System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ExpressionRepresentationBase})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.InvocationExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type of expression.</param>
            <param name="expressionRepresentation">The expression to invoke.</param>
            <param name="arguments">The arguments to invoke with.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.ExpressionRepresentation">
            <summary>
            Gets the expression to invoke.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.Arguments">
            <summary>
            Gets the arguments for the expression.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.InvocationExpressionRepresentation,OBeautifulCode.Representation.System.InvocationExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.InvocationExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.InvocationExpressionRepresentation,OBeautifulCode.Representation.System.InvocationExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.InvocationExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.Equals(OBeautifulCode.Representation.System.InvocationExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.DeepCloneWithExpressionRepresentation(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.ExpressionRepresentation" />.
            </summary>
            <param name="expressionRepresentation">The new <see cref="P:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.ExpressionRepresentation" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.InvocationExpressionRepresentation" /> using the specified <paramref name="expressionRepresentation" /> for <see cref="P:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.ExpressionRepresentation" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.DeepCloneWithArguments(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ExpressionRepresentationBase})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.Arguments" />.
            </summary>
            <param name="arguments">The new <see cref="P:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.Arguments" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.InvocationExpressionRepresentation" /> using the specified <paramref name="arguments" /> for <see cref="P:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.Arguments" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.InvocationExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.InvocationExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.InvocationExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="invocationExpression">The invocation expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.InvocationExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.InvocationExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="invocationExpressionRepresentation">The invocation expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.LambdaExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.LambdaExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.ExpressionRepresentationBase,System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ParameterExpressionRepresentation})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.LambdaExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type of expression.</param>
            <param name="body">The body.</param>
            <param name="parameters">The parameters.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.Body">
            <summary>
            Gets the body.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.Parameters">
            <summary>
            Gets the parameters.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.LambdaExpressionRepresentation,OBeautifulCode.Representation.System.LambdaExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.LambdaExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.LambdaExpressionRepresentation,OBeautifulCode.Representation.System.LambdaExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.LambdaExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.Equals(OBeautifulCode.Representation.System.LambdaExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.DeepCloneWithBody(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.Body" />.
            </summary>
            <param name="body">The new <see cref="P:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.Body" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.LambdaExpressionRepresentation" /> using the specified <paramref name="body" /> for <see cref="P:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.Body" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.DeepCloneWithParameters(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ParameterExpressionRepresentation})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.Parameters" />.
            </summary>
            <param name="parameters">The new <see cref="P:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.Parameters" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.LambdaExpressionRepresentation" /> using the specified <paramref name="parameters" /> for <see cref="P:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.Parameters" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.LambdaExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.LambdaExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="lambdaExpression">The lambda expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.LambdaExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.LambdaExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="lambdaExpressionRepresentation">The lambda expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.ListInitExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.ListInitExpression" />.
            </summary>
            <seealso cref="T:OBeautifulCode.Representation.System.ExpressionRepresentationBase" />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.NewExpressionRepresentation,System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ElementInitRepresentation})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.ListInitExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type of expression.</param>
            <param name="newExpressionRepresentation">The new expression.</param>
            <param name="initializers">The initializers.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.NewExpressionRepresentation">
            <summary>
            Gets the new expression representation.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.Initializers">
            <summary>
            Gets the initializers.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.ListInitExpressionRepresentation,OBeautifulCode.Representation.System.ListInitExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ListInitExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.ListInitExpressionRepresentation,OBeautifulCode.Representation.System.ListInitExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ListInitExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.Equals(OBeautifulCode.Representation.System.ListInitExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.DeepCloneWithNewExpressionRepresentation(OBeautifulCode.Representation.System.NewExpressionRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.NewExpressionRepresentation" />.
            </summary>
            <param name="newExpressionRepresentation">The new <see cref="P:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.NewExpressionRepresentation" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ListInitExpressionRepresentation" /> using the specified <paramref name="newExpressionRepresentation" /> for <see cref="P:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.NewExpressionRepresentation" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.DeepCloneWithInitializers(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ElementInitRepresentation})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.Initializers" />.
            </summary>
            <param name="initializers">The new <see cref="P:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.Initializers" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ListInitExpressionRepresentation" /> using the specified <paramref name="initializers" /> for <see cref="P:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.Initializers" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.ListInitExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.ListInitExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.ListInitExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="listInitExpression">The listInit expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ListInitExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.ListInitExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="listInitExpressionRepresentation">The listInit expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.MemberExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.ExpressionRepresentationBase,OBeautifulCode.Representation.System.MemberInfoRepresentation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.MemberExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="expression">The expression.</param>
            <param name="memberInfo">The member info representation.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberExpressionRepresentation.Expression">
            <summary>
            Gets the expression.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberExpressionRepresentation.MemberInfo">
            <summary>
            Gets the member hash.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.MemberExpressionRepresentation,OBeautifulCode.Representation.System.MemberExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.MemberExpressionRepresentation,OBeautifulCode.Representation.System.MemberExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.Equals(OBeautifulCode.Representation.System.MemberExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.DeepCloneWithExpression(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberExpressionRepresentation.Expression" />.
            </summary>
            <param name="expression">The new <see cref="P:OBeautifulCode.Representation.System.MemberExpressionRepresentation.Expression" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberExpressionRepresentation" /> using the specified <paramref name="expression" /> for <see cref="P:OBeautifulCode.Representation.System.MemberExpressionRepresentation.Expression" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.DeepCloneWithMemberInfo(OBeautifulCode.Representation.System.MemberInfoRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberExpressionRepresentation.MemberInfo" />.
            </summary>
            <param name="memberInfo">The new <see cref="P:OBeautifulCode.Representation.System.MemberExpressionRepresentation.MemberInfo" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberExpressionRepresentation" /> using the specified <paramref name="memberInfo" /> for <see cref="P:OBeautifulCode.Representation.System.MemberExpressionRepresentation.MemberInfo" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.MemberExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.MemberExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="memberExpression">The member expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.MemberExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="memberExpressionRepresentation">The member expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.MemberInitExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.NewExpressionRepresentation,System.Collections.Generic.IReadOnlyCollection{OBeautifulCode.Representation.System.MemberBindingRepresentationBase})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="newExpressionRepresentation">The new expression.</param>
            <param name="bindings">The bindings.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.NewExpressionRepresentation">
            <summary>
            Gets the new expression.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.Bindings">
            <summary>
            Gets the bindings.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.MemberInitExpressionRepresentation,OBeautifulCode.Representation.System.MemberInitExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.MemberInitExpressionRepresentation,OBeautifulCode.Representation.System.MemberInitExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.Equals(OBeautifulCode.Representation.System.MemberInitExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.DeepCloneWithNewExpressionRepresentation(OBeautifulCode.Representation.System.NewExpressionRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.NewExpressionRepresentation" />.
            </summary>
            <param name="newExpressionRepresentation">The new <see cref="P:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.NewExpressionRepresentation" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation" /> using the specified <paramref name="newExpressionRepresentation" /> for <see cref="P:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.NewExpressionRepresentation" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.DeepCloneWithBindings(System.Collections.Generic.IReadOnlyCollection{OBeautifulCode.Representation.System.MemberBindingRepresentationBase})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.Bindings" />.
            </summary>
            <param name="bindings">The new <see cref="P:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.Bindings" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation" /> using the specified <paramref name="bindings" /> for <see cref="P:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.Bindings" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberInitExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.MemberInitExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.MemberInitExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="memberInitExpression">The memberInit expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInitExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.MemberInitExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="memberInitExpressionRepresentation">The memberInit expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.MethodCallExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,System.Linq.Expressions.ExpressionType,OBeautifulCode.Representation.System.ExpressionRepresentationBase,OBeautifulCode.Representation.System.MethodInfoRepresentation,System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ExpressionRepresentationBase})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="nodeType">Type of the node.</param>
            <param name="parentObject">The object.</param>
            <param name="method">The method.</param>
            <param name="arguments">The arguments.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.ParentObject">
            <summary>
            Gets the object.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.Method">
            <summary>
            Gets the method hash.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.Arguments">
            <summary>
            Gets the arguments.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.MethodCallExpressionRepresentation,OBeautifulCode.Representation.System.MethodCallExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.MethodCallExpressionRepresentation,OBeautifulCode.Representation.System.MethodCallExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.Equals(OBeautifulCode.Representation.System.MethodCallExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.DeepCloneWithParentObject(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.ParentObject" />.
            </summary>
            <param name="parentObject">The new <see cref="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.ParentObject" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation" /> using the specified <paramref name="parentObject" /> for <see cref="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.ParentObject" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.DeepCloneWithMethod(OBeautifulCode.Representation.System.MethodInfoRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.Method" />.
            </summary>
            <param name="method">The new <see cref="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.Method" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation" /> using the specified <paramref name="method" /> for <see cref="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.Method" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.DeepCloneWithArguments(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ExpressionRepresentationBase})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.Arguments" />.
            </summary>
            <param name="arguments">The new <see cref="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.Arguments" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation" /> using the specified <paramref name="arguments" /> for <see cref="P:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.Arguments" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.MethodCallExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.MethodCallExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="methodCallExpression">The methodCall expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodCallExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.MethodCallExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="methodCallExpressionRepresentation">The methodCall expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.NewArrayExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,System.Linq.Expressions.ExpressionType,System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ExpressionRepresentationBase})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="nodeType">Type of the node.</param>
            <param name="expressions">The expressions.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.Expressions">
            <summary>
            Gets the expressions.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.NewArrayExpressionRepresentation,OBeautifulCode.Representation.System.NewArrayExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.NewArrayExpressionRepresentation,OBeautifulCode.Representation.System.NewArrayExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.Equals(OBeautifulCode.Representation.System.NewArrayExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.DeepCloneWithExpressions(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ExpressionRepresentationBase})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.Expressions" />.
            </summary>
            <param name="expressions">The new <see cref="P:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.Expressions" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation" /> using the specified <paramref name="expressions" /> for <see cref="P:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.Expressions" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.NewArrayExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.NewArrayExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.NewArrayExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="newArrayExpression">The newArray expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewArrayExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.NewArrayExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="newArrayExpressionRepresentation">The newArray expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.NewExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.NewExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.ConstructorInfoRepresentation,System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ExpressionRepresentationBase})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.NewExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="constructorInfo">The constructor info.</param>
            <param name="arguments">The arguments.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.NewExpressionRepresentation.ConstructorInfo">
            <summary>
            Gets the constructor hash.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.NewExpressionRepresentation.Arguments">
            <summary>
            Gets the arguments.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.NewExpressionRepresentation,OBeautifulCode.Representation.System.NewExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.NewExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.NewExpressionRepresentation,OBeautifulCode.Representation.System.NewExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.NewExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.Equals(OBeautifulCode.Representation.System.NewExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.DeepCloneWithConstructorInfo(OBeautifulCode.Representation.System.ConstructorInfoRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.NewExpressionRepresentation.ConstructorInfo" />.
            </summary>
            <param name="constructorInfo">The new <see cref="P:OBeautifulCode.Representation.System.NewExpressionRepresentation.ConstructorInfo" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.NewExpressionRepresentation" /> using the specified <paramref name="constructorInfo" /> for <see cref="P:OBeautifulCode.Representation.System.NewExpressionRepresentation.ConstructorInfo" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.DeepCloneWithArguments(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ExpressionRepresentationBase})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.NewExpressionRepresentation.Arguments" />.
            </summary>
            <param name="arguments">The new <see cref="P:OBeautifulCode.Representation.System.NewExpressionRepresentation.Arguments" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.NewExpressionRepresentation" /> using the specified <paramref name="arguments" /> for <see cref="P:OBeautifulCode.Representation.System.NewExpressionRepresentation.Arguments" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.NewExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.NewExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.NewExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="newExpression">The new expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.NewExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.NewExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="newExpressionRepresentation">The new expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.ParameterExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.ParameterExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.ParameterExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="name">The name.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.Name">
            <summary>
            Gets the name.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.ParameterExpressionRepresentation,OBeautifulCode.Representation.System.ParameterExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ParameterExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.ParameterExpressionRepresentation,OBeautifulCode.Representation.System.ParameterExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.ParameterExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.Equals(OBeautifulCode.Representation.System.ParameterExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.DeepCloneWithName(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.Name" />.
            </summary>
            <param name="name">The new <see cref="P:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.Name" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.ParameterExpressionRepresentation" /> using the specified <paramref name="name" /> for <see cref="P:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.Name" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.ParameterExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.ParameterExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="parameterExpression">The parameter expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.ParameterExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="parameterExpressionRepresentation">The parameter expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentationExtensions.ToRepresentation(System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression})">
            <summary>
            Converts to serializable.
            </summary>
            <param name="expressions">The expressions.</param>
            <returns>
            Converted expressions.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ParameterExpressionRepresentationExtensions.FromRepresentation(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.ParameterExpressionRepresentation})">
            <summary>
            From the serializable.
            </summary>
            <param name="expressions">The expressions.</param>
            <returns>
            Converted expressions.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="expression">The expression.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.Expression">
            <summary>
            Gets the expression.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation,OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation,OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.Equals(OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.DeepCloneWithExpression(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.Expression" />.
            </summary>
            <param name="expression">The new <see cref="P:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.Expression" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation" /> using the specified <paramref name="expression" /> for <see cref="P:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.Expression" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.TypeBinaryExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="typeBinaryExpression">The typeBinary expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.TypeBinaryExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="typeBinaryExpressionRepresentation">The typeBinary expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.UnaryExpressionRepresentation">
            <summary>
            Representation of <see cref="T:System.Linq.Expressions.UnaryExpression" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,System.Linq.Expressions.ExpressionType,OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.UnaryExpressionRepresentation"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="nodeType">Type of the node.</param>
            <param name="operand">The operand.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.Operand">
            <summary>
            Gets the operand.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.op_Equality(OBeautifulCode.Representation.System.UnaryExpressionRepresentation,OBeautifulCode.Representation.System.UnaryExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.UnaryExpressionRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.op_Inequality(OBeautifulCode.Representation.System.UnaryExpressionRepresentation,OBeautifulCode.Representation.System.UnaryExpressionRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.UnaryExpressionRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.Equals(OBeautifulCode.Representation.System.UnaryExpressionRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.DeepCloneWithNodeType(System.Linq.Expressions.ExpressionType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.DeepCloneWithType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.DeepCloneWithOperand(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.Operand" />.
            </summary>
            <param name="operand">The new <see cref="P:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.Operand" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.UnaryExpressionRepresentation" /> using the specified <paramref name="operand" /> for <see cref="P:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.Operand" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.UnaryExpressionRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.UnaryExpressionRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentationExtensions.ToRepresentation(System.Linq.Expressions.UnaryExpression)">
            <summary>
            Converts to serializable.
            </summary>
            <param name="unaryExpression">The unary expression.</param>
            <returns>
            Serializable expression.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.UnaryExpressionRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.UnaryExpressionRepresentation)">
            <summary>
            From the serializable.
            </summary>
            <param name="unaryExpressionRepresentation">The unary expression.</param>
            <returns>
            Converted expression.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.ExpressionRepresentationVisitor">
            <summary>
            Expression tree visitor for <see cref="T:OBeautifulCode.Representation.System.ExpressionRepresentationBase" />'s.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationVisitor.VisitAllConnectedNodes(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Visits all connected nodes.
            </summary>
            <param name="root">The root.</param>
            <returns>
            Collection of the connected nodes.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionRepresentationVisitor.VisitAllNodes(OBeautifulCode.Representation.System.ExpressionRepresentationBase)">
            <summary>
            Visits all nodes in the tree.
            </summary>
            <param name="root">Node traverse from.</param>
            <returns>
            Collection of the <see cref="T:OBeautifulCode.Representation.System.ExpressionRepresentationBase" /> from the tree.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.ExpressionVisitor">
            <summary>
            Expression tree visitor for <see cref="T:System.Linq.Expressions.Expression" />'s.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionVisitor.VisitAllConnectedNodes(System.Linq.Expressions.Expression)">
            <summary>
            Visits all connected nodes.
            </summary>
            <param name="root">The root.</param>
            <returns>
            Collection of the connected nodes.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ExpressionVisitor.VisitAllNodes(System.Linq.Expressions.Expression)">
            <summary>
            Visits all nodes in the tree.
            </summary>
            <param name="root">Node traverse from.</param>
            <returns>
            Collection of the <see cref="T:System.Linq.Expressions.Expression" /> from the tree.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.ConstructorInfoRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.ConstructorInfoRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentationExtensions.GetSignatureHash(System.Reflection.ConstructorInfo)">
            <summary>
            Gets the constructor hash.
            </summary>
            <param name="constructorInfo">The constructor information.</param>
            <returns>
            Hash of the constructor.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentationExtensions.ToRepresentation(System.Reflection.ConstructorInfo)">
            <summary>
            Converts to representation.
            </summary>
            <param name="constructorInfo">The constructor information.</param>
            <returns>
            Converted <see cref="T:OBeautifulCode.Representation.System.ConstructorInfoRepresentation" />.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.ConstructorInfoRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.ConstructorInfoRepresentation)">
            <summary>
            Converts from representation.
            </summary>
            <param name="constructorInfoRepresentation">The representation.</param>
            <returns>
            Converted <see cref="T:System.Reflection.ConstructorInfo" />.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.MemberInfoRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.MemberInfoRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentationExtensions.GetSignatureHash(System.Reflection.MemberInfo)">
            <summary>
            Gets the member hash.
            </summary>
            <param name="memberInfo">The member information.</param>
            <returns>
            Hash of the member.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentationExtensions.ToRepresentation(System.Reflection.MemberInfo)">
            <summary>
            Converts to representation.
            </summary>
            <param name="memberInfo">The member information.</param>
            <returns>
            Converted <see cref="T:OBeautifulCode.Representation.System.MemberInfoRepresentation" />.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MemberInfoRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.MemberInfoRepresentation)">
            <summary>
            Converts from representation.
            </summary>
            <param name="memberInfoRepresentation">The representation.</param>
            <returns>
            Converted <see cref="T:System.Reflection.MemberInfo" />.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.MethodInfoRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.MethodInfoRepresentation" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentationExtensions.GetSignatureHash(System.Reflection.MethodInfo)">
            <summary>
            Gets the method hash.
            </summary>
            <param name="methodInfo">The method information.</param>
            <returns>
            Hash of the method.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentationExtensions.ToRepresentation(System.Reflection.MethodInfo)">
            <summary>
            Converts to representation.
            </summary>
            <param name="methodInfo">The method information.</param>
            <returns>
            Converted <see cref="T:OBeautifulCode.Representation.System.MethodInfoRepresentation" />.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.MethodInfoRepresentationExtensions.FromRepresentation(OBeautifulCode.Representation.System.MethodInfoRepresentation)">
            <summary>
            Converts from representation.
            </summary>
            <param name="methodInfoRepresentation">The representation.</param>
            <returns>
            Converted <see cref="T:System.Reflection.MemberInfo" />.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.TypeRepresentation">
            <summary>
            Model object containing a representation of a type that can be serialized without knowledge of the type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Representation.System.TypeRepresentation.UnknownTypeRepresentation">
            <summary>
            The unknown type representation to use.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.#ctor(System.String,System.String,System.String,System.String,System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.TypeRepresentation})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation" /> class.
            </summary>
            <param name="namespace">Namespace of type.</param>
            <param name="name">Name of type.</param>
            <param name="assemblyName">The simple name of the assembly. This is usually, but not necessarily, the file name of the manifest file of the assembly, minus its extension.</param>
            <param name="assemblyVersion">The major, minor, build, and revision numbers of the assembly.</param>
            <param name="genericArguments">Generic arguments if any.  Use null if the type is not generic.  Specify an empty set for a generic type definition.  Other open types are not supported.</param>
        </member>
        <member name="P:OBeautifulCode.Representation.System.TypeRepresentation.Namespace">
            <summary>
            Gets the namespace of the type.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.TypeRepresentation.Name">
            <summary>
            Gets the name of the type.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.TypeRepresentation.AssemblyName">
            <summary>
            Gets the simple name of the assembly. This is usually, but not necessarily, the file name of the manifest file of the assembly, minus its extension.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.TypeRepresentation.AssemblyVersion">
            <summary>
            Gets the major, minor, build, and revision numbers of the assembly.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Representation.System.TypeRepresentation.GenericArguments">
            <summary>
            Gets the generic arguments.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.ToString">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareToStringMethod" />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.op_Equality(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.op_Inequality(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.Equals(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.DeepCloneWithNamespace(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.Namespace" />.
            </summary>
            <param name="namespace">The new <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.Namespace" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation" /> using the specified <paramref name="namespace" /> for <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.Namespace" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.DeepCloneWithName(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.Name" />.
            </summary>
            <param name="name">The new <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.Name" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation" /> using the specified <paramref name="name" /> for <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.Name" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.DeepCloneWithAssemblyName(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.AssemblyName" />.
            </summary>
            <param name="assemblyName">The new <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.AssemblyName" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation" /> using the specified <paramref name="assemblyName" /> for <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.AssemblyName" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.DeepCloneWithAssemblyVersion(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.AssemblyVersion" />.
            </summary>
            <param name="assemblyVersion">The new <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.AssemblyVersion" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation" /> using the specified <paramref name="assemblyVersion" /> for <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.AssemblyVersion" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentation.DeepCloneWithGenericArguments(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Representation.System.TypeRepresentation})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.GenericArguments" />.
            </summary>
            <param name="genericArguments">The new <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.GenericArguments" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation" /> using the specified <paramref name="genericArguments" /> for <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.GenericArguments" /> and a deep clone of every other property.</returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.TypeRepresentationExtensions">
            <summary>
            Extensions to <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.IsArray(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Determines whether the type is an array type.
            </summary>
            <param name="typeRepresentation">The type representation.</param>
            <returns>
            true if the type is an array type, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.IsGenericType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Determines whether this type is a generic type.
            </summary>
            <param name="typeRepresentation">The type representation.</param>
            <returns>
            true if the type is a generic type, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.IsGenericTypeDefinition(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Determines whether this type is a generic type definition.
            </summary>
            <param name="typeRepresentation">The type representation.</param>
            <returns>
            true if the type is a generic type definition, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.IsClosedGenericType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Determines whether this type is a closed generic type.
            </summary>
            <param name="typeRepresentation">The type representation.</param>
            <returns>
            true if the type is a closed generic type, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.ToRepresentation(System.Type)">
            <summary>
            Creates a new type representation from a given type.
            </summary>
            <param name="type">Input type to use.</param>
            <returns>Type representation describing input type.</returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.ResolveFromLoadedTypes(System.String,OBeautifulCode.Type.VersionMatchStrategy,System.Boolean)">
            <summary>
            Resolve the assembly qualified name into a Type from the loaded Types.
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name.</param>
            <param name="assemblyVersionMatchStrategy">Strategy to use for matching assembly versions.</param>
            <param name="throwIfCannotResolve">
            Optional value indicating whether to throw an exception if the required assembly(ies) or the type(s) cannot be found
            (generics, having generic type arguments, may cause the specified type representation to encapsulate multiple assemblies and/or multiple types).
            Default is true.
            </param>
            <returns>
            Resolved/matching Type.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.ResolveFromLoadedTypes(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Type.VersionMatchStrategy,System.Boolean)">
            <summary>
            Resolve the <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation" /> into a Type from the loaded Types.
            </summary>
            <param name="typeRepresentation">The representation of the type.</param>
            <param name="assemblyVersionMatchStrategy">Strategy to use for matching assembly versions.</param>
            <param name="throwIfCannotResolve">
            Optional value indicating whether to throw an exception if the required assembly(ies) or the type(s) cannot be found
            (generics, having generic type arguments, may cause the specified type representation to encapsulate multiple assemblies and/or multiple types).
            Default is true.
            </param>
            <returns>
            Resolved/matching Type.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.ToTypeRepresentationFromAssemblyQualifiedName(System.String)">
            <summary>
            Hydrates a <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation"/> from an assembly qualified name
            generated by <see cref="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.BuildAssemblyQualifiedName(OBeautifulCode.Representation.System.TypeRepresentation)"/>.
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name.</param>
            <returns>
            The <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation" /> for the specified assembly qualified name.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.RemoveAssemblyVersions(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Removes all assembly versions from the specified <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation"/>.
            </summary>
            <param name="representation">The type representation.</param>
            <returns>
            The specified <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation"/>, except with <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.AssemblyVersion"/>
            set to null on the outer type as well as the tree of generic type arguments.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.GetFullyNestedName(System.Type)">
            <summary>
            Gets the name of the type, including it's chain of declaring types separated
            by the plus (+) symbol, similar to how the type's name appears in <see cref="P:System.Type.FullName"/>.
            </summary>
            <remarks>
            <see cref="P:System.Type.FullName"/> includes other details that aren't needed and there's no property on Type
            that returns the fully nested name.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            The fully nested name of the type.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.BuildAssemblyQualifiedName(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Builds the assembly qualified name for a type.
            </summary>
            <param name="representation">The type representation.</param>
            <returns>
            The assembly qualified name of the specified type.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Representation.System.TypeRepresentationExtensions.BuildAssemblyName(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Builds the <see cref="T:System.Reflection.AssemblyName"/> of the assembly that contains a specified type.
            </summary>
            <param name="representation">The type representation.</param>
            <returns>
            The <see cref="T:System.Reflection.AssemblyName"/> of the assembly that contains the specified type.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Representation.System.VersionlessTypeEqualityComparer">
            <summary>
            Compares two objects of type <see cref="T:System.Type"/> for equality, ignoring assembly version.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.VersionlessTypeEqualityComparer.Equals(System.Type,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.VersionlessTypeEqualityComparer.GetHashCode(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Representation.System.VersionlessTypeRepresentationEqualityComparer">
            <summary>
            Compares two objects of type <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation"/> for equality, ignoring <see cref="P:OBeautifulCode.Representation.System.TypeRepresentation.AssemblyVersion" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Representation.System.VersionlessTypeRepresentationEqualityComparer.Equals(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Representation.System.VersionlessTypeRepresentationEqualityComparer.GetHashCode(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
    </members>
</doc>
