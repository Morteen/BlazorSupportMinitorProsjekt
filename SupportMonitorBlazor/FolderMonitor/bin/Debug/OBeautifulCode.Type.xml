<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OBeautifulCode.Type</name>
    </assembly>
    <members>
        <member name="T:OBeautifulCode.Type.Recipes.ArrayKind">
            <summary>
            Specifies the kind of array.
            </summary>
            <remarks>
            See <a href="https://stackoverflow.com/questions/60859850/how-to-determine-if-rank-1-array-is-a-vector-or-multidimensional-array?noredirect=1#comment107679655_60859850"/>.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.None">
            <summary>
            Not an array.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.Vector">
            <summary>
            A vector array.  Can only have a single dimension.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.Multidimensional">
            <summary>
            A multidimensional array.  Can have 1 to 32 dimensions.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.ToStringReadableOptions">
            <summary>
            Options for generating a readability-optimized string representation of a type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.None">
            <summary>
            None (default).
            Use this option to generate the most succinct representation of the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.IncludeNamespace">
            <summary>
            Include the namespace of the type.
            If the type is generic then also include the namespace of all generic argument types.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.IncludeAssemblyDetails">
            <summary>
            Include details (name and version) about the assembly that contains the type.
            If the type is generic then also include details about the assembly that contains
            all of the generic argument types.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions">
            <summary>
            Options for generating a XML doc compatible string representation of a type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions.None">
            <summary>
            None (default).
            Use this option to generate the most succinct representation of the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions.IncludeNamespace">
            <summary>
            Include the namespace of the type.
            If the type is generic then also include the namespace of all generic argument types.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.TypeExtensions">
            <summary>
            Extension methods on type <see cref="T:System.Type"/>.
            </summary>
            <remarks>
            These resources helped:
            <a href="https://stackoverflow.com/questions/13012733/difference-between-type-isgenerictypedefinition-and-type-containsgenericparamete" />.
            <a href="https://stackoverflow.com/questions/2173107/what-exactly-is-an-open-generic-type-in-net" />.
            <a href="https://stackoverflow.com/questions/1735035/generics-open-and-closed-constructed-types" />.
            <a href="https://stackoverflow.com/questions/25811514/detect-if-a-generic-type-is-open" />.
            <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
            <a href="https://stackoverflow.com/questions/31772922/difference-between-isgenerictype-and-isgenerictypedefinition" />.
            <a href="https://stackoverflow.com/questions/59144791/if-type-isgenericparameter-true-will-type-containsgenericparameters-true?noredirect=1#comment104515860_59144791" />.
            <a href="https://stackoverflow.com/questions/59141721/why-is-the-basetype-of-a-generic-type-definition-not-itself-a-generic-type-defin?noredirect=1#comment104515814_59141721" />.
            </remarks>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetArrayKind(System.Type)">
            <summary>
            Determines the kind of array that the specified type is.
            </summary>
            <param name="type">The type.</param>
            <returns>
            The kind of array of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedEnumerableElementType(System.Type)">
            <summary>
            Gets the type of the elements of a specified closed Enumerable type.
            </summary>
            <param name="type">The closed Enumerable type.</param>
            <returns>
            The type of the elements of the specified closed Enumerable type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Enumerable type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedDictionaryKeyType(System.Type)">
            <summary>
            Gets the type of the keys of a specified closed Dictionary type.
            </summary>
            <param name="type">The closed Dictionary type.</param>
            <returns>
            The type of the keys of the specified closed Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Dictionary type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedDictionaryValueType(System.Type)">
            <summary>
            Gets the type of the values of a specified closed Dictionary type.
            </summary>
            <param name="type">The closed Dictionary type.</param>
            <returns>
            The type of the values of the specified closed Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Dictionary type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemCollectionElementType(System.Type)">
            <summary>
            Gets the type of the elements of the specified closed <see cref="N:System"/> Collection type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Collection type.</param>
            <returns>
            The type of the elements of the specified closed <see cref="N:System"/> Collection type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Collection type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemCollectionType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemDictionaryKeyType(System.Type)">
            <summary>
            Gets the type of the keys of the specified closed <see cref="N:System"/> Dictionary type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Dictionary type.</param>
            <returns>
            The type of the keys of the specified closed <see cref="N:System"/> Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Dictionary type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemDictionaryValueType(System.Type)">
            <summary>
            Gets the type of the values of the specified closed <see cref="N:System"/> Dictionary type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Dictionary type.</param>
            <returns>
            The type of the values of the specified closed <see cref="N:System"/> Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Dictionary type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetGenericTypeDefinitionOrSpecifiedType(System.Type)">
            <summary>
            Gets the generic type definition of a specified type if the type is generic
            but not a generic type definition, otherwise returns the specified type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            If the specified type is a generic type but not a generic type definition then the
            generic type definition is returned, otherwise the specified type is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetInheritancePath(System.Type)">
            <summary>
            Gets the types in the inheritance path starting from the specified type's
            <see cref="P:System.Type.BaseType"/> and ending in a type with no <see cref="P:System.Type.BaseType"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            The <see cref="P:System.Type.BaseType"/> of <paramref name="type"/>, followed by that type's
            <see cref="P:System.Type.BaseType"/>, and so on until a type has no <see cref="P:System.Type.BaseType"/>
            (that property returns null).
            If <paramref name="type"/> has no <see cref="P:System.Type.BaseType"/>, then this method returns
            an empty list.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not assignable to <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.EnumerableInterfaceType"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasDefaultConstructor(System.Type)">
            <summary>
            Determines if the specified type has a default (public parameterless) constructor.
            </summary>
            <param name="type">Type to check.</param>
            <returns>
            A value indicating whether or not the type has a default (public parameterless) constructor.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasBaseType(System.Type)">
            <summary>
            Determines if the specified type has a base type.
            </summary>
            <returns>
            true if the specified type has a base type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasObjectAsBaseType(System.Type)">
            <summary>
            Determines if the base type of the specified type is object.
            </summary>
            <returns>
            true if the base type of the specified type is object, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer``1">
            <summary>
            Determines if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> will return a
            working (non-throwing) comparer for the specified type.
            </summary>
            <remarks>
            See remarks in <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer(System.Type)"/>.
            </remarks>
            <typeparam name="T">The type.</typeparam>
            <returns>
            true if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> returns a working (non-throwing)
            comparer for the specified type, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer(System.Type)">
            <summary>
            Determines if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> will return a
            working (non-throwing) comparer for the specified type.
            </summary>
            <remarks>
            <see cref="P:System.Collections.Generic.Comparer`1.Default" /> will always return some comparer for
            any given closed type.  However, that comparer, when used, will or will no
            throw based on the type itself.  If the type implements or inherits <see cref="T:System.IComparable`1"/>
            where T is itself, then the comparer will ultimately use that implementation.
            We say "ultimately" here and below because a wrapper object is used.
            If the type is nullable and the underlying type implements or inherits <see cref="T:System.IComparable`1"/>
            where T is the underlying type, then the comparer will ultimately use that implementation.
            Finally, if the the type, when boxed, implements or inherits <see cref="T:System.IComparable"/> then the comparer
            will ultimately use that implementation.  If not, then, upon using the comparer to compare two
            objects, an exception will be thrown.
            It's further important to note that this method is NOT simply checking whether the specified
            type is assignable to <see cref="T:System.IComparable`1"/>.  For example:
            typeof(IComparable&lt;string&gt;).HasWorkingDefaultComparer() == false
            That's because that type doesn't implement IComparable&lt;IComparable&lt;string&gt;&gt;
            per the heuristic described above.  That said, any type that is assignable to <see cref="T:System.IComparable"/>
            will return true per the heuristic above.  For example:
            typeof(IComparable).HasWorkingDefaultComparer() == true.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> returns a working (non-throwing)
            comparer for the specified type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="type"/> is an open type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsAssignableTo(System.Type,System.Type,System.Boolean)">
            <summary>
            Determines if a type if assignable to another type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/questions/74616/how-to-detect-if-type-is-another-generic-type/1075059#1075059" />.
            </remarks>
            <param name="type">The current type.</param>
            <param name="otherType">The type to check for ability to assign to.</param>
            <param name="treatGenericTypeDefinitionAsAssignableTo">If <paramref name="otherType"/> is a generic type definition, specifies whether the method should treat that type as if a closed type can be assigned to it (e.g. IsAssignableTo(List&lt;int&gt;, List&lt;&gt;)).</param>
            <returns>
            true if <paramref name="type"/> can be assigned to <paramref name="otherType"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherType"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="type"/> is an open type.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="otherType"/> is an open type, but not a generic type definition.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedTypeAssignableToNull(System.Type)">
            <summary>
            Determines if the specified type is closed and assignable to null.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/1770232/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is closed and assignable to null, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousType(System.Type)">
            <summary>
            Determines if a type is a closed anonymous type.
            </summary>
            <param name="type">Type to check.</param>
            <returns>A value indicating whether or not the type provided is a closed anonymous type.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousTypeFastCheck(System.Type)">
            <summary>
            Determines if a type is a closed anonymous type using a faster, but potentially
            less accurate heuristic than <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousType(System.Type)"/>.
            </summary>
            <param name="type">Type to check.</param>
            <returns>A value indicating whether or not the type provided is a closed anonymous type.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedGenericType(System.Type)">
            <summary>
            Determines if the specified type is a closed generic type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed generic type; otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedNonAnonymousClassType(System.Type)">
            <summary>
            Determines if the specified type is a class type, that's not anonymous, and is closed.
            </summary>
            <remarks>
            This is basically asking, "Is this a class type that can be constructed/new-ed up?".
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a class type, non-anonymous, and closed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedNullableType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Nullable`1"/> type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Nullable`1"/> type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="N:System"/> collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)">
            <summary>
            Determines if the specified type is a closed version one of one of the
            following <see cref="N:System"/> Dictionary generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemDictionaryGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="N:System"/> dictionary type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemEnumerableType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemKeyValuePairType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemOrderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following ordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemOrderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed, ordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemUnorderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following unordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemUnorderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed, unordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsNullableType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Nullable`1"/> type.
            </summary>
            <remarks>Adapted from: <a href="https://stackoverflow.com/a/41281601/356790" />.</remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Nullable`1"/> type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemType(System.Type)">
            <summary>
            Determines if the specified type is in the <see cref="N:System"/> namespace.
            </summary>
            <remarks>
            An array is considered a system type.
            A ValueTuple is considered a system type.
            A generic type parameter is considered a system type.
            An anonymous type is not considered a system type.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is in the <see cref="N:System"/> namespace, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="N:System"/> collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemDictionaryType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version one of one of the
            following <see cref="N:System"/> Dictionary generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemDictionaryGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="N:System"/> dictionary type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemEnumerableType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemKeyValuePairType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemOrderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following ordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemOrderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed, ordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemUnorderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following unordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemUnorderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed, unordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsTypeAssignableToNull(System.Type)">
            <summary>
            Determines if the specified type is assignable to null.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/1770232/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is assignable to null, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.MakeGenericTypeOrNull(System.Type,System.Type[])">
            <summary>
            Substitutes the elements of an array of types for the type parameters of the current
            generic type definition and returns a <see cref="T:System.Type"/> object representing the resulting constructed type
            or null if the operation cannot be performed.
            </summary>
            <param name="type">The generic type definition.</param>
            <param name="typeArguments">An array of types to be substituted for the type parameters of <paramref name="type"/>.</param>
            <returns>
            A <see cref="T:System.Type"/> representing the constructed type formed by substituting the
            elements of <paramref name="typeArguments"/> for the type parameters of <paramref name="type"/> or null
            if the operation cannot be performed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringCompilable(System.Type,System.Boolean)">
            <summary>
            Gets a compilable, readability-optimized string representation of the specified type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
            Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
            </remarks>
            <param name="type">The type.</param>
            <param name="throwIfNoCompilableStringExists">Optional value indicating whether to throw a <see cref="T:System.NotSupportedException"/> if there's no compilable representation of the specified type.</param>
            <returns>
            A compilable, readability-optimized string representation of the specified type
            OR
            null if there is no compilable representation and <paramref name="throwIfNoCompilableStringExists"/> is true.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic open constructed type, which is not supported.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic parameter.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringReadable(System.Type,OBeautifulCode.Type.Recipes.ToStringReadableOptions)">
            <summary>
            Gets a readability-optimized string representation of the specified type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
            Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
            Helpful breakdown of generics: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
            </remarks>
            <param name="type">The type.</param>
            <param name="options">The options to use when generating the string representation.</param>
            <returns>
            A readability-optimized string representation of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringXmlDoc(System.Type,System.Boolean,OBeautifulCode.Type.Recipes.ToStringXmlDocOptions)">
            <summary>
            Gets an XML-doc compatible string representation of the specified type.
            </summary>
            <param name="type">The type.</param>
            <param name="throwIfNoCompatibleStringExists">Optional value indicating whether to throw a <see cref="T:System.NotSupportedException"/> if there's no compatible string representation of the specified type.</param>
            <param name="options">The options to use when generating the string representation.</param>
            <returns>
            A XML-doc compatible string representation of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringWithoutGenericComponent(System.Type)">
            <summary>
            Gets a string representation of the specified type without the generic component.
            For example, Dictionary&lt;string, string&gt; would be represented as 'Dictionary'.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6386234/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            A string representation of the specified type with the generic component stripped out.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.TryMakeGenericType(System.Type,System.Type@,System.Type[])">
            <summary>
            Substitutes the elements of an array of types for the type parameters of the current
            generic type definition and returns a <see cref="T:System.Type"/> object representing the resulting constructed type.
            </summary>
            <param name="type">The generic type definition.</param>
            <param name="genericType">A <see cref="T:System.Type"/> representing the constructed type formed by substituting the elements of <paramref name="typeArguments"/> for the type parameters of <paramref name="type"/> or null if the operation cannot be performed.</param>
            <param name="typeArguments">An array of types to be substituted for the type parameters of <paramref name="type"/>.</param>
            <returns>
            true if the type was successfully constructed; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.Type.ProtocolAlreadyRegisteredForOperationStrategy">
            <summary>
            Determines what do when registering a protocol that supports an operation
            that is already registered with the protocol factory via some other protocol.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.ProtocolAlreadyRegisteredForOperationStrategy.Unknown">
            <summary>
            Unknown (default)
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.ProtocolAlreadyRegisteredForOperationStrategy.Throw">
            <summary>
            Throw a <see cref="T:OBeautifulCode.Type.OpExecutionFailedException"/>.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.ProtocolAlreadyRegisteredForOperationStrategy.Replace">
            <summary>
            Replace the protocol in-use for the operation with the specified protocol.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.ProtocolAlreadyRegisteredForOperationStrategy.Skip">
            <summary>
            Skip the operation; the already specified protocol will be returned for this operation.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.MissingProtocolStrategy">
            <summary>
            Determines what to do when a protocol is not found.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.MissingProtocolStrategy.Unknown">
            <summary>
            Unknown (default)
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.MissingProtocolStrategy.Throw">
            <summary>
            Throw an exception.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.MissingProtocolStrategy.ReturnNull">
            <summary>
            Return null.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.VersionMatchStrategy">
            <summary>
            Determines the acceptable version to use of some item.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.VersionMatchStrategy.Unknown">
            <summary>
            Unknown (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.VersionMatchStrategy.Any">
            <summary>
            Any version can be used.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.VersionMatchStrategy.AnySingleVersion">
            <summary>
            Any single version can be used.  If multiple versions found then there's no match.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.VersionMatchStrategy.MaxVersion">
            <summary>
            Use the max version.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.VersionMatchStrategy.MinVersion">
            <summary>
            Use the min version.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.VersionMatchStrategy.SpecifiedVersion">
            <summary>
            Use a specified version.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.OpExecutionFailedException">
            <summary>
            Exception thrown when the execution of an <see cref="T:OBeautifulCode.Type.IOperation"/> has failed.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionFailedException.#ctor(OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionFailedException"/> class.
            </summary>
            <param name="operation">OPTIONAL operation whose execution failed.  DEFAULT is to omit that operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionFailedException.#ctor(System.String,OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionFailedException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="operation">OPTIONAL operation whose execution failed.  DEFAULT is to omit that operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionFailedException.#ctor(System.String,System.Exception,OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionFailedException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
            <param name="operation">OPTIONAL operation whose execution failed.  DEFAULT is to omit that operation.</param>
        </member>
        <member name="T:OBeautifulCode.Type.OpExecutionAbortedException">
            <summary>
            Exception thrown when the execution of an <see cref="T:OBeautifulCode.Type.IOperation"/> is aborted.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionAbortedException.#ctor(OBeautifulCode.Type.IOperation,OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionAbortedException"/> class.
            </summary>
            <param name="executingOperation">OPTIONAL operation that was executing and is now aborted.  DEFAULT is to omit that operation.</param>
            <param name="abortingOperation">OPTIONAL operation that aborted the execution of <paramref name="executingOperation"/>.  DEFAULT is to omit that operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionAbortedException.#ctor(System.String,OBeautifulCode.Type.IOperation,OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionAbortedException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="executingOperation">OPTIONAL operation that was executing and is now aborted.  DEFAULT is to omit that operation.</param>
            <param name="abortingOperation">OPTIONAL operation that aborted the execution of <paramref name="executingOperation"/>.  DEFAULT is to omit that operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionAbortedException.#ctor(System.String,System.Exception,OBeautifulCode.Type.IOperation,OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionAbortedException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
            <param name="executingOperation">OPTIONAL operation that was executing and is now aborted.  DEFAULT is to omit that operation.</param>
            <param name="abortingOperation">OPTIONAL operation that aborted the execution of <paramref name="executingOperation"/>.  DEFAULT is to omit that operation.</param>
        </member>
        <member name="T:OBeautifulCode.Type.OpExecutionFailedExceptionBase">
            <summary>
            Base class for exception thrown when the execution of an <see cref="T:OBeautifulCode.Type.IOperation"/> has failed.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionFailedExceptionBase.#ctor(OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionFailedExceptionBase"/> class.
            </summary>
            <param name="operation">The operation whose execution failed.</param>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionFailedExceptionBase.#ctor(System.String,OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionFailedExceptionBase"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="operation">The operation whose execution failed.</param>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionFailedExceptionBase.#ctor(System.String,System.Exception,OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionFailedExceptionBase"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
            <param name="operation">The operation whose execution failed.</param>
        </member>
        <member name="P:OBeautifulCode.Type.OpExecutionFailedExceptionBase.Operation">
            <summary>
            Gets the operation that was executing and is now failed.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionFailedExceptionBase.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.OpExecutionAbortedExceptionBase">
            <summary>
            Base class for exception thrown when the execution of an <see cref="T:OBeautifulCode.Type.IOperation"/> is aborted.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionAbortedExceptionBase.#ctor(OBeautifulCode.Type.IOperation,OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionAbortedExceptionBase"/> class.
            </summary>
            <param name="executingOperation">The operation that was executing and is now aborted.</param>
            <param name="abortingOperation">The operation that aborted the execution of <paramref name="executingOperation"/>.</param>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionAbortedExceptionBase.#ctor(System.String,OBeautifulCode.Type.IOperation,OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionAbortedExceptionBase"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="executingOperation">The operation that was executing and is now aborted.</param>
            <param name="abortingOperation">The operation that aborted the execution of <paramref name="executingOperation"/>.</param>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionAbortedExceptionBase.#ctor(System.String,System.Exception,OBeautifulCode.Type.IOperation,OBeautifulCode.Type.IOperation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.OpExecutionAbortedExceptionBase"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
            <param name="executingOperation">The operation that was executing and is now aborted.</param>
            <param name="abortingOperation">The operation that aborted the execution of <paramref name="executingOperation"/>.</param>
        </member>
        <member name="P:OBeautifulCode.Type.OpExecutionAbortedExceptionBase.ExecutingOperation">
            <summary>
            Gets the operation that was executing and is now aborted.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Type.OpExecutionAbortedExceptionBase.AbortingOperation">
            <summary>
            Gets the operation that aborted the execution of <see cref="P:OBeautifulCode.Type.OpExecutionAbortedExceptionBase.ExecutingOperation"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.OpExecutionAbortedExceptionBase.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.IThrowOpExecutionAbortedExceptionOp">
            <summary>
            An operation that throws an <see cref="T:OBeautifulCode.Type.OpExecutionAbortedExceptionBase"/>.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.ProtocolFactoryExtensions">
            <summary>
            Extension methods related to <see cref="T:OBeautifulCode.Type.IProtocolFactory"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolFactoryExtensions.GetProtocolAndExecuteViaReflection(OBeautifulCode.Type.ISyncReturningProtocol{OBeautifulCode.Type.GetProtocolOp,OBeautifulCode.Type.IProtocol},OBeautifulCode.Type.IOperation)">
            <summary>
            Executes a void operation synchronously using a protocol returned by a specified protocol factory.
            </summary>
            <param name="protocolFactory">The protocol factory.</param>
            <param name="operation">The operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolFactoryExtensions.GetProtocolAndExecuteViaReflection``1(OBeautifulCode.Type.ISyncReturningProtocol{OBeautifulCode.Type.GetProtocolOp,OBeautifulCode.Type.IProtocol},OBeautifulCode.Type.IOperation)">
            <summary>
            Executes a returning operation synchronously using a protocol returned by a specified protocol factory.
            </summary>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
            <param name="protocolFactory">The protocol factory.</param>
            <param name="operation">The operation.</param>
            <returns>
            The results of executing the operation.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolFactoryExtensions.GetProtocolAndExecuteViaReflectionAsync(OBeautifulCode.Type.IAsyncReturningProtocol{OBeautifulCode.Type.GetProtocolOp,OBeautifulCode.Type.IProtocol},OBeautifulCode.Type.IOperation)">
            <summary>
            Executes a void operation asynchronously using a protocol returned by a specified protocol factory.
            </summary>
            <param name="protocolFactory">The protocol factory.</param>
            <param name="operation">The operation.</param>
            <returns>
            A task.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolFactoryExtensions.GetProtocolAndExecuteViaReflectionAsync``1(OBeautifulCode.Type.IAsyncReturningProtocol{OBeautifulCode.Type.GetProtocolOp,OBeautifulCode.Type.IProtocol},OBeautifulCode.Type.IOperation)">
            <summary>
            Executes a returning operation asynchronously using a protocol returned by a specified protocol factory.
            </summary>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
            <param name="protocolFactory">The protocol factory.</param>
            <param name="operation">The operation.</param>
            <returns>
            The results of executing the operation.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Type.ProtocolExtensions">
            <summary>
            Extension methods related to <see cref="T:OBeautifulCode.Type.IProtocol"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolExtensions.ExecuteViaReflection(OBeautifulCode.Type.IProtocol,OBeautifulCode.Type.IOperation)">
            <summary>
            Executes the specified non-returning operation synchronously, using a specified protocol.
            </summary>
            <remarks>
            This is intended for use with <see cref="T:OBeautifulCode.Type.IProtocol"/>.
            Be aware that this will throw a runtime failure if the protocol cannot execute the operation.
            This is generally used in conjunction with an <see cref="T:OBeautifulCode.Type.IProtocolFactory"/>
            which will ensure that the protocol coming out of the factory can in fact execute the specified operation.
            </remarks>
            <param name="protocol">The protocol.</param>
            <param name="operation">The operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolExtensions.ExecuteViaReflection``1(OBeautifulCode.Type.IProtocol,OBeautifulCode.Type.IOperation)">
            <summary>
            Executes the specified returning operation synchronously, using a specified protocol.
            </summary>
            <remarks>
            This is intended for use with <see cref="T:OBeautifulCode.Type.IProtocol"/>.
            Be aware that this will throw a runtime failure if the protocol cannot execute the operation.
            This is generally used in conjunction with an <see cref="T:OBeautifulCode.Type.IProtocolFactory"/>
            which will ensure that the protocol coming out of the factory can in fact execute the specified operation.
            </remarks>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
            <param name="protocol">The protocol.</param>
            <param name="operation">The operation.</param>
            <returns>
            The result of executing the specified operation using the specified protocol.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolExtensions.ExecuteViaReflectionAsync(OBeautifulCode.Type.IProtocol,OBeautifulCode.Type.IOperation)">
            <summary>
            Executes the specified non-returning operation asynchronously, using a specified protocol.
            </summary>
            <remarks>
            This is intended for use with <see cref="T:OBeautifulCode.Type.IProtocol"/>.
            Be aware that this will throw a runtime failure if the protocol cannot execute the operation.
            This is generally used in conjunction with an <see cref="T:OBeautifulCode.Type.IProtocolFactory"/>
            which will ensure that the protocol coming out of the factory can in fact execute the specified operation.
            </remarks>
            <param name="protocol">The protocol.</param>
            <param name="operation">The operation.</param>
            <returns>
            A task.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolExtensions.ExecuteViaReflectionAsync``1(OBeautifulCode.Type.IProtocol,OBeautifulCode.Type.IOperation)">
            <summary>
            Executes the specified returning operation asynchronously, using a specified protocol.
            </summary>
            <remarks>
            This is intended for use with <see cref="T:OBeautifulCode.Type.IProtocol"/>.
            Be aware that this will throw a runtime failure if the protocol cannot execute the operation.
            This is generally used in conjunction with an <see cref="T:OBeautifulCode.Type.IProtocolFactory"/>
            which will ensure that the protocol coming out of the factory can in fact execute the specified operation.
            </remarks>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
            <param name="protocol">The protocol.</param>
            <param name="operation">The operation.</param>
            <returns>
            The result of executing the specified operation using the specified protocol.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolExtensions.ToProtocolFactory(OBeautifulCode.Type.IProtocol)">
            <summary>
            Creates a <see cref="T:OBeautifulCode.Type.IProtocolFactory"/> for the supported operations on a specified protocol.
            </summary>
            <param name="protocol">The protocol.</param>
            <returns>
            A <see cref="T:OBeautifulCode.Type.IProtocolFactory" /> for the supported operations on the specified protocol.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Type.LambdaReturningProtocol`2">
            <summary>
            Protocolizes a returning lambda.
            </summary>
            <typeparam name="TOperation">Type of operation.</typeparam>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.LambdaReturningProtocol`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.LambdaReturningProtocol`2"/> class.
            </summary>
            <param name="asynchronousLambda">The lambda to protocol the operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.LambdaReturningProtocol`2.#ctor(System.Func{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.LambdaReturningProtocol`2"/> class.
            </summary>
            <param name="synchronousLambda">The lambda to protocol the operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.LambdaReturningProtocol`2.#ctor(System.Func{`0,`1},System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.LambdaReturningProtocol`2"/> class.
            </summary>
            <param name="synchronousLambda">The synchronous lambda to protocol the operation.</param>
            <param name="asynchronousLambda">The asynchronous lambda to protocol the operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.LambdaReturningProtocol`2.Execute(`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.LambdaReturningProtocol`2.ExecuteAsync(`0)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.LambdaVoidProtocol`1">
            <summary>
            Protocolizes a non-returning lambda.
            </summary>
            <typeparam name="TOperation">Type of operation.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.LambdaVoidProtocol`1.#ctor(System.Func{`0,System.Threading.Tasks.Task})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.LambdaVoidProtocol`1"/> class.
            </summary>
            <param name="asynchronousLambda">The lambda to protocol the operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.LambdaVoidProtocol`1.#ctor(System.Action{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.LambdaVoidProtocol`1"/> class.
            </summary>
            <param name="synchronousLambda">The lambda to protocol the operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.LambdaVoidProtocol`1.#ctor(System.Action{`0},System.Func{`0,System.Threading.Tasks.Task})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.LambdaVoidProtocol`1"/> class.
            </summary>
            <param name="synchronousLambda">The synchronous lambda to protocol the operation.</param>
            <param name="asynchronousLambda">The asynchronous lambda to protocol the operation.</param>
        </member>
        <member name="M:OBeautifulCode.Type.LambdaVoidProtocol`1.Execute(`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.LambdaVoidProtocol`1.ExecuteAsync(`0)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.ChainOfResponsibilityProtocolFactory">
            <summary>
            An <see cref="T:OBeautifulCode.Type.IProtocolFactory"/> that uses the chain-of-responsibility design pattern to iterate
            through a specified, ordered list of protocol factories, looking for the first one that can
            execute a specified operation.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.ChainOfResponsibilityProtocolFactory.#ctor(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Type.IProtocolFactory})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.ChainOfResponsibilityProtocolFactory"/> class.
            </summary>
            <param name="protocolFactoriesToUseInOrder">The protocol factories to use, in order of precedence.</param>
        </member>
        <member name="M:OBeautifulCode.Type.ChainOfResponsibilityProtocolFactory.AddToEndOfChain(OBeautifulCode.Type.IProtocolFactory)">
            <summary>
            Adds a protocol factory to the end of the chain-of-responsibility.
            </summary>
            <param name="protocolFactory">The protocol's type.  Use concrete types.  These protocols can execute multiple operations and those will be honored in the factory.</param>
        </member>
        <member name="M:OBeautifulCode.Type.ChainOfResponsibilityProtocolFactory.Execute(OBeautifulCode.Type.GetProtocolOp)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ChainOfResponsibilityProtocolFactory.ExecuteAsync(OBeautifulCode.Type.GetProtocolOp)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.ProtocolFactory">
            <summary>
            Stock implementation of <see cref="T:OBeautifulCode.Type.IProtocolFactory"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolFactory.#ctor(System.Collections.Generic.IReadOnlyDictionary{System.Type,System.Func{OBeautifulCode.Type.IProtocol}})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.ProtocolFactory"/> class.
            </summary>
            <param name="protocolTypeToGetProtocolFuncMap">
            A map of protocol type to a func that returns an instance of the protocol.
            Use the protocols' concrete types.
            These protocols can execute multiple operations and those will be honored in the factory.
            Protocols can also be registered after construction.
            </param>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolFactory.RegisterProtocolForSupportedOperations(System.Type,System.Func{OBeautifulCode.Type.IProtocol},OBeautifulCode.Type.ProtocolAlreadyRegisteredForOperationStrategy)">
            <summary>
            Registers a protocol with the factory to be used for the operations supported by the protocol.
            </summary>
            <param name="protocolType">The protocol's type.  Use concrete types.  These protocols can execute multiple operations and those will be honored in the factory.</param>
            <param name="getProtocolFunc">A func that gets an instance of the protocol.</param>
            <param name="protocolAlreadyRegisteredForOperationStrategy">OPTIONAL value that determines what do when the protocol supports an operation has already been registered via some other protocol.  DEFAULT is to throw an exception.</param>
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolFactory.Execute(OBeautifulCode.Type.GetProtocolOp)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolFactory.ExecuteAsync(OBeautifulCode.Type.GetProtocolOp)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolFactory.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ProtocolFactory.ShallowClone">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp">
            <summary>
            Operation that throws a <see cref="T:OBeautifulCode.Type.OpExecutionAbortedExceptionBase"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp"/> class.
            </summary>
            <param name="details">Details about the operation.</param>
        </member>
        <member name="P:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.Details">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.op_Equality(OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp,OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.op_Inequality(OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp,OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.Equals(OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.DeepCloneWithDetails(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.Details" />.
            </summary>
            <param name="details">The new <see cref="P:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.Details" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp" /> using the specified <paramref name="details" /> for <see cref="P:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.Details" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1">
            <summary>
            Operation that throws a <see cref="T:OBeautifulCode.Type.OpExecutionAbortedExceptionBase"/>.
            </summary>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1"/> class.
            </summary>
            <param name="details">Details about the operation.</param>
        </member>
        <member name="P:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.Details">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.op_Equality(OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp{`0},OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.op_Inequality(OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp{`0},OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.Equals(OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.DeepCloneWithDetails(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.Details" />.
            </summary>
            <param name="details">The new <see cref="P:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.Details" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1" /> using the specified <paramref name="details" /> for <see cref="P:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.Details" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ThrowOpExecutionAbortedExceptionOp`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.GetProtocolOp">
            <summary>
            Gets the protocol to use for a specified <see cref="T:OBeautifulCode.Type.IOperation"/> object.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.GetProtocolOp.#ctor(OBeautifulCode.Type.IOperation,OBeautifulCode.Type.MissingProtocolStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.GetProtocolOp"/> class.
            </summary>
            <param name="operation">The operation.</param>
            <param name="missingProtocolStrategy">OPTIONAL value that determine what to do if the protocol is missing.  DEFAULT is to throw.</param>
        </member>
        <member name="P:OBeautifulCode.Type.GetProtocolOp.Operation">
            <summary>
            Gets the operation.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Type.GetProtocolOp.MissingProtocolStrategy">
            <summary>
            Gets a value that determines what to do if the protocol is missing.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.GetProtocolOp.op_Equality(OBeautifulCode.Type.GetProtocolOp,OBeautifulCode.Type.GetProtocolOp)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.GetProtocolOp"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.GetProtocolOp.op_Inequality(OBeautifulCode.Type.GetProtocolOp,OBeautifulCode.Type.GetProtocolOp)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.GetProtocolOp"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.GetProtocolOp.Equals(OBeautifulCode.Type.GetProtocolOp)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.GetProtocolOp.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.GetProtocolOp.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.GetProtocolOp.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.GetProtocolOp.DeepCloneWithOperation(OBeautifulCode.Type.IOperation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.GetProtocolOp.Operation" />.
            </summary>
            <param name="operation">The new <see cref="P:OBeautifulCode.Type.GetProtocolOp.Operation" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.GetProtocolOp" /> using the specified <paramref name="operation" /> for <see cref="P:OBeautifulCode.Type.GetProtocolOp.Operation" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.GetProtocolOp.DeepCloneWithMissingProtocolStrategy(OBeautifulCode.Type.MissingProtocolStrategy)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.GetProtocolOp.MissingProtocolStrategy" />.
            </summary>
            <param name="missingProtocolStrategy">The new <see cref="P:OBeautifulCode.Type.GetProtocolOp.MissingProtocolStrategy" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.GetProtocolOp" /> using the specified <paramref name="missingProtocolStrategy" /> for <see cref="P:OBeautifulCode.Type.GetProtocolOp.MissingProtocolStrategy" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.GetProtocolOp.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.GetProtocolOp.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.IProtocolFactory">
            <summary>
            Returns the protocol to use for a given operation.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.NamedValueExtensions">
            <summary>
            Extension methods related to <see cref="T:OBeautifulCode.Type.NamedValue`1"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValueExtensions.GetNames``1(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Type.NamedValue{``0}})">
            <summary>
            Gets the names of an ordered collection of <see cref="T:OBeautifulCode.Type.NamedValue`1"/>.
            </summary>
            <typeparam name="TValue">The type of values.</typeparam>
            <param name="source">The source collection.</param>
            <returns>
            The names of the specified ordered collection of <see cref="T:OBeautifulCode.Type.NamedValue`1"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> contains a null element.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValueExtensions.GetNames``1(System.Collections.Generic.IReadOnlyCollection{OBeautifulCode.Type.NamedValue{``0}})">
            <summary>
            Gets the names of an unordered collection of <see cref="T:OBeautifulCode.Type.NamedValue`1"/>.
            </summary>
            <typeparam name="TValue">The type of values.</typeparam>
            <param name="source">The source collection.</param>
            <returns>
            The names of the specified unordered collection of <see cref="T:OBeautifulCode.Type.NamedValue`1"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> contains a null element.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValueExtensions.GetValues``1(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Type.NamedValue{``0}})">
            <summary>
            Gets the values of an ordered collection of <see cref="T:OBeautifulCode.Type.NamedValue`1"/>.
            </summary>
            <typeparam name="TValue">The type of values.</typeparam>
            <param name="source">The source collection.</param>
            <returns>
            The values of the specified ordered collection of <see cref="T:OBeautifulCode.Type.NamedValue`1"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> contains a null element.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValueExtensions.GetValues``1(System.Collections.Generic.IReadOnlyCollection{OBeautifulCode.Type.NamedValue{``0}})">
            <summary>
            Gets the values of an unordered collection of <see cref="T:OBeautifulCode.Type.NamedValue`1"/>.
            </summary>
            <typeparam name="TValue">The type of values.</typeparam>
            <param name="source">The source collection.</param>
            <returns>
            The values of the specified unordered collection of <see cref="T:OBeautifulCode.Type.NamedValue`1"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> contains a null element.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValueExtensions.GetSingleValue``1(System.Collections.Generic.IReadOnlyList{OBeautifulCode.Type.NamedValue{``0}},System.String)">
            <summary>
            Gets the single value contained in an ordered collection of <see cref="T:OBeautifulCode.Type.NamedValue`1"/> having a specified name.
            </summary>
            <typeparam name="TValue">The type of values.</typeparam>
            <param name="source">The source collection.</param>
            <param name="name">The name to search for.</param>
            <returns>
            The single value having the specified name.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="name"/> is white space.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> contains a null element.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="source"/> contains no elements named <paramref name="name"/> -or- contains two or more elements named <paramref name="name"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValueExtensions.GetSingleValue``1(System.Collections.Generic.IReadOnlyCollection{OBeautifulCode.Type.NamedValue{``0}},System.String)">
            <summary>
            Gets the single value contained in an unordered collection of <see cref="T:OBeautifulCode.Type.NamedValue`1"/> having a specified name.
            </summary>
            <typeparam name="TValue">The type of values.</typeparam>
            <param name="source">The source collection.</param>
            <param name="name">The name to search for.</param>
            <returns>
            The single value having the specified name.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="name"/> is white space.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> contains a null element.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="source"/> contains no elements named <paramref name="name"/> -or- contains two or more elements named <paramref name="name"/>.</exception>
        </member>
        <member name="T:OBeautifulCode.Type.IEvent`1">
            <summary>
            An record of something that has occurred and has a unique identifier.
            </summary>
            <typeparam name="TId">Type of the identifier.</typeparam>
        </member>
        <member name="T:OBeautifulCode.Type.IEvent">
            <summary>
            A record of something that has occurred.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IOperation">
             <summary>
             An operation is, conceptually, a method on an interface.
             </summary>
             <remarks>
             Some operations return an object and some don't.  The operation needs to be named and should be suffixed with
             Op' (e.g. DoSomeWorkOp).  Operations have 0 or more parameters.  These define the data with which the operation
             is being performed and any behavioral variables.
            
             Only abstract classes should implement this interface.  Other interfaces should not implement this interface.
             By defining operations in classes it forces the consumer to specify one operation per class (i.e. you can't
             implement the same interface multiple times for different conceptual operations).  This simplifies the
             definition, consumption, and serialization of operations.
            
             The two implementors below differentiate operations that return versus those that don't.  When you inherit
             from one of these base classes, the nature of the operation from a return perspective should be evident and
             declarative because it prevents the consumer from defining a void operation where a returning operation is
             actually required.  The TResult in <see cref="T:OBeautifulCode.Type.ReturningOperationBase`1"/> is not used by the class itself
             and is thus not enforced when the operation is being authored.  However, the
             <see cref="T:OBeautifulCode.Type.IProtocol`1"/> associated with the operation requires this generic parameter to define
             the signature of the method that can execute the operation.
             </remarks>
        </member>
        <member name="T:OBeautifulCode.Type.IReturningOperation`1">
            <summary>
            Interface necessary for a returning operation to connect to a protocol.
            </summary>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
        </member>
        <member name="T:OBeautifulCode.Type.IVoidOperation">
            <summary>
            Interface necessary for a void operation to connect to a protocol.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IAsyncReturningProtocol`2">
            <summary>
            Executes a <see cref="T:OBeautifulCode.Type.IReturningOperation`1"/> asynchronously.
            </summary>
            <typeparam name="TOperation">The type of the operation.</typeparam>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.IAsyncReturningProtocol`2.ExecuteAsync(`0)">
            <summary>
            Executes the operation.
            </summary>
            <param name="operation">The operation.</param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="T:OBeautifulCode.Type.IAsyncVoidProtocol`1">
            <summary>
            Executes a <see cref="T:OBeautifulCode.Type.IVoidOperation"/> asynchronously.
            </summary>
            <typeparam name="TOperation">The type of the operation.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.IAsyncVoidProtocol`1.ExecuteAsync(`0)">
            <summary>
            Executes the operation.
            </summary>
            <param name="operation">The operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous operation.</returns>
        </member>
        <member name="T:OBeautifulCode.Type.IProtocol">
            <summary>
            Executes an operation.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IProtocol`1">
            <summary>
            Executes an operation.
            </summary>
            <typeparam name="TOperation">The type of the operation.</typeparam>
        </member>
        <member name="T:OBeautifulCode.Type.ISyncReturningProtocol`2">
            <summary>
            Executes a <see cref="T:OBeautifulCode.Type.IReturningOperation`1"/> synchronously.
            </summary>
            <typeparam name="TOperation">The type of the operation.</typeparam>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.ISyncReturningProtocol`2.Execute(`0)">
            <summary>
            Executes the operation.
            </summary>
            <param name="operation">The operation.</param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="T:OBeautifulCode.Type.ISyncAndAsyncReturningProtocol`2">
            <summary>
            Executes a <see cref="T:OBeautifulCode.Type.IReturningOperation`1"/> both synchronously and asynchronously.
            </summary>
            <typeparam name="TOperation">The type of the operation.</typeparam>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
        </member>
        <member name="T:OBeautifulCode.Type.ISyncAndAsyncVoidProtocol`1">
            <summary>
            Executes a <see cref="T:OBeautifulCode.Type.IVoidOperation"/> both synchronously and asynchronously.
            </summary>
            <typeparam name="TOperation">The type of the operation.</typeparam>
        </member>
        <member name="T:OBeautifulCode.Type.ISyncVoidProtocol`1">
            <summary>
            Executes a <see cref="T:OBeautifulCode.Type.IVoidOperation"/> synchronously.
            </summary>
            <typeparam name="TOperation">The type of the operation.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.ISyncVoidProtocol`1.Execute(`0)">
            <summary>
            Executes the operation.
            </summary>
            <param name="operation">The operation.</param>
        </member>
        <member name="T:OBeautifulCode.Type.IHaveDetails">
            <summary>
            Interface to declare having details or context on some action or event.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Type.IHaveDetails.Details">
            <summary>
            Gets the details.
            </summary>
            <value>The details.</value>
        </member>
        <member name="T:OBeautifulCode.Type.AsyncSpecificReturningProtocolBase`2">
            <summary>
            Protocol that gives pass-through implementation for the synchronous execution for <see cref="T:OBeautifulCode.Type.ISyncAndAsyncReturningProtocol`2"/>.
            </summary>
            <typeparam name="TOperation">Type of operation.</typeparam>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.AsyncSpecificReturningProtocolBase`2.Execute(`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.AsyncSpecificReturningProtocolBase`2.ExecuteAsync(`0)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.AsyncSpecificVoidProtocolBase`1">
            <summary>
            Protocol that gives pass-through implementation for the synchronous execution for <see cref="T:OBeautifulCode.Type.ISyncAndAsyncVoidProtocol`1"/>.
            </summary>
            <typeparam name="TOperation">Type of operation.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.AsyncSpecificVoidProtocolBase`1.Execute(`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.AsyncSpecificVoidProtocolBase`1.ExecuteAsync(`0)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.SyncSpecificReturningProtocolBase`2">
            <summary>
            Protocol that gives pass-through implementation for the asynchronous execution for <see cref="T:OBeautifulCode.Type.ISyncAndAsyncReturningProtocol`2"/>.
            </summary>
            <typeparam name="TOperation">Type of operation.</typeparam>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.SyncSpecificReturningProtocolBase`2.Execute(`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.SyncSpecificReturningProtocolBase`2.ExecuteAsync(`0)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.SyncSpecificVoidProtocolBase`1">
            <summary>
            Protocol that gives pass-through implementation for the asynchronous execution for <see cref="T:OBeautifulCode.Type.ISyncAndAsyncVoidProtocol`1"/>.
            </summary>
            <typeparam name="TOperation">Type of operation.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.SyncSpecificVoidProtocolBase`1.Execute(`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.SyncSpecificVoidProtocolBase`1.ExecuteAsync(`0)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.EventBase">
            <summary>
            Base implementation of <see cref="T:OBeautifulCode.Type.IEvent"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.EventBase.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.EventBase"/> class.
            </summary>
            <param name="timestampUtc">The time of the event in UTC.</param>
        </member>
        <member name="P:OBeautifulCode.Type.EventBase.TimestampUtc">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.EventBase.op_Equality(OBeautifulCode.Type.EventBase,OBeautifulCode.Type.EventBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.EventBase"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.EventBase.op_Inequality(OBeautifulCode.Type.EventBase,OBeautifulCode.Type.EventBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.EventBase"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.EventBase.Equals(OBeautifulCode.Type.EventBase)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.EventBase.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.EventBase.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.EventBase.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.EventBase.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.EventBase.DeepCloneWithTimestampUtc(System.DateTime)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.EventBase.TimestampUtc" />.
            </summary>
            <param name="timestampUtc">The new <see cref="P:OBeautifulCode.Type.EventBase.TimestampUtc" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.EventBase" /> using the specified <paramref name="timestampUtc" /> for <see cref="P:OBeautifulCode.Type.EventBase.TimestampUtc" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.EventBase.DeepCloneInternal">
            <summary>
            Creates a new object that is a deep clone of this instance.
            </summary>
            <returns>
            A new object that is a deep clone of this instance.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.EventBase.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.EventBase`1">
            <summary>
            Base implementation of <see cref="T:OBeautifulCode.Type.IEvent`1"/>.
            </summary>
            <typeparam name="TId">The type of the identifier.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.EventBase`1.#ctor(`0,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.EventBase`1"/> class.
            </summary>
            <param name="id">The identifier.</param>
            <param name="timestampUtc">The timestamp in UTC.</param>
        </member>
        <member name="P:OBeautifulCode.Type.EventBase`1.Id">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.EventBase`1.op_Equality(OBeautifulCode.Type.EventBase{`0},OBeautifulCode.Type.EventBase{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.EventBase`1"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.EventBase`1.op_Inequality(OBeautifulCode.Type.EventBase{`0},OBeautifulCode.Type.EventBase{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.EventBase`1"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.EventBase`1.Equals(OBeautifulCode.Type.EventBase{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.EventBase`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.EventBase`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.EventBase`1.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.EventBase`1.DeepCloneWithId(`0)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.EventBase`1.Id" />.
            </summary>
            <param name="id">The new <see cref="P:OBeautifulCode.Type.EventBase`1.Id" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.EventBase`1" /> using the specified <paramref name="id" /> for <see cref="P:OBeautifulCode.Type.EventBase`1.Id" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.EventBase`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`2">
            <summary>
            Event with a <typeparamref name="TOperation"/> to execute.
            </summary>
            <typeparam name="TId">Type of the event identifier.</typeparam>
            <typeparam name="TOperation"><see cref="T:OBeautifulCode.Type.IOperation"/> to execute.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.#ctor(`0,`1,System.DateTime,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`2"/> class.
            </summary>
            <param name="id">The identifier of the event.</param>
            <param name="operation">Operation to execute.</param>
            <param name="timestampUtc">The timestamp of the event in UTC.</param>
            <param name="details">The optional details about the completion.</param>
        </member>
        <member name="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.Operation">
            <summary>
            Gets the operation.
            </summary>
            <value>The operation.</value>
        </member>
        <member name="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.Details">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.op_Equality(OBeautifulCode.Type.ExecuteOpRequestedEvent{`0,`1},OBeautifulCode.Type.ExecuteOpRequestedEvent{`0,`1})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`2"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.op_Inequality(OBeautifulCode.Type.ExecuteOpRequestedEvent{`0,`1},OBeautifulCode.Type.ExecuteOpRequestedEvent{`0,`1})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`2"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.Equals(OBeautifulCode.Type.ExecuteOpRequestedEvent{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.DeepCloneWithTimestampUtc(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.DeepCloneWithId(`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.DeepCloneWithOperation(`1)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.Operation" />.
            </summary>
            <param name="operation">The new <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.Operation" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`2" /> using the specified <paramref name="operation" /> for <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.Operation" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.DeepCloneWithDetails(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.Details" />.
            </summary>
            <param name="details">The new <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.Details" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`2" /> using the specified <paramref name="details" /> for <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.Details" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`2.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`1">
            <summary>
            Event with a <typeparamref name="TOperation"/> to execute.
            </summary>
            <typeparam name="TOperation"><see cref="T:OBeautifulCode.Type.IOperation"/> to execute.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.#ctor(`0,System.DateTime,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`1"/> class.
            </summary>
            <param name="operation">Operation to execute.</param>
            <param name="timestampUtc">The timestamp of the event in UTC.</param>
            <param name="details">The optional details about the completion.</param>
        </member>
        <member name="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.Operation">
            <summary>
            Gets the operation.
            </summary>
            <value>The operation.</value>
        </member>
        <member name="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.Details">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.op_Equality(OBeautifulCode.Type.ExecuteOpRequestedEvent{`0},OBeautifulCode.Type.ExecuteOpRequestedEvent{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`1"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.op_Inequality(OBeautifulCode.Type.ExecuteOpRequestedEvent{`0},OBeautifulCode.Type.ExecuteOpRequestedEvent{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`1"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.Equals(OBeautifulCode.Type.ExecuteOpRequestedEvent{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.DeepCloneWithTimestampUtc(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.DeepCloneWithOperation(`0)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.Operation" />.
            </summary>
            <param name="operation">The new <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.Operation" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`1" /> using the specified <paramref name="operation" /> for <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.Operation" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.DeepCloneWithDetails(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.Details" />.
            </summary>
            <param name="details">The new <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.Details" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.ExecuteOpRequestedEvent`1" /> using the specified <paramref name="details" /> for <see cref="P:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.Details" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ExecuteOpRequestedEvent`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.NullEvent">
            <summary>
            Null object pattern implementation for <see cref="T:OBeautifulCode.Type.EventBase"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.NullEvent"/> class.
            </summary>
            <param name="timestampUtc">The timestamp; probably best to put <see cref="F:System.DateTime.MinValue"/> converted to UTC.  Cannot be defaulted do to framework limitations.</param>
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent.op_Equality(OBeautifulCode.Type.NullEvent,OBeautifulCode.Type.NullEvent)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.NullEvent"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent.op_Inequality(OBeautifulCode.Type.NullEvent,OBeautifulCode.Type.NullEvent)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.NullEvent"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent.Equals(OBeautifulCode.Type.NullEvent)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent.DeepCloneWithTimestampUtc(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.NullEvent`1">
            <summary>
            Null object pattern implementation for <see cref="T:OBeautifulCode.Type.EventBase`1"/>.
            </summary>
            <typeparam name="TId">The type of the identifier.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent`1.#ctor(`0,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.NullEvent`1"/> class.
            </summary>
            <param name="id">The identifier.</param>
            <param name="timestampUtc">The timestamp; probably best to put <see cref="F:System.DateTime.MinValue"/> converted to UTC.  Cannot be defaulted do to framework limitations.</param>
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent`1.op_Equality(OBeautifulCode.Type.NullEvent{`0},OBeautifulCode.Type.NullEvent{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.NullEvent`1"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent`1.op_Inequality(OBeautifulCode.Type.NullEvent{`0},OBeautifulCode.Type.NullEvent{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.NullEvent`1"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent`1.Equals(OBeautifulCode.Type.NullEvent{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent`1.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent`1.DeepCloneWithTimestampUtc(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent`1.DeepCloneWithId(`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent`1.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullEvent`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.NamedValue`1">
            <summary>
            A value with an associate name.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValue`1.#ctor(System.String,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.NamedValue`1"/> class.
            </summary>
            <param name="name">The name of the value.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:OBeautifulCode.Type.NamedValue`1.Name">
            <summary>
            Gets the name of the value.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Type.NamedValue`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValue`1.op_Equality(OBeautifulCode.Type.NamedValue{`0},OBeautifulCode.Type.NamedValue{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.NamedValue`1"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValue`1.op_Inequality(OBeautifulCode.Type.NamedValue{`0},OBeautifulCode.Type.NamedValue{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.NamedValue`1"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValue`1.Equals(OBeautifulCode.Type.NamedValue{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NamedValue`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NamedValue`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NamedValue`1.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NamedValue`1.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NamedValue`1.DeepCloneWithName(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.NamedValue`1.Name" />.
            </summary>
            <param name="name">The new <see cref="P:OBeautifulCode.Type.NamedValue`1.Name" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.NamedValue`1" /> using the specified <paramref name="name" /> for <see cref="P:OBeautifulCode.Type.NamedValue`1.Name" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValue`1.DeepCloneWithValue(`0)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.NamedValue`1.Value" />.
            </summary>
            <param name="value">The new <see cref="P:OBeautifulCode.Type.NamedValue`1.Value" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.NamedValue`1" /> using the specified <paramref name="value" /> for <see cref="P:OBeautifulCode.Type.NamedValue`1.Value" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NamedValue`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.NullReturningOp`1">
            <summary>
            Null object pattern implementation for <see cref="T:OBeautifulCode.Type.ReturningOperationBase`1"/>.
            </summary>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.NullReturningOp`1.op_Equality(OBeautifulCode.Type.NullReturningOp{`0},OBeautifulCode.Type.NullReturningOp{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.NullReturningOp`1"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NullReturningOp`1.op_Inequality(OBeautifulCode.Type.NullReturningOp{`0},OBeautifulCode.Type.NullReturningOp{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.NullReturningOp`1"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NullReturningOp`1.Equals(OBeautifulCode.Type.NullReturningOp{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullReturningOp`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullReturningOp`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullReturningOp`1.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullReturningOp`1.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullReturningOp`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.TestVoidOp">
            <summary>
            A void operation for testing.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.TestVoidOp.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.TestVoidOp"/> class.
            </summary>
            <param name="details">Details about the operation.</param>
        </member>
        <member name="P:OBeautifulCode.Type.TestVoidOp.Details">
            <summary>
            Gets details about the operation.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.TestVoidOp.op_Equality(OBeautifulCode.Type.TestVoidOp,OBeautifulCode.Type.TestVoidOp)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.TestVoidOp"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.TestVoidOp.op_Inequality(OBeautifulCode.Type.TestVoidOp,OBeautifulCode.Type.TestVoidOp)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.TestVoidOp"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.TestVoidOp.Equals(OBeautifulCode.Type.TestVoidOp)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.TestVoidOp.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.TestVoidOp.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.TestVoidOp.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.TestVoidOp.DeepCloneWithDetails(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.TestVoidOp.Details" />.
            </summary>
            <param name="details">The new <see cref="P:OBeautifulCode.Type.TestVoidOp.Details" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.TestVoidOp" /> using the specified <paramref name="details" /> for <see cref="P:OBeautifulCode.Type.TestVoidOp.Details" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.TestVoidOp.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.TestVoidOp.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.NullVoidOp">
            <summary>
            Null object pattern implementation for <see cref="T:OBeautifulCode.Type.VoidOperationBase"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.NullVoidOp.op_Equality(OBeautifulCode.Type.NullVoidOp,OBeautifulCode.Type.NullVoidOp)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.NullVoidOp"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NullVoidOp.op_Inequality(OBeautifulCode.Type.NullVoidOp,OBeautifulCode.Type.NullVoidOp)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.NullVoidOp"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.NullVoidOp.Equals(OBeautifulCode.Type.NullVoidOp)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullVoidOp.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullVoidOp.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullVoidOp.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullVoidOp.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.NullVoidOp.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.OperationBase">
            <summary>
            Base implementation of <see cref="T:OBeautifulCode.Type.IOperation"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.OperationBase.op_Equality(OBeautifulCode.Type.OperationBase,OBeautifulCode.Type.OperationBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.OperationBase"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.OperationBase.op_Inequality(OBeautifulCode.Type.OperationBase,OBeautifulCode.Type.OperationBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.OperationBase"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.OperationBase.Equals(OBeautifulCode.Type.OperationBase)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.OperationBase.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.OperationBase.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.OperationBase.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.OperationBase.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.OperationBase.DeepCloneInternal">
            <summary>
            Creates a new object that is a deep clone of this instance.
            </summary>
            <returns>
            A new object that is a deep clone of this instance.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.OperationBase.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.ReturningOperationBase`1">
            <summary>
            Base implementation of <see cref="T:OBeautifulCode.Type.IReturningOperation`1"/>.
            </summary>
            <typeparam name="TResult">The type returned when the operation is executed.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.ReturningOperationBase`1.op_Equality(OBeautifulCode.Type.ReturningOperationBase{`0},OBeautifulCode.Type.ReturningOperationBase{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.ReturningOperationBase`1"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ReturningOperationBase`1.op_Inequality(OBeautifulCode.Type.ReturningOperationBase{`0},OBeautifulCode.Type.ReturningOperationBase{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.ReturningOperationBase`1"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.ReturningOperationBase`1.Equals(OBeautifulCode.Type.ReturningOperationBase{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ReturningOperationBase`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ReturningOperationBase`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ReturningOperationBase`1.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.ReturningOperationBase`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.VoidOperationBase">
            <summary>
            Base implementation of <see cref="T:OBeautifulCode.Type.IVoidOperation"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.VoidOperationBase.op_Equality(OBeautifulCode.Type.VoidOperationBase,OBeautifulCode.Type.VoidOperationBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.VoidOperationBase"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.VoidOperationBase.op_Inequality(OBeautifulCode.Type.VoidOperationBase,OBeautifulCode.Type.VoidOperationBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.VoidOperationBase"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.VoidOperationBase.Equals(OBeautifulCode.Type.VoidOperationBase)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.VoidOperationBase.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.VoidOperationBase.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.VoidOperationBase.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.VoidOperationBase.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.UtcDateTimeRangeInclusive">
            <summary>
            Represents a range of <see cref="T:System.DateTime"/>, inclusive of the endpoints.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.UtcDateTimeRangeInclusive.#ctor(System.DateTime,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.UtcDateTimeRangeInclusive"/> class.
            </summary>
            <param name="startDateTimeInUtc">The start of the range in UTC.</param>
            <param name="endDateTimeInUtc">The end of the range in UTC.</param>
            <exception cref="T:System.ArgumentException"><paramref name="startDateTimeInUtc"/> is not <see cref="F:System.DateTimeKind.Utc"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="endDateTimeInUtc"/> is not <see cref="F:System.DateTimeKind.Utc"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startDateTimeInUtc"/> is greater than <paramref name="endDateTimeInUtc"/>.</exception>
        </member>
        <member name="P:OBeautifulCode.Type.UtcDateTimeRangeInclusive.StartDateTimeInUtc">
            <summary>
            Gets the start of the range in UTC.  The range includes this endpoint.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Type.UtcDateTimeRangeInclusive.EndDateTimeInUtc">
            <summary>
            Gets the end of the range in UTC.  The range includes this endpoint.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.UtcDateTimeRangeInclusive.ToString">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareToStringMethod" />
        </member>
        <member name="M:OBeautifulCode.Type.UtcDateTimeRangeInclusive.op_Equality(OBeautifulCode.Type.UtcDateTimeRangeInclusive,OBeautifulCode.Type.UtcDateTimeRangeInclusive)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.UtcDateTimeRangeInclusive"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.UtcDateTimeRangeInclusive.op_Inequality(OBeautifulCode.Type.UtcDateTimeRangeInclusive,OBeautifulCode.Type.UtcDateTimeRangeInclusive)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.UtcDateTimeRangeInclusive"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.UtcDateTimeRangeInclusive.Equals(OBeautifulCode.Type.UtcDateTimeRangeInclusive)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.UtcDateTimeRangeInclusive.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.UtcDateTimeRangeInclusive.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.UtcDateTimeRangeInclusive.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.UtcDateTimeRangeInclusive.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.UtcDateTimeRangeInclusive.DeepCloneWithStartDateTimeInUtc(System.DateTime)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.UtcDateTimeRangeInclusive.StartDateTimeInUtc" />.
            </summary>
            <param name="startDateTimeInUtc">The new <see cref="P:OBeautifulCode.Type.UtcDateTimeRangeInclusive.StartDateTimeInUtc" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.UtcDateTimeRangeInclusive" /> using the specified <paramref name="startDateTimeInUtc" /> for <see cref="P:OBeautifulCode.Type.UtcDateTimeRangeInclusive.StartDateTimeInUtc" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.UtcDateTimeRangeInclusive.DeepCloneWithEndDateTimeInUtc(System.DateTime)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Type.UtcDateTimeRangeInclusive.EndDateTimeInUtc" />.
            </summary>
            <param name="endDateTimeInUtc">The new <see cref="P:OBeautifulCode.Type.UtcDateTimeRangeInclusive.EndDateTimeInUtc" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Type.UtcDateTimeRangeInclusive" /> using the specified <paramref name="endDateTimeInUtc" /> for <see cref="P:OBeautifulCode.Type.UtcDateTimeRangeInclusive.EndDateTimeInUtc" /> and a deep clone of every other property.</returns>
        </member>
        <member name="T:OBeautifulCode.Type.IDeclareToStringMethod">
            <summary>
            Declares the <see cref="M:OBeautifulCode.Type.IStringRepresentable.ToString"/> method.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString">
            <summary>
            Construct a friendly string representation of this object.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:OBeautifulCode.Type.IDeclareGetHashCodeMethod">
            <summary>
            Declares the <see cref="M:OBeautifulCode.Type.IHashable.GetHashCode"/> method.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.IDeclareGetHashCodeMethod.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="T:OBeautifulCode.Type.IDeclareEqualsMethod`1">
            <summary>
            Declares the <see cref="M:System.IEquatable`1.Equals(`0)"/> method.
            </summary>
            <typeparam name="T">The type of objects to compare for equality.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.IDeclareEqualsMethod`1.Equals(`0)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the other parameter; otherwise, false.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1">
            <summary>
            Declares the <see cref="M:OBeautifulCode.Type.IComparableForRelativeSortOrder`1.CompareToForRelativeSortOrder(`0)"/> method.
            </summary>
            <typeparam name="T">The type of the objects being compared.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1.CompareToForRelativeSortOrder(`0)">
            <summary>
            Compares the current instance with another object of the same type and
            returns a value that indicates whether the current instance precedes, follows,
            or occurs in the same position in the sort order as the other object.
            </summary>
            <param name="other">An object to compare with this instance.</param>
            <returns>
            A value that indicates the relative order of the objects being compared.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Type.IDeclareDeepCloneMethod`1">
            <summary>
            Declares the <see cref="M:OBeautifulCode.Type.IDeepCloneable`1.DeepClone"/> method.
            </summary>
            <typeparam name="T">The type of object to clone.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.IDeclareDeepCloneMethod`1.DeepClone">
            <summary>
            Creates a new object that is a deep clone of this instance.
            </summary>
            <returns>
            A new object that is a deep clone of this instance.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Type.EncodingExtensions">
            <summary>
            Extension methods related to <see cref="T:System.Text.Encoding"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.EncodingExtensions.ToEncoding(OBeautifulCode.Type.EncodingKind)">
            <summary>
            Converts an <see cref="T:OBeautifulCode.Type.EncodingKind"/> to an <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="encodingKind">The encoding kind.</param>
            <returns>
            The <see cref="T:System.Text.Encoding"/> corresponding to the specified <see cref="T:OBeautifulCode.Type.EncodingKind"/>.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.EncodingExtensions.ToEncodingKind(System.Text.Encoding)">
            <summary>
            Converts an <see cref="T:System.Text.Encoding"/> to an <see cref="T:OBeautifulCode.Type.EncodingKind"/>.
            </summary>
            <param name="encoding">The encoding.</param>
            <returns>
            The <see cref="T:OBeautifulCode.Type.EncodingKind"/> corresponding to the specified <see cref="T:System.Text.Encoding"/>.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Type.EncodingKind">
            <summary>
            Specifies the kind of encoding.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.EncodingKind.Ascii">
            <summary>
            Encoding for the ASCII (7-bit) character set.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.EncodingKind.Utf7">
            <summary>
            The encoding for the UTF-7 format.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.EncodingKind.Utf8">
            <summary>
            The encoding for the UTF-8 encoding.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.EncodingKind.Utf16LittleEndian">
            <summary>
            The encoding for the UTF-16 format using the little endian byte order.
            </summary>
            <remarks>
            This is also called 'Unicode' and 'UCS-2 little endian'.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Type.EncodingKind.Utf16BigEndian">
            <summary>
            The encoding for the UTF-16 format using the big endian byte order.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.EncodingKind.Utf32LittleEndian">
            <summary>
            The encoding for the UTF-16 format using the little endian byte order.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.EncodingKind.Utf32BigEndian">
            <summary>
            The encoding for the UTF-16 format using the big endian byte order.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.EncodingKind.WesternEuropeanIso">
            <summary>
            The encoding for the Western European (ISO-8559-1) format.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.RelativeSortOrder">
            <summary>
            The relative order of two objects being compared.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.RelativeSortOrder.ThisInstancePrecedesTheOtherInstance">
            <summary>
            This instance precedes the other instance in the sort order.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.RelativeSortOrder.ThisInstanceOccursInTheSamePositionAsTheOtherInstance">
            <summary>
            This instance occurs in the same position in the sort order as the other instance.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.RelativeSortOrder.ThisInstanceFollowsTheOtherInstance">
            <summary>
            This instance follows the other instance in the sort order.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IComparableForRelativeSortOrder`1">
            <summary>
            Defines a generalized comparison method that a value type or class implements
            to create a type-specific comparison method for ordering or sorting its instances.
            </summary>
            <typeparam name="T">The type of the objects being compared.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.IComparableForRelativeSortOrder`1.CompareToForRelativeSortOrder(`0)">
            <summary>
            Compares the current instance with another object of the same type and
            returns a value that indicates whether the current instance precedes, follows,
            or occurs in the same position in the sort order as the other object.
            </summary>
            <param name="other">An object to compare with this instance.</param>
            <returns>
            A value that indicates the relative order of the objects being compared.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Type.IHaveIntId">
            <summary>
            Represents an object that has a <see cref="T:System.Int32"/> unique identifier.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IHaveId`1">
            <summary>
            Represents an object that has a unique identifier.
            </summary>
            <typeparam name="T">The type of the unique identifier.</typeparam>
        </member>
        <member name="P:OBeautifulCode.Type.IHaveId`1.Id">
            <summary>
            Gets the unique identifier.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IObject">
            <summary>
            An interface alternative to <see cref="T:System.Object"/>.
            Enables a method (typically a constructor) to take-in an object of any type.
            </summary>
            <remarks>
            This is particularly useful in providing a facility for a caller to construct
            your object with their domain-specific context and then serialize your object.
            Serializing an object having a property of type <see cref="T:System.Object"/> can
            break some serializers.
            </remarks>
        </member>
        <member name="T:OBeautifulCode.Type.IHashable">
            <summary>
            Creates a hash code for an instance of the object.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.IHashable.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="T:OBeautifulCode.Type.IHaveTimestampUtc">
            <summary>
            Represents an object that is timestamped in UTC.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Type.IHaveTimestampUtc.TimestampUtc">
            <summary>
            Gets the timestamp in UTC.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IHaveTags">
            <summary>
            Represents an object that can be tagged using named strings.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Type.IHaveTags.Tags">
            <summary>
            Gets the tags as named strings.
            </summary>
            <remarks>
            null is valid value.
            If the tags have a single dimension/no grouping concept,
            then they can be specified as the names with null values.
            </remarks>
        </member>
        <member name="T:OBeautifulCode.Type.IImplementNullObjectPattern">
            <summary>
            Interface to express usage of the Null Object Pattern (like an empty implementation of the contract it honors).
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IStringRepresentable">
            <summary>
            Creates a string representation of an instance of the object.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.IStringRepresentable.ToString">
            <summary>
            Construct a friendly string representation of this object.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:OBeautifulCode.Type.IHaveGuidId">
            <summary>
            Represents an object that has a <see cref="T:System.Guid"/> unique identifier.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IHaveStringId">
            <summary>
            Represents an object that has a <see cref="T:System.String"/> unique identifier.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IHaveId">
            <summary>
            Represents an object that has a unique identifier.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.FakeModel`1">
            <summary>
            This class is used to "model-ize" a type that cannot easily implement <see cref="T:OBeautifulCode.Type.IModel`1"/>.
            </summary>
            <remarks>
            This is used to satisfy the compiler when a model type is required, but the type in question
            cannot easily be made into a model and there is no intention of using any of the model "features".
            </remarks>
            <typeparam name="T">The type to model-ize.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.FakeModel`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Type.FakeModel`1"/> class.
            </summary>
            <param name="value">The value to wrap.</param>
        </member>
        <member name="P:OBeautifulCode.Type.FakeModel`1.Value">
            <summary>
            Gets the wrapped value.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.FakeModel`1.op_Equality(OBeautifulCode.Type.FakeModel{`0},OBeautifulCode.Type.FakeModel{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.FakeModel`1"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.FakeModel`1.op_Inequality(OBeautifulCode.Type.FakeModel{`0},OBeautifulCode.Type.FakeModel{`0})">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Type.FakeModel`1"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Type.FakeModel`1.Equals(OBeautifulCode.Type.FakeModel{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.FakeModel`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.FakeModel`1.GetHashCode">
            <inheritdoc cref="T:OBeautifulCode.Type.IHashable" />
        </member>
        <member name="M:OBeautifulCode.Type.FakeModel`1.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.FakeModel`1.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Type.FakeModel`1.ToString">
            <inheritdoc cref="T:OBeautifulCode.Type.IStringRepresentable" />
        </member>
        <member name="T:OBeautifulCode.Type.IModel">
            <summary>
            Represents the contract of a model object.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IModel`1">
            <summary>
            Represents the contract of a model object.
            </summary>
            <typeparam name="T">The type of object being modeled.</typeparam>
        </member>
        <member name="T:OBeautifulCode.Type.IDeepCloneable`1">
            <summary>
            Supports deep cloning, which creates a new instance of a class that is equal to
            a reference instance, but where the two instances do not share any memory between
            their full object graphs.
            </summary>
            <typeparam name="T">The type of object to clone.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.IDeepCloneable`1.DeepClone">
            <summary>
            Creates a new object that is a deep clone of this instance.
            </summary>
            <returns>
            A new object that is a deep clone of this instance.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Type.IShallowCloneable`1">
            <summary>
            Supports shallow cloning, which creates a new instance of a class that is equal to
            a reference instance, but where the two instances share memory somewhere in their
            object graphs.
            </summary>
            <typeparam name="T">The type of object to clone.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Type.IShallowCloneable`1.ShallowClone">
            <summary>
            Creates a new object that is a shallow clone of this instance.
            </summary>
            <returns>
            A new object that is a shallow clone of this instance.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Type.ProjectInfo">
            <summary>
            Project-related information.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.ProjectInfo.Namespace">
            <summary>
            The namespace used by types in this project.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.ProjectInfo.Assembly">
            <summary>
            The assembly produced by this project.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IComparableViaCodeGen">
            <summary>
            Represents an object that is expected to be an
            <see cref="T:OBeautifulCode.Type.IComparableForRelativeSortOrder`1"/> that is implemented with generated code.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IForsakeDeepCloneWithVariantsViaCodeGen">
            <summary>
            Used on a type to indicate that all DeepCloneWith method variants (one per model property) should be forsaken (don't generate code).
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IHashableViaCodeGen">
            <summary>
            Represents an object that is expected to be an
            <see cref="T:OBeautifulCode.Type.IHashable"/> that is implemented with generated code.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IForsakeInheritedModelViaCodeGen">
            <summary>
            Used on a type to indicate that an inherited <see cref="T:OBeautifulCode.Type.IModelViaCodeGen"/> should be forsaken (don't generate code).
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IStringRepresentableViaCodeGen">
            <summary>
            Represents an object that is expected to be an
            <see cref="T:OBeautifulCode.Type.IStringRepresentable"/> that is implemented with generated code.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IEquatableViaCodeGen">
            <summary>
            Represents an object that is expected to be an
            <see cref="T:System.IEquatable`1"/> that is implemented with generated code.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IDeepCloneableViaCodeGen">
            <summary>
            Represents an object that is expected to be an
            <see cref="T:OBeautifulCode.Type.IDeepCloneable`1"/> that is implemented with generated code.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.IModelViaCodeGen">
            <summary>
            Represents an object that is expected to be an
            <see cref="T:OBeautifulCode.Type.IModel`1"/> that is implemented with generated code.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Cloning.Recipes.CloningExtensions">
            <summary>
            Extension methods to clone objects of various types.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone``1(``0)">
            <summary>
            Deep clones an arbitrary value.
            </summary>
            <typeparam name="T">The type of the value to deep clone.</typeparam>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.  If value is null, returns null.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.String)">
            <summary>
            Deep clones a <see cref="T:System.String"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.Version)">
            <summary>
            Deep clones a <see cref="T:System.Version"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.Uri)">
            <summary>
            Deep clones a <see cref="T:System.Uri"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause">
            <summary>
            Standard justifications for analysis suppression.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_SeeOtherSuppressionMessages">
            <summary>
            See the other suppression message(s) applied within the same context.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_AgreeWithAssessmentAndNeedsRefactoring">
            <summary>
            We agree with the assessment.  This code needs refactoring but we cannot justify spending time on this right now.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_NatureOfTypeNecessitatesIgnoringAllWarnings">
            <summary>
            The nature of this type necessitates that we ignore all warnings.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_NotApplicable">
            <summary>
            This warning detects a situation that is not applicable to this code.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1000_DoNotDeclareStaticMembersOnGenericTypes_StaticPropertyReturnsInstanceOfContainingGenericClassAndIsConvenientAndMostDiscoverableWhereDeclared">
            <summary>
            A static property returns an instance of the generic class that contains the property.  The property exists for convenience in creating and configuring the instance.  It is most discoverable where it is, in-context of the class being instantiated.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1002_DoNotExposeGenericLists_GenericListRequiredForTesting">
            <summary>
            A generic list is required in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1004_GenericMethodsShouldProvideTypeParameter_OnlyInputsToMethodAreTypesAndItsMoreConciseToCallMethodUseGenericTypeParameters">
            <summary>
            The only input(s) to the method are Types.  It's more concise to call the method using generic types parameters instead of a parameter signature with parameters of type Type (e.g. MyMethod&lt;MyType&gt;() instead of MyMethod(Type myType)).
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1005_AvoidExcessiveParametersOnGenericTypes_SpecifiedParametersRequiredForNeededFunctionality">
            <summary>
            The specified paramters are required to achieve the needed functionality.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1014_MarkAssembliesWithClsCompliant_ConsoleExeDoesNotNeedToBeClsCompliant">
            <summary>
            Console executable does not need the [assembly: CLSCompliant(true)] as it should not be shared as an assembly for reference.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1020_AvoidNamespacesWithFewTypes_OptimizeForLogicalGroupingOfTypes">
            <summary>
            We are optimizing for the logical grouping of types rather than the number of types in a namepace.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1021_AvoidOutParameters_OutParameterRequiredForTryMethod">
            <summary>
            An out parameter is required for a Try...() method that attempts to perform some operation, returning true when successful and setting the out parameter to the result of the operation or returning false and leaving the out parameter uninitialized (e.g. dictionary.TryGetValue(key, int out result) ).
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1027_MarkEnumsWithFlags_EnumValuesArePurposefullyNonContiguous">
            <summary>
            This is not a flags enum.  Enum values are purposefully non-contiguous.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1032_ImplementStandardExceptionConstructors_ExceptionUsedInternallyAndConstructorsEnsureRequiredInfoAvailableWhenCaught">
            <summary>
            This Exception is only used internally and the constructor(s) ensure that when the Exception is caught, it contains the required information.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1034_NestedTypesShouldNotBeVisible_VisibleNestedTypeRequiredForTesting">
            <summary>
            A visible nested type is required in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1036_OverrideMethodsOnComparableTypes_TypeCreatedForTestsThatRequireComparableTypeButDoNotUseTypeToPerformComparisons">
            <summary>
            The type exists for unit tests that require a comparable type, but do not use the type to perform any comparisons.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1040_AvoidEmptyInterfaces_NeedToIdentifyGroupOfTypesAndPreferInterfaceOverAttribute">
            <summary>
            When we need to identify a group of types, we prefer the use of an empty interface over an attribute because it's easier to use and results in cleaner code.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1051_DoNotDeclareVisibleInstanceFields_TypeUsedInTestingThatRequiresInstanceFieldToBeVisible">
            <summary>
            The type is used for test code that requires the instance field to be visible.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1054_UriParametersShouldNotBeStrings_PreferToRepresentUrlAsString">
            <summary>
            In this case we prefer to represent the URL as a string.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1056_UriPropertiesShouldNotBeStrings_PreferToRepresentUrlAsString">
            <summary>
            In this case we prefer to represent the URL as a string.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1065_DoNotRaiseExceptionsInUnexpectedLocations_ThrowNotSupportedExceptionForUnreachableCodePath">
            <summary>
            It's ok to throw NotSupportedException for an unreachable code path.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1065_DoNotRaiseExceptionsInUnexpectedLocations_ThrowNotImplementedExceptionWhenForcedToSpecifyMemberThatWillNeverBeUsedInTesting">
            <summary>
            It's ok to throw NotImplementedException when a base type or implementing an interface forces us to create a member that will never be used in testing.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1308_NormalizeStringsToUppercase_PreferGuidLowercase">
            <summary>
            We prefer to read <see cref="T:System.Guid" />'s string representation as lowercase.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1502_AvoidExcessiveComplexity_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment that this method as excessively complex.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1505_AvoidUnmaintainableCode_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment that this code is unmaintainable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1506_AvoidExcessiveClassCoupling_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment this type or method is excessively coupled.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1702_CompoundWordsShouldBeCasedCorrectly_AnalyzerIsIncorrectlyDetectingCompoundWords">
            <summary>
            The analyzer is incorrectly detecting compound words.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1704_IdentifiersShouldBeSpelledCorrectly_SpellingIsCorrectInContextOfTheDomain">
            <summary>
            The spelling of the identifier is correct in-context of the domain.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1709_IdentifiersShouldBeCasedCorrectly_CasingIsAsPreferred">
            <summary>
            The casing is as preferred.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1710_IdentifiersShouldHaveCorrectSuffix_ExceptionBaseClassShouldEndWithBase">
            <summary>
            An Exception base class should end in 'Base' (as is the convention for all base classes), not 'Exception'.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1710_IdentifiersShouldHaveCorrectSuffix_NameDirectlyExtendedOrImplementedTypeAddedAsSuffixForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier is suffixed with the name of the Type that it directly extends or implements to improves readability and comprehension of unit tests whre the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1711_IdentifiersShouldNotHaveIncorrectSuffix_TypeNameAddedAsSuffixForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier is suffixed with it's Type name to improve readability and comprehension of unit tests where the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1714_FlagsEnumsShouldHavePluralNames_TheNameIsPlural">
            <summary>
            The name is plural.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndNoGoodAlternative">
            <summary>
            The type name adds clarity to the identifier and there is no good alternative.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity">
            <summary>
            The type name adds clarity to the identifier and the alternatives degrade the clarity of the identifier.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddedToIdentifierForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier includes it's Type name to improve readability and comprehension of unit tests where the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1726_UsePreferredTerms_FlagsAddedForTestsWhereEnumKindIsPrimaryConcern">
            <summary>
            The identifier includes 'Flags' to improve readability and comprehension of unit tests where the kind of Enum is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags">
            <summary>
            The name of the Type of the identifier uses the term 'Flags' and so it's appropriate to use that term in the the name of the identifier.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1804_RemoveUnusedLocals_UsedAsWorkaroundForConditionalBreakpointThatCannotBeSet">
            <summary>
            In some cases, the debugger raises an error because it cannot set a conditional breakpoint.  A local is introduced to simplify the evaluation of the breakpoint's condition.  It's only purpose is to allow a conditional breakpoint in proximity of the breakpoint that cannot be set.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1810_InitializeReferenceTypeStaticFieldsInline_FieldsDeclaredInCodeGeneratedPartialTestClass">
            <summary>
            The static field(s) are declared in a code generated partial test class that should not be alterated.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1811_AvoidUncalledPrivateCode_MethodIsWiredIntoClapAsVerb">
            <summary>
            The method is wired into CLAP, a framework for command-line parsing, as a verb.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1811_AvoidUncalledPrivateCode_PropertyExistsForCompleteness">
            <summary>
            The property exists for completeness.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_ClassIsWiredIntoClapInProgramCs">
            <summary>
            The class is wired into CLAP, a framework for command-line parsing, in Program.cs.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_SerializationConfigurationClassInstantedBySerializer">
            <summary>
            The class derives from SerializationConfigurationBase and is instantiated by a Serializer that is configured using the type of that class.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_ClassExistsToUseItsTypeInUnitTests">
            <summary>
            The class exists because it's Type is used in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1815_OverrideEqualsAndOperatorEqualsOnValueTypes_TypeUsedForTestsThatRequireTypeToNotBeEquatable">
            <summary>
            The type is being used in testing and we explicitly do not want the type to be equatable because it has bearing on the tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1819_PropertiesShouldNotReturnArrays_DataPayloadsAreCommonlyRepresentedAsByteArrays">
            <summary>
            Data payloads are commonly represented as a byte arrays.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1819_PropertiesShouldNotReturnArrays_ArrayPropertyRequiredForTesting">
            <summary>
            An array property is required for unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2000_DisposeObjectsBeforeLosingScope_DisposableObjectIsMethodReturnObject">
            <summary>
            The disposable object is the method's return object.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2000_DisposeObjectsBeforeLosingScope_MethodCreatesDisposableObjectButItCannotBeDisposedBecauseReturnObjectRequiresDisposableObjectToBeFullyIntact">
            <summary>
            The method creates a dispoable object, but it cannot be disposed because the return object requires the disposable object to be fully intact.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2104_DoNotDeclareReadOnlyMutableReferenceTypes_TypeIsImmutable">
            <summary>
            The type is immutable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2201_DoNotRaiseReservedExceptionTypes_UsedForUnitTesting">
            <summary>
            The reserved exception is being used in unit test code; there is no real caller that will be impacted.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2202_DoNotDisposeObjectsMultipleTimes_AnalyzerIsIncorrectlyFlaggingObjectAsBeingDisposedMultipleTimes">
            <summary>
            The analyzer is incorectly flagging an object as being disposed multiple times.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2214_DoNotCallOverridableMethodsInConstructors_OverriddenMethodDoesNotRelyOnInitializationNorOtherConfigurationInConstructor">
            <summary>
            The overridden method does not relies on initialization nor other configuration in the constructor.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2227_CollectionPropertiesShouldBeReadOnly_PublicInterfaceNeverExposesTheObject">
            <summary>
            The public interface of the system associated with this object never exposes this object.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2227_CollectionPropertiesShouldBeReadOnly_SetterIsRequiredForTesting">
            <summary>
            A setter is required for unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2237_MarkISerializableTypesWithSerializable_UsedForTestingWithNoIntentionToSerialize">
            <summary>
            The type is used in unit tests with no intention to serialize.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2237_MarkISerializableTypesWithSerializable_ExceptionOnlyUsedInternallyAndWillNeverBeSerialized">
            <summary>
            The Exception is only used internally; it will never be serialized.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer">
            <summary>
            Compares two byte arrays for equality.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer.Equals(System.Byte[],System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer.GetHashCode(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer">
            <summary>
            Compares two <see cref="T:System.DateTime"/>, fixing .NET's default implementation where two objects
            having the same <see cref="P:System.DateTime.Ticks"/> but different <see cref="P:System.DateTime.Kind"/> are
            considered equal.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer.Equals(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer.GetHashCode(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of dictionary keys.</typeparam>
            <typeparam name="TValue">The type of dictionary values.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2.Equals(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2.GetHashCode(System.Collections.Generic.IDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/14675741/356790" />.
            </remarks>
            <typeparam name="T">The type of objects to enumerate.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.#ctor(OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1"/> class.
            </summary>
            <param name="enumerableEqualityComparerStrategy">The strategy to use when comparing two <see cref="T:System.Collections.Generic.IEnumerable`1"/> for equality.</param>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.Equals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy">
            <summary>
            Determines the strategy to use when comparing two <see cref="T:System.Collections.Generic.IEnumerable`1"/> for equality.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy.SequenceEqual">
            <summary>
            Use <see cref="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsSequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy.UnorderedEqual">
            <summary>
            Use <see cref="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsUnorderedEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EqualityComparerHelper">
            <summary>
            Helper methods related to <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets the equality comparer to use for the specified type.
            </summary>
            <typeparam name="T">The type of the objects being compared.</typeparam>
            <param name="comparer">Optional comparer passed into the calling method.  Default is null, which instructs this method to determine the comparer.  If not null, then the specified comparer is returned.</param>
            <returns>
            The equality comparer to use for the specified type.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EqualityExtensions">
            <summary>
            Extension methods that test for equality between two objects.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsEqualTo``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares objects for equality.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
            <param name="item1">The first object to compare.</param>
            <param name="item2">The second object to compare.</param>
            <param name="comparer">Optional equality comparer to use to compare the objects.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two objects are equal
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsDictionaryEqualTo``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionaries.</typeparam>
            <typeparam name="TValue">The type of values in the dictionaries.</typeparam>
            <param name="item1">The first <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="item2">The second <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="valueComparer">Optional equality comparer to use to compare values.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source dictionaries are null.
            - false if one or the other is null.
            - false if the dictionaries are of different length.
            - true if the two dictionaries are of equal length and their values are equal for the same keys.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsReadOnlyDictionaryEqualTo``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionaries.</typeparam>
            <typeparam name="TValue">The type of values in the dictionaries.</typeparam>
            <param name="item1">The first <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="item2">The second <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="valueComparer">Optional equality comparer to use to compare values.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source dictionaries are null.
            - false if one or the other is null.
            - false if the dictionaries are of different length.
            - true if the two dictionaries are of equal length and their values are equal for the same keys.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsSequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TElement">The type of the elements of the input sequences.</typeparam>
            <param name="item1">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to <paramref name="item2"/>.</param>
            <param name="item2">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to the first sequence.</param>
            <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source sequences are null.
            - false if one or the other is null.
            - true if the two sequences are of equal length and their corresponding elements are equal according to <paramref name="elementComparer"/>.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsUnorderedEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if two enumerables have the exact same elements in any order.
            Every unique element in the first set has to appear in the second set the same number of times it appears in the first.
            </summary>
            <typeparam name="TElement">The type of the elements of the input sequences.</typeparam>
            <param name="item1">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to <paramref name="item2"/>.</param>
            <param name="item2">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to the first sequence.</param>
            <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source sequences are null.
            - false if one or the other is null.
            - false if there is any symmetric difference.
            - true if the two sequences both contain the same number of elements for each unique element.
            - otherwise, false.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.HashCodeHelper">
            <summary>
            Provides methods to help with generating hash codes for structures and classes. This handles
            value types, nullable type, and objects.
            </summary>
            <remarks>
            Adapted from NodaTime: <a href="https://github.com/nodatime/nodatime/blob/master/src/NodaTime/Utility/HashCodeHelper.cs"/>.
            The basic usage pattern is as follows.
            <example>
            <code>
             public override int GetHashCode() => HashCodeHelper.Initialize().Hash(Field1).Hash(Field2).Hash(Field3).Value;
            </code>
            </example>
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.HashCodeHelper.HashCodeMultiplier">
            <summary>
            The multiplier for each value.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.HashCodeHelper.HashCodeInitializer">
            <summary>
            The initial hash value.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> class.
            </summary>
            <param name="value">The hash code value.</param>
        </member>
        <member name="P:OBeautifulCode.Equality.Recipes.HashCodeHelper.Value">
            <summary>
            Gets the hash code value.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Initialize">
            <summary>
            Returns the initial value for a hash code.
            </summary>
            <returns>The initial integer wrapped in a <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> value.</returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Initialize(System.Int32)">
            <summary>
            Returns the initial value for a hash code.
            </summary>
            <param name="seedValue">Seed value to initialize with (often the hash code from a base class using it's base properties).</param>
            <returns>The initial integer wrapped in a <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> value.</returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Hash``1(``0)">
            <summary>
            Adds the hash code for the given item to the current hash code and returns the new hash code.
            </summary>
            <typeparam name="T">The type of the item being hashed.</typeparam>
            <param name="item">The item to hash.</param>
            <returns>The new hash code.</returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1">
            <summary>
            An equality comparer backed by a lambda.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1"/> class.
            </summary>
            <param name="equalsFunc">The function to use to determine whether two objects of type <typeparamref name="T"/> are equal.</param>
            <param name="getHashCodeFunc">OPTIONAL function to get the hash code for an object of type <typeparamref name="T"/> in context of this equality comparer.  DEFAULT is to have <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"/> throw <see cref="T:System.NotSupportedException"/>.</param>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.NativeMethods">
            <summary>
            P/invoke method.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NativeMethods.memcmp(System.Byte[],System.Byte[],System.Int64)">
            <summary>
            Compares two byte arrays.
            </summary>
            <param name="b1">The first byte array.</param>
            <param name="b2">The second byte array.</param>
            <param name="count">The length of the bytes.</param>
            <returns>
            0 if the byte arrays are equal.
            Less than 0 if the first byte array is less than the second byte array.
            Greater than 0 if the first byte array is greater than the second byte array.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer">
            <summary>
            Compares two <see cref="T:System.Nullable`1"/>, fixing .NET's default implementation where two objects
            having the same <see cref="P:System.DateTime.Ticks"/> but different <see cref="P:System.DateTime.Kind"/> are
            considered equal.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer.Equals(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer.GetHashCode(System.Nullable{System.DateTime})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer">
            <summary>
            Compares two objects equality.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer.Equals(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer.GetHashCode(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of dictionary keys.</typeparam>
            <typeparam name="TValue">The type of dictionary values.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2.Equals(System.Collections.Generic.IReadOnlyDictionary{`0,`1},System.Collections.Generic.IReadOnlyDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2.GetHashCode(System.Collections.Generic.IReadOnlyDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Execution.Recipes.TaskExtensions">
            <summary>
            Extension methods on <see cref="T:System.Threading.Tasks.Task"/>.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Execution.Recipes.TaskExtensions.DefaultPollingInterval">
            <summary>
            Default <see cref="T:System.TimeSpan" /> to wait before re-checking <see cref="P:System.Threading.Tasks.Task.Status" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Execution.Recipes.TaskExtensions.RunUntilCompletion(System.Threading.Tasks.Task,System.TimeSpan,OBeautifulCode.Execution.Recipes.TaskWaitingStrategy)">
            <summary>
            Blocks on a task execution until it's in a <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /> status, will start the task if in <see cref="F:System.Threading.Tasks.TaskStatus.Created" />.
            </summary>
            <param name="task">Task to wait on.</param>
            <param name="pollingInterval">OPTIONAL time to poll and check status of task; DEFAULT is <see cref="F:OBeautifulCode.Execution.Recipes.TaskExtensions.DefaultPollingInterval" />.</param>
            <param name="taskWaitingStrategy">OPTIONAL strategy on how to wait; DEFAULT is <see cref="F:OBeautifulCode.Execution.Recipes.TaskWaitingStrategy.Sleep" />.</param>
        </member>
        <member name="M:OBeautifulCode.Execution.Recipes.TaskExtensions.RunUntilCompletion``1(System.Threading.Tasks.Task{``0},System.TimeSpan,OBeautifulCode.Execution.Recipes.TaskWaitingStrategy)">
            <summary>
            Blocks on a task execution until it's in a <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /> status, will start the task if in <see cref="F:System.Threading.Tasks.TaskStatus.Created" />.
            </summary>
            <typeparam name="T">The type of the return value of the specified task.</typeparam>
            <param name="task">Task to wait on.</param>
            <param name="pollingInterval">OPTIONAL time to poll and check status of task; DEFAULT is <see cref="F:OBeautifulCode.Execution.Recipes.TaskExtensions.DefaultPollingInterval" />.</param>
            <param name="taskWaitingStrategy">OPTIONAL strategy on how to wait; DEFAULT is <see cref="F:OBeautifulCode.Execution.Recipes.TaskWaitingStrategy.Sleep" />.</param>
            <returns>
            Return value of specified task.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Execution.Recipes.TaskWaitingStrategy">
            <summary>
            Strategy on how to wait until a <see cref="T:System.Threading.Tasks.Task" /> is complete.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Execution.Recipes.TaskWaitingStrategy.Sleep">
            <summary>
            <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)" /> while waiting.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Execution.Recipes.TaskWaitingStrategy.YieldAndSleep">
            <summary>
            <see cref="M:System.Threading.Thread.Yield" /> followed by a <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)" /> while waiting.
            </summary>
        </member>
    </members>
</doc>
