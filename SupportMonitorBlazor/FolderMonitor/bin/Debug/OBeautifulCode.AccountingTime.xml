<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OBeautifulCode.AccountingTime</name>
    </assembly>
    <members>
        <member name="T:OBeautifulCode.Cloning.Recipes.CloningExtensions">
            <summary>
            Extension methods to clone objects of various types.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone``1(``0)">
            <summary>
            Deep clones an arbitrary value.
            </summary>
            <typeparam name="T">The type of the value to deep clone.</typeparam>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.  If value is null, returns null.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.String)">
            <summary>
            Deep clones a <see cref="T:System.String"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.Version)">
            <summary>
            Deep clones a <see cref="T:System.Version"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.Uri)">
            <summary>
            Deep clones a <see cref="T:System.Uri"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause">
            <summary>
            Standard justifications for analysis suppression.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_SeeOtherSuppressionMessages">
            <summary>
            See the other suppression message(s) applied within the same context.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_AgreeWithAssessmentAndNeedsRefactoring">
            <summary>
            We agree with the assessment.  This code needs refactoring but we cannot justify spending time on this right now.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_NatureOfTypeNecessitatesIgnoringAllWarnings">
            <summary>
            The nature of this type necessitates that we ignore all warnings.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_NotApplicable">
            <summary>
            This warning detects a situation that is not applicable to this code.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1000_DoNotDeclareStaticMembersOnGenericTypes_StaticPropertyReturnsInstanceOfContainingGenericClassAndIsConvenientAndMostDiscoverableWhereDeclared">
            <summary>
            A static property returns an instance of the generic class that contains the property.  The property exists for convenience in creating and configuring the instance.  It is most discoverable where it is, in-context of the class being instantiated.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1002_DoNotExposeGenericLists_GenericListRequiredForTesting">
            <summary>
            A generic list is required in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1004_GenericMethodsShouldProvideTypeParameter_OnlyInputsToMethodAreTypesAndItsMoreConciseToCallMethodUseGenericTypeParameters">
            <summary>
            The only input(s) to the method are Types.  It's more concise to call the method using generic types parameters instead of a parameter signature with parameters of type Type (e.g. MyMethod&lt;MyType&gt;() instead of MyMethod(Type myType)).
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1005_AvoidExcessiveParametersOnGenericTypes_SpecifiedParametersRequiredForNeededFunctionality">
            <summary>
            The specified paramters are required to achieve the needed functionality.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1014_MarkAssembliesWithClsCompliant_ConsoleExeDoesNotNeedToBeClsCompliant">
            <summary>
            Console executable does not need the [assembly: CLSCompliant(true)] as it should not be shared as an assembly for reference.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1020_AvoidNamespacesWithFewTypes_OptimizeForLogicalGroupingOfTypes">
            <summary>
            We are optimizing for the logical grouping of types rather than the number of types in a namepace.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1021_AvoidOutParameters_OutParameterRequiredForTryMethod">
            <summary>
            An out parameter is required for a Try...() method that attempts to perform some operation, returning true when successful and setting the out parameter to the result of the operation or returning false and leaving the out parameter uninitialized (e.g. dictionary.TryGetValue(key, int out result) ).
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1027_MarkEnumsWithFlags_EnumValuesArePurposefullyNonContiguous">
            <summary>
            This is not a flags enum.  Enum values are purposefully non-contiguous.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1032_ImplementStandardExceptionConstructors_ExceptionUsedInternallyAndConstructorsEnsureRequiredInfoAvailableWhenCaught">
            <summary>
            This Exception is only used internally and the constructor(s) ensure that when the Exception is caught, it contains the required information.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1034_NestedTypesShouldNotBeVisible_VisibleNestedTypeRequiredForTesting">
            <summary>
            A visible nested type is required in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1036_OverrideMethodsOnComparableTypes_TypeCreatedForTestsThatRequireComparableTypeButDoNotUseTypeToPerformComparisons">
            <summary>
            The type exists for unit tests that require a comparable type, but do not use the type to perform any comparisons.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1040_AvoidEmptyInterfaces_NeedToIdentifyGroupOfTypesAndPreferInterfaceOverAttribute">
            <summary>
            When we need to identify a group of types, we prefer the use of an empty interface over an attribute because it's easier to use and results in cleaner code.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1051_DoNotDeclareVisibleInstanceFields_TypeUsedInTestingThatRequiresInstanceFieldToBeVisible">
            <summary>
            The type is used for test code that requires the instance field to be visible.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1054_UriParametersShouldNotBeStrings_PreferToRepresentUrlAsString">
            <summary>
            In this case we prefer to represent the URL as a string.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1056_UriPropertiesShouldNotBeStrings_PreferToRepresentUrlAsString">
            <summary>
            In this case we prefer to represent the URL as a string.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1065_DoNotRaiseExceptionsInUnexpectedLocations_ThrowNotSupportedExceptionForUnreachableCodePath">
            <summary>
            It's ok to throw NotSupportedException for an unreachable code path.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1065_DoNotRaiseExceptionsInUnexpectedLocations_ThrowNotImplementedExceptionWhenForcedToSpecifyMemberThatWillNeverBeUsedInTesting">
            <summary>
            It's ok to throw NotImplementedException when a base type or implementing an interface forces us to create a member that will never be used in testing.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1308_NormalizeStringsToUppercase_PreferGuidLowercase">
            <summary>
            We prefer to read <see cref="T:System.Guid" />'s string representation as lowercase.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1502_AvoidExcessiveComplexity_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment that this method as excessively complex.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1505_AvoidUnmaintainableCode_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment that this code is unmaintainable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1506_AvoidExcessiveClassCoupling_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment this type or method is excessively coupled.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1702_CompoundWordsShouldBeCasedCorrectly_AnalyzerIsIncorrectlyDetectingCompoundWords">
            <summary>
            The analyzer is incorrectly detecting compound words.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1704_IdentifiersShouldBeSpelledCorrectly_SpellingIsCorrectInContextOfTheDomain">
            <summary>
            The spelling of the identifier is correct in-context of the domain.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1709_IdentifiersShouldBeCasedCorrectly_CasingIsAsPreferred">
            <summary>
            The casing is as preferred.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1710_IdentifiersShouldHaveCorrectSuffix_ExceptionBaseClassShouldEndWithBase">
            <summary>
            An Exception base class should end in 'Base' (as is the convention for all base classes), not 'Exception'.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1710_IdentifiersShouldHaveCorrectSuffix_NameDirectlyExtendedOrImplementedTypeAddedAsSuffixForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier is suffixed with the name of the Type that it directly extends or implements to improves readability and comprehension of unit tests whre the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1711_IdentifiersShouldNotHaveIncorrectSuffix_TypeNameAddedAsSuffixForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier is suffixed with it's Type name to improve readability and comprehension of unit tests where the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1714_FlagsEnumsShouldHavePluralNames_TheNameIsPlural">
            <summary>
            The name is plural.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndNoGoodAlternative">
            <summary>
            The type name adds clarity to the identifier and there is no good alternative.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity">
            <summary>
            The type name adds clarity to the identifier and the alternatives degrade the clarity of the identifier.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddedToIdentifierForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier includes it's Type name to improve readability and comprehension of unit tests where the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1726_UsePreferredTerms_FlagsAddedForTestsWhereEnumKindIsPrimaryConcern">
            <summary>
            The identifier includes 'Flags' to improve readability and comprehension of unit tests where the kind of Enum is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags">
            <summary>
            The name of the Type of the identifier uses the term 'Flags' and so it's appropriate to use that term in the the name of the identifier.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1804_RemoveUnusedLocals_UsedAsWorkaroundForConditionalBreakpointThatCannotBeSet">
            <summary>
            In some cases, the debugger raises an error because it cannot set a conditional breakpoint.  A local is introduced to simplify the evaluation of the breakpoint's condition.  It's only purpose is to allow a conditional breakpoint in proximity of the breakpoint that cannot be set.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1810_InitializeReferenceTypeStaticFieldsInline_FieldsDeclaredInCodeGeneratedPartialTestClass">
            <summary>
            The static field(s) are declared in a code generated partial test class that should not be alterated.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1811_AvoidUncalledPrivateCode_MethodIsWiredIntoClapAsVerb">
            <summary>
            The method is wired into CLAP, a framework for command-line parsing, as a verb.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1811_AvoidUncalledPrivateCode_PropertyExistsForCompleteness">
            <summary>
            The property exists for completeness.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_ClassIsWiredIntoClapInProgramCs">
            <summary>
            The class is wired into CLAP, a framework for command-line parsing, in Program.cs.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_SerializationConfigurationClassInstantedBySerializer">
            <summary>
            The class derives from SerializationConfigurationBase and is instantiated by a Serializer that is configured using the type of that class.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_ClassExistsToUseItsTypeInUnitTests">
            <summary>
            The class exists because it's Type is used in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1815_OverrideEqualsAndOperatorEqualsOnValueTypes_TypeUsedForTestsThatRequireTypeToNotBeEquatable">
            <summary>
            The type is being used in testing and we explicitly do not want the type to be equatable because it has bearing on the tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1819_PropertiesShouldNotReturnArrays_DataPayloadsAreCommonlyRepresentedAsByteArrays">
            <summary>
            Data payloads are commonly represented as a byte arrays.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1819_PropertiesShouldNotReturnArrays_ArrayPropertyRequiredForTesting">
            <summary>
            An array property is required for unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2000_DisposeObjectsBeforeLosingScope_DisposableObjectIsMethodReturnObject">
            <summary>
            The disposable object is the method's return object.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2000_DisposeObjectsBeforeLosingScope_MethodCreatesDisposableObjectButItCannotBeDisposedBecauseReturnObjectRequiresDisposableObjectToBeFullyIntact">
            <summary>
            The method creates a dispoable object, but it cannot be disposed because the return object requires the disposable object to be fully intact.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2104_DoNotDeclareReadOnlyMutableReferenceTypes_TypeIsImmutable">
            <summary>
            The type is immutable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2201_DoNotRaiseReservedExceptionTypes_UsedForUnitTesting">
            <summary>
            The reserved exception is being used in unit test code; there is no real caller that will be impacted.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2202_DoNotDisposeObjectsMultipleTimes_AnalyzerIsIncorrectlyFlaggingObjectAsBeingDisposedMultipleTimes">
            <summary>
            The analyzer is incorectly flagging an object as being disposed multiple times.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2214_DoNotCallOverridableMethodsInConstructors_OverriddenMethodDoesNotRelyOnInitializationNorOtherConfigurationInConstructor">
            <summary>
            The overridden method does not relies on initialization nor other configuration in the constructor.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2227_CollectionPropertiesShouldBeReadOnly_PublicInterfaceNeverExposesTheObject">
            <summary>
            The public interface of the system associated with this object never exposes this object.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2227_CollectionPropertiesShouldBeReadOnly_SetterIsRequiredForTesting">
            <summary>
            A setter is required for unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2237_MarkISerializableTypesWithSerializable_UsedForTestingWithNoIntentionToSerialize">
            <summary>
            The type is used in unit tests with no intention to serialize.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2237_MarkISerializableTypesWithSerializable_ExceptionOnlyUsedInternallyAndWillNeverBeSerialized">
            <summary>
            The Exception is only used internally; it will never be serialized.
            </summary>
        </member>
        <member name="T:OBeautifulCode.DateTime.Recipes.DateTimeExtensions">
            <summary>
            Extension methods on <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.DateTime.Recipes.DateTimeExtensions.Next(System.DateTime,System.DayOfWeek)">
            <summary>
            Finds a specified day-of-week after a reference date.
            </summary>
            <param name="value">The reference date.</param>
            <param name="dayOfWeek">The next day-of-week to find.</param>
            <returns>
            Returns the specified day-of-week that falls after the reference date.
            </returns>
        </member>
        <member name="M:OBeautifulCode.DateTime.Recipes.DateTimeExtensions.Previous(System.DateTime,System.DayOfWeek)">
            <summary>
            Finds a specified day-of-week prior to a reference date.
            </summary>
            <param name="value">The reference date.</param>
            <param name="dayOfWeek">The previous day-of-week to find.</param>
            <returns>
            Returns the specified day-of-week that falls prior to the reference date.
            </returns>
        </member>
        <member name="M:OBeautifulCode.DateTime.Recipes.DateTimeExtensions.ToUtc(System.DateTime)">
            <summary>
            Converts the provided time into a UTC time.
            </summary>
            <remarks>
            If <paramref name="value"/> is <see cref="F:System.DateTimeKind.Unspecified"/>, then the method will
            simply change it to <see cref="F:System.DateTimeKind.Utc"/>, it will NOT be treated as a local time
            as is the case with <see cref="M:System.DateTime.ToUniversalTime"/>
            </remarks>
            <param name="value">The reference time.</param>
            <returns>
            The UTC time.
            </returns>
        </member>
        <member name="M:OBeautifulCode.DateTime.Recipes.DateTimeExtensions.ToUtc(System.Nullable{System.DateTime})">
            <summary>
            Converts the provided time into a UTC time.
            </summary>
            <param name="value">The reference time.</param>
            <remarks>
            If <paramref name="value"/> is <see cref="F:System.DateTimeKind.Unspecified"/>, then the method will
            simply change it to <see cref="F:System.DateTimeKind.Utc"/>, it will NOT be treated as a local time
            as is the case with <see cref="M:System.DateTime.ToUniversalTime"/>
            </remarks>
            <returns>
            The UTC time.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="value"/> <see cref="T:System.DateTimeKind"/> is not supported.</exception>
        </member>
        <member name="M:OBeautifulCode.DateTime.Recipes.DateTimeExtensions.ToUnspecified(System.DateTime)">
            <summary>
            Converts the provided time into an Unspecified time.
            </summary>
            <param name="value">The reference time.</param>
            <returns>
            The Unspecified time.
            </returns>
        </member>
        <member name="M:OBeautifulCode.DateTime.Recipes.DateTimeExtensions.ToUnspecified(System.Nullable{System.DateTime})">
            <summary>
            Converts the specified time into a Unspecified time.
            </summary>
            <param name="value">The reference time.</param>
            <returns>
            The Unspecified time.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer">
            <summary>
            Compares two byte arrays for equality.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer.Equals(System.Byte[],System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer.GetHashCode(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer">
            <summary>
            Compares two <see cref="T:System.DateTime"/>, fixing .NET's default implementation where two objects
            having the same <see cref="P:System.DateTime.Ticks"/> but different <see cref="P:System.DateTime.Kind"/> are
            considered equal.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer.Equals(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer.GetHashCode(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of dictionary keys.</typeparam>
            <typeparam name="TValue">The type of dictionary values.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2.Equals(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2.GetHashCode(System.Collections.Generic.IDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/14675741/356790" />.
            </remarks>
            <typeparam name="T">The type of objects to enumerate.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.#ctor(OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1"/> class.
            </summary>
            <param name="enumerableEqualityComparerStrategy">The strategy to use when comparing two <see cref="T:System.Collections.Generic.IEnumerable`1"/> for equality.</param>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.Equals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy">
            <summary>
            Determines the strategy to use when comparing two <see cref="T:System.Collections.Generic.IEnumerable`1"/> for equality.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy.SequenceEqual">
            <summary>
            Use <see cref="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsSequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy.UnorderedEqual">
            <summary>
            Use <see cref="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsUnorderedEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EqualityComparerHelper">
            <summary>
            Helper methods related to <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets the equality comparer to use for the specified type.
            </summary>
            <typeparam name="T">The type of the objects being compared.</typeparam>
            <param name="comparer">Optional comparer passed into the calling method.  Default is null, which instructs this method to determine the comparer.  If not null, then the specified comparer is returned.</param>
            <returns>
            The equality comparer to use for the specified type.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EqualityExtensions">
            <summary>
            Extension methods that test for equality between two objects.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsEqualTo``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares objects for equality.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
            <param name="item1">The first object to compare.</param>
            <param name="item2">The second object to compare.</param>
            <param name="comparer">Optional equality comparer to use to compare the objects.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two objects are equal
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsDictionaryEqualTo``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionaries.</typeparam>
            <typeparam name="TValue">The type of values in the dictionaries.</typeparam>
            <param name="item1">The first <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="item2">The second <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="valueComparer">Optional equality comparer to use to compare values.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source dictionaries are null.
            - false if one or the other is null.
            - false if the dictionaries are of different length.
            - true if the two dictionaries are of equal length and their values are equal for the same keys.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsReadOnlyDictionaryEqualTo``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionaries.</typeparam>
            <typeparam name="TValue">The type of values in the dictionaries.</typeparam>
            <param name="item1">The first <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="item2">The second <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="valueComparer">Optional equality comparer to use to compare values.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source dictionaries are null.
            - false if one or the other is null.
            - false if the dictionaries are of different length.
            - true if the two dictionaries are of equal length and their values are equal for the same keys.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsSequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TElement">The type of the elements of the input sequences.</typeparam>
            <param name="item1">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to <paramref name="item2"/>.</param>
            <param name="item2">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to the first sequence.</param>
            <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source sequences are null.
            - false if one or the other is null.
            - true if the two sequences are of equal length and their corresponding elements are equal according to <paramref name="elementComparer"/>.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsUnorderedEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if two enumerables have the exact same elements in any order.
            Every unique element in the first set has to appear in the second set the same number of times it appears in the first.
            </summary>
            <typeparam name="TElement">The type of the elements of the input sequences.</typeparam>
            <param name="item1">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to <paramref name="item2"/>.</param>
            <param name="item2">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to the first sequence.</param>
            <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source sequences are null.
            - false if one or the other is null.
            - false if there is any symmetric difference.
            - true if the two sequences both contain the same number of elements for each unique element.
            - otherwise, false.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.HashCodeHelper">
            <summary>
            Provides methods to help with generating hash codes for structures and classes. This handles
            value types, nullable type, and objects.
            </summary>
            <remarks>
            Adapted from NodaTime: <a href="https://github.com/nodatime/nodatime/blob/master/src/NodaTime/Utility/HashCodeHelper.cs"/>.
            The basic usage pattern is as follows.
            <example>
            <code>
             public override int GetHashCode() => HashCodeHelper.Initialize().Hash(Field1).Hash(Field2).Hash(Field3).Value;
            </code>
            </example>
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.HashCodeHelper.HashCodeMultiplier">
            <summary>
            The multiplier for each value.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.HashCodeHelper.HashCodeInitializer">
            <summary>
            The initial hash value.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> class.
            </summary>
            <param name="value">The hash code value.</param>
        </member>
        <member name="P:OBeautifulCode.Equality.Recipes.HashCodeHelper.Value">
            <summary>
            Gets the hash code value.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Initialize">
            <summary>
            Returns the initial value for a hash code.
            </summary>
            <returns>The initial integer wrapped in a <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> value.</returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Initialize(System.Int32)">
            <summary>
            Returns the initial value for a hash code.
            </summary>
            <param name="seedValue">Seed value to initialize with (often the hash code from a base class using it's base properties).</param>
            <returns>The initial integer wrapped in a <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> value.</returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Hash``1(``0)">
            <summary>
            Adds the hash code for the given item to the current hash code and returns the new hash code.
            </summary>
            <typeparam name="T">The type of the item being hashed.</typeparam>
            <param name="item">The item to hash.</param>
            <returns>The new hash code.</returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1">
            <summary>
            An equality comparer backed by a lambda.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1"/> class.
            </summary>
            <param name="equalsFunc">The function to use to determine whether two objects of type <typeparamref name="T"/> are equal.</param>
            <param name="getHashCodeFunc">OPTIONAL function to get the hash code for an object of type <typeparamref name="T"/> in context of this equality comparer.  DEFAULT is to have <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"/> throw <see cref="T:System.NotSupportedException"/>.</param>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.NativeMethods">
            <summary>
            P/invoke method.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NativeMethods.memcmp(System.Byte[],System.Byte[],System.Int64)">
            <summary>
            Compares two byte arrays.
            </summary>
            <param name="b1">The first byte array.</param>
            <param name="b2">The second byte array.</param>
            <param name="count">The length of the bytes.</param>
            <returns>
            0 if the byte arrays are equal.
            Less than 0 if the first byte array is less than the second byte array.
            Greater than 0 if the first byte array is greater than the second byte array.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer">
            <summary>
            Compares two <see cref="T:System.Nullable`1"/>, fixing .NET's default implementation where two objects
            having the same <see cref="P:System.DateTime.Ticks"/> but different <see cref="P:System.DateTime.Kind"/> are
            considered equal.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer.Equals(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer.GetHashCode(System.Nullable{System.DateTime})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer">
            <summary>
            Compares two objects equality.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer.Equals(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer.GetHashCode(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of dictionary keys.</typeparam>
            <typeparam name="TValue">The type of dictionary values.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2.Equals(System.Collections.Generic.IReadOnlyDictionary{`0,`1},System.Collections.Generic.IReadOnlyDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2.GetHashCode(System.Collections.Generic.IReadOnlyDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.ArrayKind">
            <summary>
            Specifies the kind of array.
            </summary>
            <remarks>
            See <a href="https://stackoverflow.com/questions/60859850/how-to-determine-if-rank-1-array-is-a-vector-or-multidimensional-array?noredirect=1#comment107679655_60859850"/>.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.None">
            <summary>
            Not an array.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.Vector">
            <summary>
            A vector array.  Can only have a single dimension.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.Multidimensional">
            <summary>
            A multidimensional array.  Can have 1 to 32 dimensions.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.ToStringReadableOptions">
            <summary>
            Options for generating a readability-optimized string representation of a type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.None">
            <summary>
            None (default).
            Use this option to generate the most succinct representation of the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.IncludeNamespace">
            <summary>
            Include the namespace of the type.
            If the type is generic then also include the namespace of all generic argument types.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.IncludeAssemblyDetails">
            <summary>
            Include details (name and version) about the assembly that contains the type.
            If the type is generic then also include details about the assembly that contains
            all of the generic argument types.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions">
            <summary>
            Options for generating a XML doc compatible string representation of a type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions.None">
            <summary>
            None (default).
            Use this option to generate the most succinct representation of the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions.IncludeNamespace">
            <summary>
            Include the namespace of the type.
            If the type is generic then also include the namespace of all generic argument types.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.TypeExtensions">
            <summary>
            Extension methods on type <see cref="T:System.Type"/>.
            </summary>
            <remarks>
            These resources helped:
            <a href="https://stackoverflow.com/questions/13012733/difference-between-type-isgenerictypedefinition-and-type-containsgenericparamete" />.
            <a href="https://stackoverflow.com/questions/2173107/what-exactly-is-an-open-generic-type-in-net" />.
            <a href="https://stackoverflow.com/questions/1735035/generics-open-and-closed-constructed-types" />.
            <a href="https://stackoverflow.com/questions/25811514/detect-if-a-generic-type-is-open" />.
            <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
            <a href="https://stackoverflow.com/questions/31772922/difference-between-isgenerictype-and-isgenerictypedefinition" />.
            <a href="https://stackoverflow.com/questions/59144791/if-type-isgenericparameter-true-will-type-containsgenericparameters-true?noredirect=1#comment104515860_59144791" />.
            <a href="https://stackoverflow.com/questions/59141721/why-is-the-basetype-of-a-generic-type-definition-not-itself-a-generic-type-defin?noredirect=1#comment104515814_59141721" />.
            </remarks>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetArrayKind(System.Type)">
            <summary>
            Determines the kind of array that the specified type is.
            </summary>
            <param name="type">The type.</param>
            <returns>
            The kind of array of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedEnumerableElementType(System.Type)">
            <summary>
            Gets the type of the elements of a specified closed Enumerable type.
            </summary>
            <param name="type">The closed Enumerable type.</param>
            <returns>
            The type of the elements of the specified closed Enumerable type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Enumerable type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedDictionaryKeyType(System.Type)">
            <summary>
            Gets the type of the keys of a specified closed Dictionary type.
            </summary>
            <param name="type">The closed Dictionary type.</param>
            <returns>
            The type of the keys of the specified closed Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Dictionary type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedDictionaryValueType(System.Type)">
            <summary>
            Gets the type of the values of a specified closed Dictionary type.
            </summary>
            <param name="type">The closed Dictionary type.</param>
            <returns>
            The type of the values of the specified closed Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Dictionary type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemCollectionElementType(System.Type)">
            <summary>
            Gets the type of the elements of the specified closed <see cref="N:System"/> Collection type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Collection type.</param>
            <returns>
            The type of the elements of the specified closed <see cref="N:System"/> Collection type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Collection type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemCollectionType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemDictionaryKeyType(System.Type)">
            <summary>
            Gets the type of the keys of the specified closed <see cref="N:System"/> Dictionary type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Dictionary type.</param>
            <returns>
            The type of the keys of the specified closed <see cref="N:System"/> Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Dictionary type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemDictionaryValueType(System.Type)">
            <summary>
            Gets the type of the values of the specified closed <see cref="N:System"/> Dictionary type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Dictionary type.</param>
            <returns>
            The type of the values of the specified closed <see cref="N:System"/> Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Dictionary type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetGenericTypeDefinitionOrSpecifiedType(System.Type)">
            <summary>
            Gets the generic type definition of a specified type if the type is generic
            but not a generic type definition, otherwise returns the specified type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            If the specified type is a generic type but not a generic type definition then the
            generic type definition is returned, otherwise the specified type is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetInheritancePath(System.Type)">
            <summary>
            Gets the types in the inheritance path starting from the specified type's
            <see cref="P:System.Type.BaseType"/> and ending in a type with no <see cref="P:System.Type.BaseType"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            The <see cref="P:System.Type.BaseType"/> of <paramref name="type"/>, followed by that type's
            <see cref="P:System.Type.BaseType"/>, and so on until a type has no <see cref="P:System.Type.BaseType"/>
            (that property returns null).
            If <paramref name="type"/> has no <see cref="P:System.Type.BaseType"/>, then this method returns
            an empty list.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not assignable to <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.EnumerableInterfaceType"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasDefaultConstructor(System.Type)">
            <summary>
            Determines if the specified type has a default (public parameterless) constructor.
            </summary>
            <param name="type">Type to check.</param>
            <returns>
            A value indicating whether or not the type has a default (public parameterless) constructor.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasBaseType(System.Type)">
            <summary>
            Determines if the specified type has a base type.
            </summary>
            <returns>
            true if the specified type has a base type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasObjectAsBaseType(System.Type)">
            <summary>
            Determines if the base type of the specified type is object.
            </summary>
            <returns>
            true if the base type of the specified type is object, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer``1">
            <summary>
            Determines if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> will return a
            working (non-throwing) comparer for the specified type.
            </summary>
            <remarks>
            See remarks in <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer(System.Type)"/>.
            </remarks>
            <typeparam name="T">The type.</typeparam>
            <returns>
            true if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> returns a working (non-throwing)
            comparer for the specified type, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer(System.Type)">
            <summary>
            Determines if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> will return a
            working (non-throwing) comparer for the specified type.
            </summary>
            <remarks>
            <see cref="P:System.Collections.Generic.Comparer`1.Default" /> will always return some comparer for
            any given closed type.  However, that comparer, when used, will or will no
            throw based on the type itself.  If the type implements or inherits <see cref="T:System.IComparable`1"/>
            where T is itself, then the comparer will ultimately use that implementation.
            We say "ultimately" here and below because a wrapper object is used.
            If the type is nullable and the underlying type implements or inherits <see cref="T:System.IComparable`1"/>
            where T is the underlying type, then the comparer will ultimately use that implementation.
            Finally, if the the type, when boxed, implements or inherits <see cref="T:System.IComparable"/> then the comparer
            will ultimately use that implementation.  If not, then, upon using the comparer to compare two
            objects, an exception will be thrown.
            It's further important to note that this method is NOT simply checking whether the specified
            type is assignable to <see cref="T:System.IComparable`1"/>.  For example:
            typeof(IComparable&lt;string&gt;).HasWorkingDefaultComparer() == false
            That's because that type doesn't implement IComparable&lt;IComparable&lt;string&gt;&gt;
            per the heuristic described above.  That said, any type that is assignable to <see cref="T:System.IComparable"/>
            will return true per the heuristic above.  For example:
            typeof(IComparable).HasWorkingDefaultComparer() == true.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> returns a working (non-throwing)
            comparer for the specified type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="type"/> is an open type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsAssignableTo(System.Type,System.Type,System.Boolean)">
            <summary>
            Determines if a type if assignable to another type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/questions/74616/how-to-detect-if-type-is-another-generic-type/1075059#1075059" />.
            </remarks>
            <param name="type">The current type.</param>
            <param name="otherType">The type to check for ability to assign to.</param>
            <param name="treatGenericTypeDefinitionAsAssignableTo">If <paramref name="otherType"/> is a generic type definition, specifies whether the method should treat that type as if a closed type can be assigned to it (e.g. IsAssignableTo(List&lt;int&gt;, List&lt;&gt;)).</param>
            <returns>
            true if <paramref name="type"/> can be assigned to <paramref name="otherType"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherType"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="type"/> is an open type.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="otherType"/> is an open type, but not a generic type definition.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedTypeAssignableToNull(System.Type)">
            <summary>
            Determines if the specified type is closed and assignable to null.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/1770232/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is closed and assignable to null, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousType(System.Type)">
            <summary>
            Determines if a type is a closed anonymous type.
            </summary>
            <param name="type">Type to check.</param>
            <returns>A value indicating whether or not the type provided is a closed anonymous type.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousTypeFastCheck(System.Type)">
            <summary>
            Determines if a type is a closed anonymous type using a faster, but potentially
            less accurate heuristic than <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousType(System.Type)"/>.
            </summary>
            <param name="type">Type to check.</param>
            <returns>A value indicating whether or not the type provided is a closed anonymous type.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedGenericType(System.Type)">
            <summary>
            Determines if the specified type is a closed generic type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed generic type; otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedNonAnonymousClassType(System.Type)">
            <summary>
            Determines if the specified type is a class type, that's not anonymous, and is closed.
            </summary>
            <remarks>
            This is basically asking, "Is this a class type that can be constructed/new-ed up?".
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a class type, non-anonymous, and closed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedNullableType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Nullable`1"/> type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Nullable`1"/> type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="N:System"/> collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)">
            <summary>
            Determines if the specified type is a closed version one of one of the
            following <see cref="N:System"/> Dictionary generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemDictionaryGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="N:System"/> dictionary type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemEnumerableType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemKeyValuePairType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemOrderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following ordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemOrderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed, ordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemUnorderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following unordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemUnorderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed, unordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsNullableType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Nullable`1"/> type.
            </summary>
            <remarks>Adapted from: <a href="https://stackoverflow.com/a/41281601/356790" />.</remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Nullable`1"/> type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemType(System.Type)">
            <summary>
            Determines if the specified type is in the <see cref="N:System"/> namespace.
            </summary>
            <remarks>
            An array is considered a system type.
            A ValueTuple is considered a system type.
            A generic type parameter is considered a system type.
            An anonymous type is not considered a system type.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is in the <see cref="N:System"/> namespace, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="N:System"/> collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemDictionaryType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version one of one of the
            following <see cref="N:System"/> Dictionary generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemDictionaryGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="N:System"/> dictionary type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemEnumerableType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemKeyValuePairType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemOrderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following ordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemOrderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed, ordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemUnorderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following unordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemUnorderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed, unordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsTypeAssignableToNull(System.Type)">
            <summary>
            Determines if the specified type is assignable to null.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/1770232/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is assignable to null, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.MakeGenericTypeOrNull(System.Type,System.Type[])">
            <summary>
            Substitutes the elements of an array of types for the type parameters of the current
            generic type definition and returns a <see cref="T:System.Type"/> object representing the resulting constructed type
            or null if the operation cannot be performed.
            </summary>
            <param name="type">The generic type definition.</param>
            <param name="typeArguments">An array of types to be substituted for the type parameters of <paramref name="type"/>.</param>
            <returns>
            A <see cref="T:System.Type"/> representing the constructed type formed by substituting the
            elements of <paramref name="typeArguments"/> for the type parameters of <paramref name="type"/> or null
            if the operation cannot be performed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringCompilable(System.Type,System.Boolean)">
            <summary>
            Gets a compilable, readability-optimized string representation of the specified type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
            Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
            </remarks>
            <param name="type">The type.</param>
            <param name="throwIfNoCompilableStringExists">Optional value indicating whether to throw a <see cref="T:System.NotSupportedException"/> if there's no compilable representation of the specified type.</param>
            <returns>
            A compilable, readability-optimized string representation of the specified type
            OR
            null if there is no compilable representation and <paramref name="throwIfNoCompilableStringExists"/> is true.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic open constructed type, which is not supported.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic parameter.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringReadable(System.Type,OBeautifulCode.Type.Recipes.ToStringReadableOptions)">
            <summary>
            Gets a readability-optimized string representation of the specified type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
            Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
            Helpful breakdown of generics: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
            </remarks>
            <param name="type">The type.</param>
            <param name="options">The options to use when generating the string representation.</param>
            <returns>
            A readability-optimized string representation of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringXmlDoc(System.Type,System.Boolean,OBeautifulCode.Type.Recipes.ToStringXmlDocOptions)">
            <summary>
            Gets an XML-doc compatible string representation of the specified type.
            </summary>
            <param name="type">The type.</param>
            <param name="throwIfNoCompatibleStringExists">Optional value indicating whether to throw a <see cref="T:System.NotSupportedException"/> if there's no compatible string representation of the specified type.</param>
            <param name="options">The options to use when generating the string representation.</param>
            <returns>
            A XML-doc compatible string representation of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringWithoutGenericComponent(System.Type)">
            <summary>
            Gets a string representation of the specified type without the generic component.
            For example, Dictionary&lt;string, string&gt; would be represented as 'Dictionary'.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6386234/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            A string representation of the specified type with the generic component stripped out.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.TryMakeGenericType(System.Type,System.Type@,System.Type[])">
            <summary>
            Substitutes the elements of an array of types for the type parameters of the current
            generic type definition and returns a <see cref="T:System.Type"/> object representing the resulting constructed type.
            </summary>
            <param name="type">The generic type definition.</param>
            <param name="genericType">A <see cref="T:System.Type"/> representing the constructed type formed by substituting the elements of <paramref name="typeArguments"/> for the type parameters of <paramref name="type"/> or null if the operation cannot be performed.</param>
            <param name="typeArguments">An array of types to be substituted for the type parameters of <paramref name="type"/>.</param>
            <returns>
            true if the type was successfully constructed; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.AccountingPeriodSystem">
            <summary>
            Represents a system for defining an entity's annual accounting period.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.AccountingPeriodSystem.op_Equality(OBeautifulCode.AccountingTime.AccountingPeriodSystem,OBeautifulCode.AccountingTime.AccountingPeriodSystem)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.AccountingPeriodSystem"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.AccountingPeriodSystem.op_Inequality(OBeautifulCode.AccountingTime.AccountingPeriodSystem,OBeautifulCode.AccountingTime.AccountingPeriodSystem)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.AccountingPeriodSystem"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.AccountingPeriodSystem.Equals(OBeautifulCode.AccountingTime.AccountingPeriodSystem)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.AccountingPeriodSystem.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.AccountingPeriodSystem.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.AccountingPeriodSystem.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.AccountingPeriodSystem.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.AccountingPeriodSystem.DeepCloneInternal">
            <summary>
            Creates a new object that is a deep clone of this instance.
            </summary>
            <returns>
            A new object that is a deep clone of this instance.
            </returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.AccountingPeriodSystem.ToString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.AccountingPeriodSystem.GetReportingPeriodForFiscalYear(OBeautifulCode.AccountingTime.FiscalYear)">
            <summary>
            Gets the reporting period, in calendar days, for the specified fiscal year.
            </summary>
            <param name="fiscalYear">The fiscal year.</param>
            <returns>
            Returns the reporting period, in calendar days, for the specified fiscal year.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fiscalYear"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem">
            <summary>
            A calendar year is 12 consecutive months beginning on January 1st and ending on December 31st.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem.op_Equality(OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem,OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem.op_Inequality(OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem,OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem.Equals(OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem.ToString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYearAccountingPeriodSystem.GetReportingPeriodForFiscalYear(OBeautifulCode.AccountingTime.FiscalYear)">
            <inheritdoc />
            <exception cref="T:System.ArgumentNullException"><paramref name="fiscalYear"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem">
            <summary>
            This system is used by companies that want that their accounting year always end on the same day of the week.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.op_Equality(OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem,OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.op_Inequality(OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem,OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.Equals(OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.DeepCloneWithLastDayOfWeekInAccountingYear(System.DayOfWeek)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.LastDayOfWeekInAccountingYear" />.
            </summary>
            <param name="lastDayOfWeekInAccountingYear">The new <see cref="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.LastDayOfWeekInAccountingYear" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem" /> using the specified <paramref name="lastDayOfWeekInAccountingYear" /> for <see cref="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.LastDayOfWeekInAccountingYear" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.DeepCloneWithAnchorMonth(OBeautifulCode.AccountingTime.MonthOfYear)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.AnchorMonth" />.
            </summary>
            <param name="anchorMonth">The new <see cref="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.AnchorMonth" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem" /> using the specified <paramref name="anchorMonth" /> for <see cref="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.AnchorMonth" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.DeepCloneWithFiftyTwoFiftyThreeWeekMethodology(OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekMethodology)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.FiftyTwoFiftyThreeWeekMethodology" />.
            </summary>
            <param name="fiftyTwoFiftyThreeWeekMethodology">The new <see cref="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.FiftyTwoFiftyThreeWeekMethodology" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem" /> using the specified <paramref name="fiftyTwoFiftyThreeWeekMethodology" /> for <see cref="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.FiftyTwoFiftyThreeWeekMethodology" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.ToString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.#ctor(System.DayOfWeek,OBeautifulCode.AccountingTime.MonthOfYear,OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekMethodology)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem"/> class.
            </summary>
            <param name="lastDayOfWeekInAccountingYear">The day of the week that the fiscal year always ends on.</param>
            <param name="anchorMonth">The month that the fiscal year end is anchored to.  See <see cref="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.FiftyTwoFiftyThreeWeekMethodology"/>.</param>
            <param name="fiftyTwoFiftyThreeWeekMethodology">The methodology used to identify the last day of the accounting year.</param>
            <exception cref="T:System.ArgumentException"><paramref name="anchorMonth"/> is invalid.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.LastDayOfWeekInAccountingYear">
            <summary>
            Gets the day of the week that the fiscal year always ends on.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.AnchorMonth">
            <summary>
            Gets the month that the fiscal year end is anchored to.
            See <see cref="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.FiftyTwoFiftyThreeWeekMethodology"/>.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.FiftyTwoFiftyThreeWeekMethodology">
            <summary>
            Gets the methodology used to identify the last day of the accounting year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekAccountingPeriodSystem.GetReportingPeriodForFiscalYear(OBeautifulCode.AccountingTime.FiscalYear)">
            <inheritdoc />
            <exception cref="T:System.ArgumentNullException"><paramref name="fiscalYear"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem">
            <summary>
            A fiscal year is 12 consecutive months ending on the last day of any month except December 31st.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.op_Equality(OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem,OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.op_Inequality(OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem,OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.Equals(OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.DeepCloneWithLastMonthInFiscalYear(OBeautifulCode.AccountingTime.MonthOfYear)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.LastMonthInFiscalYear" />.
            </summary>
            <param name="lastMonthInFiscalYear">The new <see cref="P:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.LastMonthInFiscalYear" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem" /> using the specified <paramref name="lastMonthInFiscalYear" /> for <see cref="P:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.LastMonthInFiscalYear" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.ToString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.#ctor(OBeautifulCode.AccountingTime.MonthOfYear)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem"/> class.
            </summary>
            <param name="lastMonthInFiscalYear">The last month of the fiscal year.</param>
            <exception cref="T:System.ArgumentException"><paramref name="lastMonthInFiscalYear"/> is invalid.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="lastMonthInFiscalYear"/> is <see cref="F:OBeautifulCode.AccountingTime.MonthOfYear.December"/>.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.LastMonthInFiscalYear">
            <summary>
            Gets the last month of the fiscal year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYearAccountingPeriodSystem.GetReportingPeriodForFiscalYear(OBeautifulCode.AccountingTime.FiscalYear)">
            <inheritdoc />
            <exception cref="T:System.ArgumentNullException"><paramref name="fiscalYear"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.DateTimeExtensions">
            <summary>
            Extension methods on <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.DateTimeExtensions.ToCalendarDay(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> into a <see cref="T:OBeautifulCode.AccountingTime.CalendarDay"/>.
            </summary>
            <param name="value">The date/time to convert.</param>
            <returns>
            A <see cref="T:OBeautifulCode.AccountingTime.CalendarDay"/> converted from a <see cref="T:System.DateTime"/>.
            </returns>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.OverflowStrategy">
            <summary>
            A strategy for dealing with overflow when splitting a reporting period.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.OverflowStrategy.ThrowOnOverflow">
            <summary>
            Throw on any overflow.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.QuarterNumberExtensions">
            <summary>
            Extension methods on type <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.QuarterNumberExtensions.ToCalendar(OBeautifulCode.AccountingTime.QuarterNumber,System.Int32)">
            <summary>
            Constructs a calendar quarter from a <see cref="T:OBeautifulCode.AccountingTime.QuarterNumber"/> and a year.
            </summary>
            <param name="quarterNumber">The quarter number.</param>
            <param name="year">The year.</param>
            <returns>
            A calendar quarter constructed from the specified <see cref="T:OBeautifulCode.AccountingTime.QuarterNumber"/> and year.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="quarterNumber"/> is <see cref="F:OBeautifulCode.AccountingTime.QuarterNumber.Invalid"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.QuarterNumberExtensions.ToFiscal(OBeautifulCode.AccountingTime.QuarterNumber,System.Int32)">
            <summary>
            Constructs a fiscal quarter from a <see cref="T:OBeautifulCode.AccountingTime.QuarterNumber"/> and a year.
            </summary>
            <param name="quarterNumber">The quarter number.</param>
            <param name="year">The year.</param>
            <returns>
            A fiscal quarter constructed from the specified <see cref="T:OBeautifulCode.AccountingTime.QuarterNumber"/> and year.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="quarterNumber"/> is <see cref="F:OBeautifulCode.AccountingTime.QuarterNumber.Invalid"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.QuarterNumberExtensions.ToGeneric(OBeautifulCode.AccountingTime.QuarterNumber,System.Int32)">
            <summary>
            Constructs a generic quarter from a <see cref="T:OBeautifulCode.AccountingTime.QuarterNumber"/> and a year.
            </summary>
            <param name="quarterNumber">The quarter number.</param>
            <param name="year">The year.</param>
            <returns>
            A generic quarter constructed from the specified <see cref="T:OBeautifulCode.AccountingTime.QuarterNumber"/> and year.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="quarterNumber"/> is <see cref="F:OBeautifulCode.AccountingTime.QuarterNumber.Invalid"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.QuarterNumberExtensions.ToOrdinalIndicator(OBeautifulCode.AccountingTime.QuarterNumber)">
            <summary>
            Converts the specified quarter to a string representation of it's ordinal indicator
            (i.e. "1st", "2nd", "3rd", or "4th").
            </summary>
            <param name="quarterNumber">The quarter number.</param>
            <returns>
            A string representation of the specified quarter number's ordinal indicator.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="quarterNumber"/> is <see cref="F:OBeautifulCode.AccountingTime.QuarterNumber.Invalid"/>.</exception>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.ReportingPeriodExtensions">
            <summary>
            Comparison-related extension methods on <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod"/>.
            </summary>
            <summary>
            Extension methods to shape and manipulate a <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod"/>.
            </summary>
            <summary>
            Property-related extension methods on <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod"/>.
            </summary>
            <summary>
            Serialization-related extension methods on <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.Contains(OBeautifulCode.AccountingTime.ReportingPeriod,OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Determines if a unit-of-time is contained within a reporting period.
            For example, 2Q2017 is contained within a reporting period of 1Q2017-4Q2017.
            </summary>
            <remarks>
            If the unit-of-time is equal to one of the endpoints of the reporting period,
            that unit-of-time is considered to be within the reporting period.
            </remarks>
            <param name="reportingPeriod">The reporting period.</param>
            <param name="unitOfTime">The unit-of-time to check against a reporting period.</param>
            <returns>
            true if the unit-of-time is contained within the reporting period; false otherwise.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="unitOfTime"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="unitOfTime"/> cannot be compared against <paramref name="reportingPeriod"/> because they represent different <see cref="P:OBeautifulCode.AccountingTime.UnitOfTime.UnitOfTimeKind"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.Contains(OBeautifulCode.AccountingTime.ReportingPeriod,OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Determines if a reporting period is contained within another reporting period.
            For example, 1Q2017-3Q2017 contains 2Q2017-3Q2017.
            </summary>
            <remarks>
            If an endpoint in the second reporting period equals an endpoint in the first reporting period, that endpoint
            is considered to be contained within the first reporting period.  Of course, both endpoints must be contained
            within the reporting period for this method to return true.
            </remarks>
            <param name="reportingPeriod1">A reporting period.</param>
            <param name="reportingPeriod2">A second reporting period to check for containment within the first reporting period.</param>
            <returns>
            true if the first reporting period contains the second one; false if not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod1"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod2"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="reportingPeriod1"/> cannot be compared against <paramref name="reportingPeriod2"/> because they represent different <see cref="P:OBeautifulCode.AccountingTime.UnitOfTime.UnitOfTimeKind"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.HasOverlapWith(OBeautifulCode.AccountingTime.ReportingPeriod,OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Determines if two reporting periods overlap.
            For example, the following reporting periods have an overlap: 1Q2017-3Q2017 and 3Q2017-4Q2017.
            </summary>
            <remarks>
            If the endpoint of one reporting period is the same as the endpoint
            of the second reporting period, the reporting periods are deemed to overlap.
            </remarks>
            <param name="reportingPeriod1">A reporting period.</param>
            <param name="reportingPeriod2">A second reporting period to check for overlap against the first reporting period.</param>
            <returns>
            true if there is an overlap between the reporting periods; false otherwise.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod1"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod2"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="reportingPeriod1"/> cannot be compared against <paramref name="reportingPeriod2"/> because they represent different <see cref="P:OBeautifulCode.AccountingTime.UnitOfTime.UnitOfTimeKind"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.IsGreaterThanAndAdjacentTo(OBeautifulCode.AccountingTime.ReportingPeriod,OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Determines if a reporting period is greater than and adjacent to a second reporting period.
            </summary>
            <remarks>
            For this method to return true, the first reporting period's Start must be greater than the
            second reporting period's End, and they must be adjacent (subtracting one unit in the same granularity
            to the first reporting period's Start should make it equal to the second reporting period's End)
            For example, 3Q2017-4Q2017 is greater than and adjacent to 1Q2017-2Q2017.
            For example, 3Q2017-4Q2017 is NOT greater than 1Q2017-3Q2017, because they overlap.
            For example, 4Q2017-4Q2017 is NOT adjacent to 1Q2017-2Q2017, because there's a gap of 3Q2017.
            </remarks>
            <param name="reportingPeriod1">A reporting period to check if greater than and adjacent to a second reporting period.</param>
            <param name="reportingPeriod2">The second reporting period.</param>
            <returns>
            true if the first reporting period is greater than and adjacent to the second reporting period; false, otherwise.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod1"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod2"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="reportingPeriod1"/> cannot be compared against <paramref name="reportingPeriod2"/> because they represent different <see cref="P:OBeautifulCode.AccountingTime.UnitOfTime.UnitOfTimeKind"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.CloneWithAdjustment(OBeautifulCode.AccountingTime.ReportingPeriod,OBeautifulCode.AccountingTime.ReportingPeriodComponent,System.Int32,OBeautifulCode.AccountingTime.UnitOfTimeGranularity)">
            <summary>
            Clones a reporting period while adjusting the start or end of the reporting period, or both.
            </summary>
            <param name="reportingPeriod">The reporting period to clone.</param>
            <param name="component">The component(s) of the reporting period to adjust.</param>
            <param name="unitsToAdd">The number of units to add when adjusting the reporting period component.  Use negative numbers to subtract units.</param>
            <param name="granularityOfUnitsToAdd">The granularity of the units to add to the specified reporting period component(s).  Must be as or less granular than the reporting period component (e.g. can add CalendarYear to a CalendarQuarter, but not vice-versa).</param>
            <returns>A clone of the specified reporting period with the specified adjustment made to the start or end of the reporting period, or both.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="component"/> is <see cref="F:OBeautifulCode.AccountingTime.ReportingPeriodComponent.Invalid"/>.</exception>
            <exception cref="T:System.ArgumentException">Cannot add or subtract from a unit-of-time whose granularity is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Unbounded"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="granularityOfUnitsToAdd"/> is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Invalid"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="granularityOfUnitsToAdd"/> is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Unbounded"/>.  Cannot add units of that granularity.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="granularityOfUnitsToAdd"/> is more granular than the reporting period component.  Only units that are as granular or less granular than a unit-of-time can be added to that unit-of-time.</exception>
            <exception cref="T:System.InvalidOperationException">The adjustment has caused the <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.Start"/> to be greater than <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.End"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.CreatePermutations(OBeautifulCode.AccountingTime.ReportingPeriod,System.Int32)">
            <summary>
            Creates all permutations of reporting periods between the
            start and end of a specified reporting period, from 1 unit
            to the specified number of maximum number of units that a
            reporting period can contain.
            </summary>
            <param name="reportingPeriod">The reporting period to permute.</param>
            <param name="maxUnitsInAnyReportingPeriod">Maximum number of units-of-time in each reporting period.</param>
            <returns>All possible reporting periods containing between 1 and <paramref name="maxUnitsInAnyReportingPeriod"/> units-of-time, contained within <paramref name="reportingPeriod"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="reportingPeriod"/> has an <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Unbounded"/> component.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxUnitsInAnyReportingPeriod"/> is less than or equal to 0.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.Split(OBeautifulCode.AccountingTime.ReportingPeriod,OBeautifulCode.AccountingTime.UnitOfTimeGranularity,OBeautifulCode.AccountingTime.OverflowStrategy)">
            <summary>
            Splits a reporting period into units-of-time by a specified granularity.
            </summary>
            <param name="reportingPeriod">The reporting period to split.</param>
            <param name="granularity">The granularity to use when splitting.</param>
            <param name="overflowStrategy">
            The strategy to use when <paramref name="granularity"/> is less granular than
            the <paramref name="reportingPeriod"/> and, when splitting, the resulting units-of-time
            cannot be aligned with the start and end of the reporting period.  For example,
            splitting Mar2015-Feb2017 by year results in 2015,2016,2017, however only 2016 is
            fully contained within the reporting period.  The reporting period is missing Jan2015-Feb2015
            and March2017-Dec2017.
            </param>
            <returns>
            Returns the units-of-time that split the specified reporting period by the specified granularity.
            The units-of-time will always be in the specified granularity, regardless of the granularity
            of the reporting period (e.g. splitting a fiscal month reporting period using yearly granularity
            will return <see cref="T:OBeautifulCode.AccountingTime.FiscalYear"/> objects).
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="reportingPeriod"/> has an <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Unbounded"/> component.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="granularity"/> is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Invalid"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="granularity"/> is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Unbounded"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="overflowStrategy"/> is not <see cref="F:OBeautifulCode.AccountingTime.OverflowStrategy.ThrowOnOverflow"/>.</exception>
            <exception cref="T:System.InvalidOperationException">There was some overflow when splitting.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.ToMostGranular(OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Converts the the specified reporting period into the most
            granular possible, but equivalent, reporting period.
            </summary>
            <param name="reportingPeriod">The reporting period to operate on.</param>
            <returns>
            A reporting period that addresses the same set of time as <paramref name="reportingPeriod"/>,
            but is the most granular version possible of that reporting period.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.ToLeastGranular(OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Converts the the specified reporting period into the least
            granular possible, but equivalent, reporting period.
            </summary>
            <param name="reportingPeriod">The reporting period to operate on.</param>
            <returns>
            A reporting period that addresses the same set of time as <paramref name="reportingPeriod"/>,
            but is the least granular version possible of that reporting period.
            Any reporting period with one unbounded and one bounded component will be returned
            as-is (e.g. Unbounded to 12/31/2017 will not be converted to Unbounded to CalendarYear 2017).
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.GetUnitOfTimeGranularity(OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Gets the granularity of the unit-of-time used in a reporting period.
            </summary>
            <param name="reportingPeriod">The reporting period.</param>
            <returns>
            The granularity of the unit-of-time used in the specified reporting period.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="reportingPeriod"/> <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.Start"/> and <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.End"/> has different granularity.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.GetUnitOfTimeKind(OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Gets the kind of the unit-of-time used in a reporting period.
            </summary>
            <param name="reportingPeriod">The reporting period.</param>
            <returns>
            The kind of the unit-of-time used in the specified reporting period.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.HasComponentWithUnboundedGranularity(OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Determines if the reporting period has a component with unbounded granularity.
            </summary>
            <param name="reportingPeriod">The reporting period.</param>
            <returns>
            true if one or both components of the reporting period has unbounded granularity; otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.GetUnitsWithin(OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Gets the distinct units-of-time contained within a specified reporting period.
            For example, a reporting period of 2Q2017-4Q2017, contains 2Q2017, 3Q2017, and 4Q2017.
            </summary>
            <remarks>
            The endpoints are considered units within the reporting period.
            </remarks>
            <param name="reportingPeriod">The reporting period.</param>
            <returns>
            The units-of-time contained within the specified reporting period.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="reportingPeriod"/> <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.Start"/> and/or <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.End"/> is unbounded.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.DeserializeFromString(System.String)">
            <summary>
            Deserializes a <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod"/> from a string.
            </summary>
            <param name="reportingPeriod">The serialized reporting period string to deserialize.</param>
            <returns>
            Gets a reporting period deserialized from it's string representation.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="reportingPeriod"/> is whitespace.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot deserialize string; it is not valid reporting period.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodExtensions.SerializeToString(OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Serializes a <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod"/> to a string.
            </summary>
            <param name="reportingPeriod">The reporting period to serialize.</param>
            <returns>
            Gets a string representation of a reporting period that can be deserialized
            into the same reporting period.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reportingPeriod"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.UnitOfTimeExtensions">
            <summary>
            Conversion-related extension methods on <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/>.
            </summary>
            <summary>
            Property-related extension methods on <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/>.
            </summary>
            <summary>
            Math-related extension methods on <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/>.
            </summary>
            <summary>
            Serialization-related extension methods on <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.ToCalendarQuarter(OBeautifulCode.AccountingTime.FiscalQuarter,OBeautifulCode.AccountingTime.QuarterNumber)">
            <summary>
            Converts a <see cref="T:OBeautifulCode.AccountingTime.CalendarQuarter"/> to a <see cref="T:OBeautifulCode.AccountingTime.FiscalQuarter"/>.
            </summary>
            <param name="fiscalQuarter">The fiscal quarter to convert.</param>
            <param name="calendarQuarterThatIsFirstFiscalQuarter">The calendar quarter that is associated with the first fiscal quarter for the company.</param>
            <returns>
            The calendar quarter associated with the specified fiscal quarter.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fiscalQuarter"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="calendarQuarterThatIsFirstFiscalQuarter"/> is <see cref="F:OBeautifulCode.AccountingTime.QuarterNumber.Invalid"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.ToFiscalQuarter(OBeautifulCode.AccountingTime.CalendarQuarter,OBeautifulCode.AccountingTime.QuarterNumber)">
            <summary>
            Converts a <see cref="T:OBeautifulCode.AccountingTime.FiscalQuarter"/> to a <see cref="T:OBeautifulCode.AccountingTime.CalendarQuarter"/>.
            </summary>
            <param name="calendarQuarter">The calendar quarter to convert.</param>
            <param name="calendarQuarterThatIsFirstFiscalQuarter">The calendar quarter that is associated with the first fiscal quarter for the company.</param>
            <returns>
            The fiscal quarter associated with the specified calendar quarter.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="calendarQuarter"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="calendarQuarterThatIsFirstFiscalQuarter"/> is <see cref="F:OBeautifulCode.AccountingTime.QuarterNumber.Invalid"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.ToGenericMonth(OBeautifulCode.AccountingTime.IHaveAMonth)">
            <summary>
            Converts the specified <see cref="T:OBeautifulCode.AccountingTime.IHaveAMonth"/> to a <see cref="T:OBeautifulCode.AccountingTime.GenericMonth"/>.
            </summary>
            <param name="month">The month to convert.</param>
            <returns>
            A <see cref="T:OBeautifulCode.AccountingTime.GenericMonth"/> converted from an <see cref="T:OBeautifulCode.AccountingTime.IHaveAMonth"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="month"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.ToGenericQuarter(OBeautifulCode.AccountingTime.IHaveAQuarter)">
            <summary>
            Converts the specified <see cref="T:OBeautifulCode.AccountingTime.IHaveAQuarter"/> to a <see cref="T:OBeautifulCode.AccountingTime.GenericQuarter"/>.
            </summary>
            <param name="quarter">The quarter to convert.</param>
            <returns>
            A <see cref="T:OBeautifulCode.AccountingTime.GenericQuarter"/> converted from an <see cref="T:OBeautifulCode.AccountingTime.IHaveAQuarter"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="quarter"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.ToGenericYear(OBeautifulCode.AccountingTime.IHaveAYear)">
            <summary>
            Converts the specified <see cref="T:OBeautifulCode.AccountingTime.IHaveAYear"/> to a <see cref="T:OBeautifulCode.AccountingTime.GenericYear"/>.
            </summary>
            <param name="year">The year to convert.</param>
            <returns>
            A <see cref="T:OBeautifulCode.AccountingTime.GenericYear"/> converted from an <see cref="T:OBeautifulCode.AccountingTime.IHaveAYear"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="year"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.ToMostGranular(OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Converts the the specified unit-of-time into the most
            granular possible, but equivalent, reporting period.
            </summary>
            <param name="unitOfTime">The unit-of-time to operate on.</param>
            <returns>
            A reporting period that addresses the same set of time as <paramref name="unitOfTime"/>,
            but is the most granular version possible of that unit-of-time.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="unitOfTime"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.ToReportingPeriod(OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Creates a reporting period from a unit-of-time.
            </summary>
            <param name="unitOfTime">The unit-of-time to use in the reporting period.</param>
            <returns>
            A reporting period where the Start and End components are equal to the specified unit-of-time.
            </returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.GetFirstCalendarDay(OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <summary>
            Gets the first calendar day in the specified calendar-based unit-of-time.
            </summary>
            <param name="unitOfTime">The unit-of-time.</param>
            <returns>
            The first calendar day in the specified calendar-based unit-of-time.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="unitOfTime"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="unitOfTime"/> is unbounded.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.GetLastCalendarDay(OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <summary>
            Gets the last calendar day in the specified calendar-based unit-of-time.
            </summary>
            <param name="unitOfTime">The unit-of-time.</param>
            <returns>
            The last calendar day in the specified calendar-based unit-of-time.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="unitOfTime"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="unitOfTime"/> is unbounded.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.GetUnitsToDate``1(``0)">
            <summary>
            Gets a list with the first <typeparamref name="T"/> in the same year as <paramref name="lastUnitOfTimeInYear"/>,
            up to and including <paramref name="lastUnitOfTimeInYear"/>, in sequential/ascending order.
            </summary>
            <param name="lastUnitOfTimeInYear">The last unit-of-time.</param>
            <typeparam name="T">The type of the unit-of-time.</typeparam>
            <returns>
            A list with the first <typeparamref name="T"/> in the same year as <paramref name="lastUnitOfTimeInYear"/>,
            up to and including <paramref name="lastUnitOfTimeInYear"/>, in sequential/ascending order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="lastUnitOfTimeInYear"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.Plus(OBeautifulCode.AccountingTime.UnitOfTime,System.Int32)">
            <summary>
            Adds the specified number of units to a unit-of-time.
            </summary>
            <param name="unitOfTime">The unit-of-time to add to.</param>
            <param name="unitsToAdd">The number of units to add (use negative numbers to subtract units).</param>
            <returns>
            The result of adding the specified number of units to the specified units-of-time.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="unitOfTime"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="unitOfTime"/> is unbounded.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.Plus(OBeautifulCode.AccountingTime.UnitOfTime,System.Int32,OBeautifulCode.AccountingTime.UnitOfTimeGranularity)">
            <summary>
            Adds the specified number of units of a specified granularity to a unit-of-time.
            </summary>
            <param name="unitOfTime">The unit-of-time to add to.</param>
            <param name="unitsToAdd">The number of units to add (use negative numbers to subtract units).</param>
            <param name="granularityOfUnitsToAdd">The granularity of the units to add.  Must be as or less granular than the <paramref name="unitOfTime"/> (e.g. can add CalendarYear to a CalendarQuarter, but not vice-versa).</param>
            <returns>
            The result of adding the specified number of units of the specified granularity to a unit-of-time.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="unitOfTime"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Cannot add or subtract from a unit-of-time whose granularity is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Unbounded"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="granularityOfUnitsToAdd"/> is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Invalid"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="granularityOfUnitsToAdd"/> is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Unbounded"/>.  Cannot add units of that granularity.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="granularityOfUnitsToAdd"/> is more granular than the <paramref name="unitOfTime"/>.  Only units that are as granular or less granular than a unit-of-time can be added to that unit-of-time.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.DeserializeFromSortableString``1(System.String)">
            <summary>
            Deserializes a <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> from a sortable string.
            </summary>
            <typeparam name="T">The type of unit-of-time.</typeparam>
            <param name="unitOfTime">The serialized, sortable unit-of-time string to deserialize.</param>
            <returns>
            Gets a unit-of-time deserialized from it's string representation.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="unitOfTime"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="unitOfTime"/> is whitespace.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot deserialize string; it is not valid unit-of-time.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.DeserializeFromSortableString(System.String,System.Type)">
            <summary>
            Deserializes a <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> from a sortable string.
            </summary>
            <param name="unitOfTime">The serialized, sortable unit-of-time string to deserialize.</param>
            <param name="type">Specific <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime" /> type to deserialize into.</param>
            <returns>
            Gets a unit-of-time deserialized from it's string representation.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="unitOfTime"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="unitOfTime"/> is whitespace.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot deserialize string; it is not valid unit-of-time.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeExtensions.SerializeToSortableString(OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Serializes a <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> to a sortable string.
            </summary>
            <param name="unitOfTime">The unit-of-time to serialize.</param>
            <returns>
            Gets a string representation of a unit-of-time that can be deserialized
            into the same unit-of-time and which sorts in the same way that the
            other unit-of-times (of the same type) would sort (earlier time first, later time last).
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="unitOfTime"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularityExtensions">
            <summary>
            Extension methods on type <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeGranularityExtensions.IsLessGranularThan(OBeautifulCode.AccountingTime.UnitOfTimeGranularity,OBeautifulCode.AccountingTime.UnitOfTimeGranularity)">
            <summary>
            Determines if a <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/> is less granular than another <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/>.
            </summary>
            <param name="granularity1">The first granularity to compare.</param>
            <param name="granularity2">The second granularity to compare.</param>
            <returns>
            true if the first <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/> is less granular than the second <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/>; false otherwise.
            </returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeGranularityExtensions.IsAsGranularOrLessGranularThan(OBeautifulCode.AccountingTime.UnitOfTimeGranularity,OBeautifulCode.AccountingTime.UnitOfTimeGranularity)">
            <summary>
            Determines if a <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/> is as granular or less granular than another <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/>.
            </summary>
            <param name="granularity1">The first granularity to compare.</param>
            <param name="granularity2">The second granularity to compare.</param>
            <returns>
            true if the first <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/> is as granular or less granular than the second <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/>; false otherwise.
            </returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeGranularityExtensions.IsMoreGranularThan(OBeautifulCode.AccountingTime.UnitOfTimeGranularity,OBeautifulCode.AccountingTime.UnitOfTimeGranularity)">
            <summary>
            Determines if a <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/> is more granular than another <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/>.
            </summary>
            <param name="granularity1">The first granularity to compare.</param>
            <param name="granularity2">The second granularity to compare.</param>
            <returns>
            true if the first <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/> is more granular than the second <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/>; false otherwise.
            </returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeGranularityExtensions.IsAsGranularOrMoreGranularThan(OBeautifulCode.AccountingTime.UnitOfTimeGranularity,OBeautifulCode.AccountingTime.UnitOfTimeGranularity)">
            <summary>
            Determines if a <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/> is as granular or more granular than another <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/>.
            </summary>
            <param name="granularity1">The first granularity to compare.</param>
            <param name="granularity2">The second granularity to compare.</param>
            <returns>
            true if the first <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/> is as granular or more granular than the second <see cref="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity"/>; false otherwise.
            </returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeGranularityExtensions.IsMostGranular(OBeautifulCode.AccountingTime.UnitOfTimeGranularity)">
            <summary>
            Determines if a specified granularity is the most granular one available.
            </summary>
            <param name="granularity">The granularity.</param>
            <returns>
            true if the specified granularity is the most granular one available, false otherwise.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="granularity"/> is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Invalid"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeGranularityExtensions.IsLeastGranular(OBeautifulCode.AccountingTime.UnitOfTimeGranularity)">
            <summary>
            Determines if a specified granularity is the least granular one available.
            </summary>
            <param name="granularity">The granularity.</param>
            <returns>
            true if the specified granularity is the least granular one available, false otherwise.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="granularity"/> is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Invalid"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeGranularityExtensions.OneNotchMoreGranular(OBeautifulCode.AccountingTime.UnitOfTimeGranularity)">
            <summary>
            Gets the granularity that is one notch more granular than the specified granularity.
            </summary>
            <param name="granularity">The granularity.</param>
            <returns>
            The granularity that is one notch more granular than the specified granuliarty.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="granularity"/> is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Invalid"/>.</exception>
            <exception cref="T:System.ArgumentException">No granularity is more granular than <paramref name="granularity"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeGranularityExtensions.OneNotchLessGranular(OBeautifulCode.AccountingTime.UnitOfTimeGranularity)">
            <summary>
            Gets the granularity that is one notch less granular than the specified granularity.
            </summary>
            <param name="granularity">The granularity.</param>
            <returns>
            The granularity that is one notch less granular than the specified granuliarty.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="granularity"/> is <see cref="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Invalid"/>.</exception>
            <exception cref="T:System.ArgumentException">No granularity is less granular than <paramref name="granularity"/>.</exception>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.ProjectInfo">
            <summary>
            Project-related information.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.ProjectInfo.Namespace">
            <summary>
            The namespace used by types in this project.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.ProjectInfo.Assembly">
            <summary>
            The assembly produced by this project.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.ReportingPeriod">
            <summary>
            Represents a range of time over which to report, inclusive of the endpoints.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriod.op_Equality(OBeautifulCode.AccountingTime.ReportingPeriod,OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriod.op_Inequality(OBeautifulCode.AccountingTime.ReportingPeriod,OBeautifulCode.AccountingTime.ReportingPeriod)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriod.Equals(OBeautifulCode.AccountingTime.ReportingPeriod)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriod.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriod.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriod.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriod.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriod.DeepCloneWithStart(OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.Start" />.
            </summary>
            <param name="start">The new <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.Start" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod" /> using the specified <paramref name="start" /> for <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.Start" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriod.DeepCloneWithEnd(OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.End" />.
            </summary>
            <param name="end">The new <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.End" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod" /> using the specified <paramref name="end" /> for <see cref="P:OBeautifulCode.AccountingTime.ReportingPeriod.End" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriod.#ctor(OBeautifulCode.AccountingTime.UnitOfTime,OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod"/> class.
            </summary>
            <param name="start">The start of the reporting period.</param>
            <param name="end">The end of the reporting period.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="start"/> or <paramref name="end"/> are null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> are bounded and are different concrete types of units-of-time.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and/or <paramref name="end"/> is unbounded and are different kinds of units-of-time.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> is greater than <paramref name="end"/>.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.ReportingPeriod.Start">
            <summary>
            Gets the start of the reporting period.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.ReportingPeriod.End">
            <summary>
            Gets the end of the reporting period.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriod.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString"/>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.ReportingPeriodComponent">
            <summary>
            Represents the start, end, or both, of a reporting period.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.ReportingPeriodComponent.Invalid">
            <summary>
            Invalid reporting period component.
            </summary>
            <remarks>
            This is required so that there is a default value for the enum.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.ReportingPeriodComponent.Start">
            <summary>
            The start of a reporting period.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.ReportingPeriodComponent.End">
            <summary>
            The end of a reporting period.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.ReportingPeriodComponent.Both">
            <summary>
            Both the start and the end of a reporting period.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.UnitOfTimeStringSerializer">
            <summary>
            String serialize for <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeStringSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeStringSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTimeStringSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.ReportingPeriodStringSerializer">
            <summary>
            String serialize for <see cref="T:OBeautifulCode.AccountingTime.ReportingPeriod"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodStringSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodStringSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.ReportingPeriodStringSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.TypeHelper">
            <summary>
            Provides helper methods related to account time types.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.TypeHelper.GetAllUnitOfTimeTypes">
            <summary>
            Gets all <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> types (that type along with all subclasses).
            </summary>
            <returns>
            All <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> types.
            </returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.TypeHelper.IsUnitOfTimeType(System.Type)">
            <summary>
            Checks to see if the type provided is a <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime" />.
            </summary>
            <param name="type">Type to check.</param>
            <returns>A value indicating whether or not it's a valid type.</returns>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.CalendarDay">
            <summary>
            Represents a calendar day.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.#ctor(System.Int32,OBeautifulCode.AccountingTime.MonthOfYear,OBeautifulCode.AccountingTime.DayOfMonth)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.CalendarDay"/> class.
            </summary>
            <param name="year">The year.</param>
            <param name="monthOfYear">The month of the year.</param>
            <param name="dayOfMonth">The day of the month.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year"/> is less than 1 or greater than 9999.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="monthOfYear"/> is invalid.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="dayOfMonth"/> is invalid.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="dayOfMonth"/> is not a valid day in the specified <paramref name="monthOfYear"/> and <paramref name="year"/>.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarDay.Year">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarDay.MonthOfYear">
            <summary>
            Gets the month of the year.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarDay.DayOfMonth">
            <summary>
            Gets the day of the month.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarDay.MonthNumber">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarDay.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.CalendarDay)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.ToDateTime">
            <summary>
            Converts this calendar day to an object of type <see cref="T:System.DateTime"/>.
            </summary>
            <returns>
            Gets a <see cref="T:System.DateTime"/> version of this calendar day.
            </returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.op_Equality(OBeautifulCode.AccountingTime.CalendarDay,OBeautifulCode.AccountingTime.CalendarDay)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarDay"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.op_Inequality(OBeautifulCode.AccountingTime.CalendarDay,OBeautifulCode.AccountingTime.CalendarDay)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarDay"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.Equals(OBeautifulCode.AccountingTime.CalendarDay)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.op_LessThan(OBeautifulCode.AccountingTime.CalendarDay,OBeautifulCode.AccountingTime.CalendarDay)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarDay"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.op_GreaterThan(OBeautifulCode.AccountingTime.CalendarDay,OBeautifulCode.AccountingTime.CalendarDay)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarDay"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.op_LessThanOrEqual(OBeautifulCode.AccountingTime.CalendarDay,OBeautifulCode.AccountingTime.CalendarDay)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarDay"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.CalendarDay,OBeautifulCode.AccountingTime.CalendarDay)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarDay"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.CompareTo(OBeautifulCode.AccountingTime.CalendarDay)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.DeepCloneWithYear(System.Int32)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.CalendarDay.Year" />.
            </summary>
            <param name="year">The new <see cref="P:OBeautifulCode.AccountingTime.CalendarDay.Year" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.CalendarDay" /> using the specified <paramref name="year" /> for <see cref="P:OBeautifulCode.AccountingTime.CalendarDay.Year" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.DeepCloneWithMonthOfYear(OBeautifulCode.AccountingTime.MonthOfYear)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.CalendarDay.MonthOfYear" />.
            </summary>
            <param name="monthOfYear">The new <see cref="P:OBeautifulCode.AccountingTime.CalendarDay.MonthOfYear" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.CalendarDay" /> using the specified <paramref name="monthOfYear" /> for <see cref="P:OBeautifulCode.AccountingTime.CalendarDay.MonthOfYear" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.DeepCloneWithDayOfMonth(OBeautifulCode.AccountingTime.DayOfMonth)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.CalendarDay.DayOfMonth" />.
            </summary>
            <param name="dayOfMonth">The new <see cref="P:OBeautifulCode.AccountingTime.CalendarDay.DayOfMonth" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.CalendarDay" /> using the specified <paramref name="dayOfMonth" /> for <see cref="P:OBeautifulCode.AccountingTime.CalendarDay.DayOfMonth" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarDay.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.CalendarMonth">
            <summary>
            Represents a calendar month in a specified year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.op_Equality(OBeautifulCode.AccountingTime.CalendarMonth,OBeautifulCode.AccountingTime.CalendarMonth)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarMonth"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.op_Inequality(OBeautifulCode.AccountingTime.CalendarMonth,OBeautifulCode.AccountingTime.CalendarMonth)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarMonth"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.Equals(OBeautifulCode.AccountingTime.CalendarMonth)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.op_LessThan(OBeautifulCode.AccountingTime.CalendarMonth,OBeautifulCode.AccountingTime.CalendarMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarMonth"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.op_GreaterThan(OBeautifulCode.AccountingTime.CalendarMonth,OBeautifulCode.AccountingTime.CalendarMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarMonth"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.op_LessThanOrEqual(OBeautifulCode.AccountingTime.CalendarMonth,OBeautifulCode.AccountingTime.CalendarMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarMonth"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.CalendarMonth,OBeautifulCode.AccountingTime.CalendarMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarMonth"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.CompareTo(OBeautifulCode.AccountingTime.CalendarMonth)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.DeepCloneWithYear(System.Int32)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.CalendarMonth.Year" />.
            </summary>
            <param name="year">The new <see cref="P:OBeautifulCode.AccountingTime.CalendarMonth.Year" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.CalendarMonth" /> using the specified <paramref name="year" /> for <see cref="P:OBeautifulCode.AccountingTime.CalendarMonth.Year" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.DeepCloneWithMonthOfYear(OBeautifulCode.AccountingTime.MonthOfYear)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.CalendarMonth.MonthOfYear" />.
            </summary>
            <param name="monthOfYear">The new <see cref="P:OBeautifulCode.AccountingTime.CalendarMonth.MonthOfYear" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.CalendarMonth" /> using the specified <paramref name="monthOfYear" /> for <see cref="P:OBeautifulCode.AccountingTime.CalendarMonth.MonthOfYear" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.#ctor(System.Int32,OBeautifulCode.AccountingTime.MonthOfYear)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.CalendarMonth"/> class.
            </summary>
            <param name="year">The year.</param>
            <param name="monthOfYear">The month of the year.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year"/> is less than 1 or greater than 9999.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="monthOfYear"/> is invalid.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarMonth.Year">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarMonth.MonthOfYear">
            <summary>
            Gets the month of the year.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarMonth.MonthNumber">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarMonth.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.CalendarMonth)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarMonth.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString" />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.CalendarQuarter">
            <summary>
            Represents a calendar quarter of a specified year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.op_Equality(OBeautifulCode.AccountingTime.CalendarQuarter,OBeautifulCode.AccountingTime.CalendarQuarter)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarQuarter"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.op_Inequality(OBeautifulCode.AccountingTime.CalendarQuarter,OBeautifulCode.AccountingTime.CalendarQuarter)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarQuarter"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.Equals(OBeautifulCode.AccountingTime.CalendarQuarter)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.op_LessThan(OBeautifulCode.AccountingTime.CalendarQuarter,OBeautifulCode.AccountingTime.CalendarQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarQuarter"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.op_GreaterThan(OBeautifulCode.AccountingTime.CalendarQuarter,OBeautifulCode.AccountingTime.CalendarQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarQuarter"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.op_LessThanOrEqual(OBeautifulCode.AccountingTime.CalendarQuarter,OBeautifulCode.AccountingTime.CalendarQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarQuarter"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.CalendarQuarter,OBeautifulCode.AccountingTime.CalendarQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarQuarter"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.CompareTo(OBeautifulCode.AccountingTime.CalendarQuarter)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.DeepCloneWithQuarterNumber(OBeautifulCode.AccountingTime.QuarterNumber)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.CalendarQuarter.QuarterNumber" />.
            </summary>
            <param name="quarterNumber">The new <see cref="P:OBeautifulCode.AccountingTime.CalendarQuarter.QuarterNumber" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.CalendarQuarter" /> using the specified <paramref name="quarterNumber" /> for <see cref="P:OBeautifulCode.AccountingTime.CalendarQuarter.QuarterNumber" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.DeepCloneWithYear(System.Int32)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.CalendarQuarter.Year" />.
            </summary>
            <param name="year">The new <see cref="P:OBeautifulCode.AccountingTime.CalendarQuarter.Year" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.CalendarQuarter" /> using the specified <paramref name="year" /> for <see cref="P:OBeautifulCode.AccountingTime.CalendarQuarter.Year" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.#ctor(System.Int32,OBeautifulCode.AccountingTime.QuarterNumber)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.CalendarQuarter"/> class.
            </summary>
            <param name="year">The year.</param>
            <param name="quarterNumber">The quarter number.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year"/> is less than 1 or greater than 9999.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="quarterNumber"/> is invalid.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarQuarter.QuarterNumber">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarQuarter.Year">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarQuarter.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.CalendarQuarter)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarQuarter.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString" />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.CalendarUnbounded">
            <summary>
            Represents an unbounded calendar unit-of-time.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.op_Equality(OBeautifulCode.AccountingTime.CalendarUnbounded,OBeautifulCode.AccountingTime.CalendarUnbounded)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnbounded"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.op_Inequality(OBeautifulCode.AccountingTime.CalendarUnbounded,OBeautifulCode.AccountingTime.CalendarUnbounded)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnbounded"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.Equals(OBeautifulCode.AccountingTime.CalendarUnbounded)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.op_LessThan(OBeautifulCode.AccountingTime.CalendarUnbounded,OBeautifulCode.AccountingTime.CalendarUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnbounded"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.op_GreaterThan(OBeautifulCode.AccountingTime.CalendarUnbounded,OBeautifulCode.AccountingTime.CalendarUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnbounded"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.op_LessThanOrEqual(OBeautifulCode.AccountingTime.CalendarUnbounded,OBeautifulCode.AccountingTime.CalendarUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnbounded"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.CalendarUnbounded,OBeautifulCode.AccountingTime.CalendarUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnbounded"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.CompareTo(OBeautifulCode.AccountingTime.CalendarUnbounded)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarUnbounded.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.CalendarUnbounded)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnbounded.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString" />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.CalendarUnitOfTime">
            <summary>
            Represents a unit of time tied to the (gregorian) calendar.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.op_Equality(OBeautifulCode.AccountingTime.CalendarUnitOfTime,OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnitOfTime"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.op_Inequality(OBeautifulCode.AccountingTime.CalendarUnitOfTime,OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnitOfTime"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.Equals(OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.op_LessThan(OBeautifulCode.AccountingTime.CalendarUnitOfTime,OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnitOfTime"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.op_GreaterThan(OBeautifulCode.AccountingTime.CalendarUnitOfTime,OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnitOfTime"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.op_LessThanOrEqual(OBeautifulCode.AccountingTime.CalendarUnitOfTime,OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnitOfTime"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.CalendarUnitOfTime,OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarUnitOfTime"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.CompareTo(OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarUnitOfTime.ToString">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarUnitOfTime.UnitOfTimeKind">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.CalendarYear">
            <summary>
            Represents a calendar year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.op_Equality(OBeautifulCode.AccountingTime.CalendarYear,OBeautifulCode.AccountingTime.CalendarYear)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarYear"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.op_Inequality(OBeautifulCode.AccountingTime.CalendarYear,OBeautifulCode.AccountingTime.CalendarYear)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.CalendarYear"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.Equals(OBeautifulCode.AccountingTime.CalendarYear)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.op_LessThan(OBeautifulCode.AccountingTime.CalendarYear,OBeautifulCode.AccountingTime.CalendarYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarYear"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.op_GreaterThan(OBeautifulCode.AccountingTime.CalendarYear,OBeautifulCode.AccountingTime.CalendarYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarYear"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.op_LessThanOrEqual(OBeautifulCode.AccountingTime.CalendarYear,OBeautifulCode.AccountingTime.CalendarYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarYear"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.CalendarYear,OBeautifulCode.AccountingTime.CalendarYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.CalendarYear"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.CompareTo(OBeautifulCode.AccountingTime.CalendarYear)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.CalendarUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.DeepCloneWithYear(System.Int32)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.CalendarYear.Year" />.
            </summary>
            <param name="year">The new <see cref="P:OBeautifulCode.AccountingTime.CalendarYear.Year" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.CalendarYear" /> using the specified <paramref name="year" /> for <see cref="P:OBeautifulCode.AccountingTime.CalendarYear.Year" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.CalendarYear"/> class.
            </summary>
            <param name="year">The year.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year"/> is less than 1 or greater than 9999.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarYear.Year">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.CalendarYear.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.CalendarYear)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.CalendarYear.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString"/>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.DayOfMonth">
            <summary>
            A month number.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Invalid">
            <summary>
            An invalid day.
            </summary>
            <remarks>
            This is required so that there is a default value for the enum.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.One">
            <summary>
            Day 1.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Two">
            <summary>
            Day 2.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Three">
            <summary>
            Day 3.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Four">
            <summary>
            Day 4.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Five">
            <summary>
            Day 5.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Six">
            <summary>
            Day 6.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Seven">
            <summary>
            Day 7.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Eight">
            <summary>
            Day 8.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Nine">
            <summary>
            Day 9.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Ten">
            <summary>
            Day 10.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Eleven">
            <summary>
            Day 11.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Twelve">
            <summary>
            Day 12.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Thirteen">
            <summary>
            Day 13.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Fourteen">
            <summary>
            Day 14.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Fifteen">
            <summary>
            Day 15.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Sixteen">
            <summary>
            Day 16.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Seventeen">
            <summary>
            Day 17.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Eighteen">
            <summary>
            Day 18.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Nineteen">
            <summary>
            Day 19.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Twenty">
            <summary>
            Day 20.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.TwentyOne">
            <summary>
            Day 21.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.TwentyTwo">
            <summary>
            Day 22.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.TwentyThree">
            <summary>
            Day 23.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.TwentyFour">
            <summary>
            Day 24.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.TwentyFive">
            <summary>
            Day 25.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.TwentySix">
            <summary>
            Day 26.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.TwentySeven">
            <summary>
            Day 27.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.TwentyEight">
            <summary>
            Day 28.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.TwentyNine">
            <summary>
            Day 29.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.Thirty">
            <summary>
            Day 30.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.DayOfMonth.ThirtyOne">
            <summary>
            Day 31.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.FiscalMonth">
            <summary>
            Represents a fiscal month in a specified year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.#ctor(System.Int32,OBeautifulCode.AccountingTime.MonthNumber)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.FiscalMonth"/> class.
            </summary>
            <param name="year">The year.</param>
            <param name="monthNumber">The month number.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year"/> is less than 1 or greater than 9999.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="monthNumber"/> is invalid.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiscalMonth.Year">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiscalMonth.MonthNumber">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiscalMonth.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.FiscalMonth)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.op_Equality(OBeautifulCode.AccountingTime.FiscalMonth,OBeautifulCode.AccountingTime.FiscalMonth)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalMonth"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.op_Inequality(OBeautifulCode.AccountingTime.FiscalMonth,OBeautifulCode.AccountingTime.FiscalMonth)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalMonth"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.Equals(OBeautifulCode.AccountingTime.FiscalMonth)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.op_LessThan(OBeautifulCode.AccountingTime.FiscalMonth,OBeautifulCode.AccountingTime.FiscalMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalMonth"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.op_GreaterThan(OBeautifulCode.AccountingTime.FiscalMonth,OBeautifulCode.AccountingTime.FiscalMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalMonth"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.op_LessThanOrEqual(OBeautifulCode.AccountingTime.FiscalMonth,OBeautifulCode.AccountingTime.FiscalMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalMonth"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.FiscalMonth,OBeautifulCode.AccountingTime.FiscalMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalMonth"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.CompareTo(OBeautifulCode.AccountingTime.FiscalMonth)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.DeepCloneWithYear(System.Int32)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.FiscalMonth.Year" />.
            </summary>
            <param name="year">The new <see cref="P:OBeautifulCode.AccountingTime.FiscalMonth.Year" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.FiscalMonth" /> using the specified <paramref name="year" /> for <see cref="P:OBeautifulCode.AccountingTime.FiscalMonth.Year" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.DeepCloneWithMonthNumber(OBeautifulCode.AccountingTime.MonthNumber)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.FiscalMonth.MonthNumber" />.
            </summary>
            <param name="monthNumber">The new <see cref="P:OBeautifulCode.AccountingTime.FiscalMonth.MonthNumber" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.FiscalMonth" /> using the specified <paramref name="monthNumber" /> for <see cref="P:OBeautifulCode.AccountingTime.FiscalMonth.MonthNumber" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalMonth.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.FiscalQuarter">
            <summary>
            Represents a fiscal quarter of a specified year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.#ctor(System.Int32,OBeautifulCode.AccountingTime.QuarterNumber)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.FiscalQuarter"/> class.
            </summary>
            <param name="year">The year.</param>
            <param name="quarterNumber">The quarter number.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year"/> is less than 1 or greater than 9999.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="quarterNumber"/> is invalid.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiscalQuarter.QuarterNumber">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiscalQuarter.Year">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiscalQuarter.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.FiscalQuarter)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.op_Equality(OBeautifulCode.AccountingTime.FiscalQuarter,OBeautifulCode.AccountingTime.FiscalQuarter)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalQuarter"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.op_Inequality(OBeautifulCode.AccountingTime.FiscalQuarter,OBeautifulCode.AccountingTime.FiscalQuarter)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalQuarter"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.Equals(OBeautifulCode.AccountingTime.FiscalQuarter)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.op_LessThan(OBeautifulCode.AccountingTime.FiscalQuarter,OBeautifulCode.AccountingTime.FiscalQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalQuarter"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.op_GreaterThan(OBeautifulCode.AccountingTime.FiscalQuarter,OBeautifulCode.AccountingTime.FiscalQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalQuarter"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.op_LessThanOrEqual(OBeautifulCode.AccountingTime.FiscalQuarter,OBeautifulCode.AccountingTime.FiscalQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalQuarter"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.FiscalQuarter,OBeautifulCode.AccountingTime.FiscalQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalQuarter"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.CompareTo(OBeautifulCode.AccountingTime.FiscalQuarter)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.DeepCloneWithQuarterNumber(OBeautifulCode.AccountingTime.QuarterNumber)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.FiscalQuarter.QuarterNumber" />.
            </summary>
            <param name="quarterNumber">The new <see cref="P:OBeautifulCode.AccountingTime.FiscalQuarter.QuarterNumber" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.FiscalQuarter" /> using the specified <paramref name="quarterNumber" /> for <see cref="P:OBeautifulCode.AccountingTime.FiscalQuarter.QuarterNumber" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.DeepCloneWithYear(System.Int32)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.FiscalQuarter.Year" />.
            </summary>
            <param name="year">The new <see cref="P:OBeautifulCode.AccountingTime.FiscalQuarter.Year" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.FiscalQuarter" /> using the specified <paramref name="year" /> for <see cref="P:OBeautifulCode.AccountingTime.FiscalQuarter.Year" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalQuarter.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.FiscalUnbounded">
            <summary>
            Represents an unbounded fiscal unit-of-time.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiscalUnbounded.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.FiscalUnbounded)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString"/>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.op_Equality(OBeautifulCode.AccountingTime.FiscalUnbounded,OBeautifulCode.AccountingTime.FiscalUnbounded)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnbounded"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.op_Inequality(OBeautifulCode.AccountingTime.FiscalUnbounded,OBeautifulCode.AccountingTime.FiscalUnbounded)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnbounded"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.Equals(OBeautifulCode.AccountingTime.FiscalUnbounded)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.op_LessThan(OBeautifulCode.AccountingTime.FiscalUnbounded,OBeautifulCode.AccountingTime.FiscalUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnbounded"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.op_GreaterThan(OBeautifulCode.AccountingTime.FiscalUnbounded,OBeautifulCode.AccountingTime.FiscalUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnbounded"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.op_LessThanOrEqual(OBeautifulCode.AccountingTime.FiscalUnbounded,OBeautifulCode.AccountingTime.FiscalUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnbounded"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.FiscalUnbounded,OBeautifulCode.AccountingTime.FiscalUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnbounded"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.CompareTo(OBeautifulCode.AccountingTime.FiscalUnbounded)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnbounded.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.FiscalUnitOfTime">
            <summary>
            Represents a unit of time in the context of some company's fiscal year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.op_Equality(OBeautifulCode.AccountingTime.FiscalUnitOfTime,OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnitOfTime"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.op_Inequality(OBeautifulCode.AccountingTime.FiscalUnitOfTime,OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnitOfTime"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.Equals(OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.op_LessThan(OBeautifulCode.AccountingTime.FiscalUnitOfTime,OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnitOfTime"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.op_GreaterThan(OBeautifulCode.AccountingTime.FiscalUnitOfTime,OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnitOfTime"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.op_LessThanOrEqual(OBeautifulCode.AccountingTime.FiscalUnitOfTime,OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnitOfTime"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.FiscalUnitOfTime,OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalUnitOfTime"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.CompareTo(OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalUnitOfTime.ToString">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiscalUnitOfTime.UnitOfTimeKind">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.FiscalYear">
            <summary>
            Represents a fiscal year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.FiscalYear"/> class.
            </summary>
            <param name="year">The year.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year"/> is less than 1 or greater than 9999.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiscalYear.Year">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.FiscalYear.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.FiscalYear)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.op_Equality(OBeautifulCode.AccountingTime.FiscalYear,OBeautifulCode.AccountingTime.FiscalYear)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalYear"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.op_Inequality(OBeautifulCode.AccountingTime.FiscalYear,OBeautifulCode.AccountingTime.FiscalYear)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.FiscalYear"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.Equals(OBeautifulCode.AccountingTime.FiscalYear)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.op_LessThan(OBeautifulCode.AccountingTime.FiscalYear,OBeautifulCode.AccountingTime.FiscalYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalYear"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.op_GreaterThan(OBeautifulCode.AccountingTime.FiscalYear,OBeautifulCode.AccountingTime.FiscalYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalYear"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.op_LessThanOrEqual(OBeautifulCode.AccountingTime.FiscalYear,OBeautifulCode.AccountingTime.FiscalYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalYear"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.FiscalYear,OBeautifulCode.AccountingTime.FiscalYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.FiscalYear"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.CompareTo(OBeautifulCode.AccountingTime.FiscalYear)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.FiscalUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.DeepCloneWithYear(System.Int32)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.FiscalYear.Year" />.
            </summary>
            <param name="year">The new <see cref="P:OBeautifulCode.AccountingTime.FiscalYear.Year" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.FiscalYear" /> using the specified <paramref name="year" /> for <see cref="P:OBeautifulCode.AccountingTime.FiscalYear.Year" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.FiscalYear.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.GenericMonth">
            <summary>
            Represents a generic month in a specified year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.#ctor(System.Int32,OBeautifulCode.AccountingTime.MonthNumber)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.GenericMonth"/> class.
            </summary>
            <param name="year">The year.</param>
            <param name="monthNumber">The month number.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year"/> is less than 1 or greater than 9999.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="monthNumber"/> is invalid.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.GenericMonth.Year">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.GenericMonth.MonthNumber">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.GenericMonth.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.GenericMonth)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.op_Equality(OBeautifulCode.AccountingTime.GenericMonth,OBeautifulCode.AccountingTime.GenericMonth)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.GenericMonth"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.op_Inequality(OBeautifulCode.AccountingTime.GenericMonth,OBeautifulCode.AccountingTime.GenericMonth)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.GenericMonth"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.Equals(OBeautifulCode.AccountingTime.GenericMonth)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.op_LessThan(OBeautifulCode.AccountingTime.GenericMonth,OBeautifulCode.AccountingTime.GenericMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericMonth"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.op_GreaterThan(OBeautifulCode.AccountingTime.GenericMonth,OBeautifulCode.AccountingTime.GenericMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericMonth"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.op_LessThanOrEqual(OBeautifulCode.AccountingTime.GenericMonth,OBeautifulCode.AccountingTime.GenericMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericMonth"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.GenericMonth,OBeautifulCode.AccountingTime.GenericMonth)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericMonth"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.CompareTo(OBeautifulCode.AccountingTime.GenericMonth)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.DeepCloneWithYear(System.Int32)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.GenericMonth.Year" />.
            </summary>
            <param name="year">The new <see cref="P:OBeautifulCode.AccountingTime.GenericMonth.Year" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.GenericMonth" /> using the specified <paramref name="year" /> for <see cref="P:OBeautifulCode.AccountingTime.GenericMonth.Year" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.DeepCloneWithMonthNumber(OBeautifulCode.AccountingTime.MonthNumber)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.GenericMonth.MonthNumber" />.
            </summary>
            <param name="monthNumber">The new <see cref="P:OBeautifulCode.AccountingTime.GenericMonth.MonthNumber" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.GenericMonth" /> using the specified <paramref name="monthNumber" /> for <see cref="P:OBeautifulCode.AccountingTime.GenericMonth.MonthNumber" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericMonth.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.GenericQuarter">
            <summary>
            Represents a generic quarter of a specified year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.#ctor(System.Int32,OBeautifulCode.AccountingTime.QuarterNumber)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.GenericQuarter"/> class.
            </summary>
            <param name="year">The year.</param>
            <param name="quarterNumber">The quarter number.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year"/> is less than 1 or greater than 9999.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="quarterNumber"/> is invalid.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.GenericQuarter.QuarterNumber">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.GenericQuarter.Year">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.GenericQuarter.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.GenericQuarter)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.op_Equality(OBeautifulCode.AccountingTime.GenericQuarter,OBeautifulCode.AccountingTime.GenericQuarter)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.GenericQuarter"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.op_Inequality(OBeautifulCode.AccountingTime.GenericQuarter,OBeautifulCode.AccountingTime.GenericQuarter)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.GenericQuarter"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.Equals(OBeautifulCode.AccountingTime.GenericQuarter)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.op_LessThan(OBeautifulCode.AccountingTime.GenericQuarter,OBeautifulCode.AccountingTime.GenericQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericQuarter"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.op_GreaterThan(OBeautifulCode.AccountingTime.GenericQuarter,OBeautifulCode.AccountingTime.GenericQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericQuarter"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.op_LessThanOrEqual(OBeautifulCode.AccountingTime.GenericQuarter,OBeautifulCode.AccountingTime.GenericQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericQuarter"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.GenericQuarter,OBeautifulCode.AccountingTime.GenericQuarter)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericQuarter"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.CompareTo(OBeautifulCode.AccountingTime.GenericQuarter)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.DeepCloneWithQuarterNumber(OBeautifulCode.AccountingTime.QuarterNumber)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.GenericQuarter.QuarterNumber" />.
            </summary>
            <param name="quarterNumber">The new <see cref="P:OBeautifulCode.AccountingTime.GenericQuarter.QuarterNumber" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.GenericQuarter" /> using the specified <paramref name="quarterNumber" /> for <see cref="P:OBeautifulCode.AccountingTime.GenericQuarter.QuarterNumber" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.DeepCloneWithYear(System.Int32)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.GenericQuarter.Year" />.
            </summary>
            <param name="year">The new <see cref="P:OBeautifulCode.AccountingTime.GenericQuarter.Year" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.GenericQuarter" /> using the specified <paramref name="year" /> for <see cref="P:OBeautifulCode.AccountingTime.GenericQuarter.Year" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericQuarter.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.GenericUnbounded">
            <summary>
            Represents an unbounded generic unit-of-time.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.GenericUnbounded.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.GenericUnbounded)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.op_Equality(OBeautifulCode.AccountingTime.GenericUnbounded,OBeautifulCode.AccountingTime.GenericUnbounded)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnbounded"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.op_Inequality(OBeautifulCode.AccountingTime.GenericUnbounded,OBeautifulCode.AccountingTime.GenericUnbounded)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnbounded"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.Equals(OBeautifulCode.AccountingTime.GenericUnbounded)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.op_LessThan(OBeautifulCode.AccountingTime.GenericUnbounded,OBeautifulCode.AccountingTime.GenericUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnbounded"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.op_GreaterThan(OBeautifulCode.AccountingTime.GenericUnbounded,OBeautifulCode.AccountingTime.GenericUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnbounded"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.op_LessThanOrEqual(OBeautifulCode.AccountingTime.GenericUnbounded,OBeautifulCode.AccountingTime.GenericUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnbounded"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.GenericUnbounded,OBeautifulCode.AccountingTime.GenericUnbounded)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnbounded"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.CompareTo(OBeautifulCode.AccountingTime.GenericUnbounded)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnbounded.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.GenericUnitOfTime">
            <summary>
            Represents a generic unit of time, without any context.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.op_Equality(OBeautifulCode.AccountingTime.GenericUnitOfTime,OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnitOfTime"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.op_Inequality(OBeautifulCode.AccountingTime.GenericUnitOfTime,OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnitOfTime"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.Equals(OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.op_LessThan(OBeautifulCode.AccountingTime.GenericUnitOfTime,OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnitOfTime"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.op_GreaterThan(OBeautifulCode.AccountingTime.GenericUnitOfTime,OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnitOfTime"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.op_LessThanOrEqual(OBeautifulCode.AccountingTime.GenericUnitOfTime,OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnitOfTime"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.GenericUnitOfTime,OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericUnitOfTime"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.CompareTo(OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericUnitOfTime.ToString">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.GenericUnitOfTime.UnitOfTimeKind">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.GenericYear">
            <summary>
            Represents a generic year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.AccountingTime.GenericYear"/> class.
            </summary>
            <param name="year">The year.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year"/> is less than 1 or greater than 9999.</exception>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.GenericYear.Year">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.GenericYear.UnitOfTimeGranularity">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.GenericYear)">
            <inheritdoc cref="T:OBeautifulCode.Type.IDeclareCompareToForRelativeSortOrderMethod`1" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.ToString">
            <inheritdoc cref="M:OBeautifulCode.Type.IDeclareToStringMethod.ToString" />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.op_Equality(OBeautifulCode.AccountingTime.GenericYear,OBeautifulCode.AccountingTime.GenericYear)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.GenericYear"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.op_Inequality(OBeautifulCode.AccountingTime.GenericYear,OBeautifulCode.AccountingTime.GenericYear)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.GenericYear"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.Equals(OBeautifulCode.AccountingTime.GenericYear)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.op_LessThan(OBeautifulCode.AccountingTime.GenericYear,OBeautifulCode.AccountingTime.GenericYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericYear"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.op_GreaterThan(OBeautifulCode.AccountingTime.GenericYear,OBeautifulCode.AccountingTime.GenericYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericYear"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.op_LessThanOrEqual(OBeautifulCode.AccountingTime.GenericYear,OBeautifulCode.AccountingTime.GenericYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericYear"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.GenericYear,OBeautifulCode.AccountingTime.GenericYear)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.GenericYear"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.CompareTo(OBeautifulCode.AccountingTime.GenericYear)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.GenericUnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.DeepCloneWithYear(System.Int32)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.AccountingTime.GenericYear.Year" />.
            </summary>
            <param name="year">The new <see cref="P:OBeautifulCode.AccountingTime.GenericYear.Year" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.AccountingTime.GenericYear" /> using the specified <paramref name="year" /> for <see cref="P:OBeautifulCode.AccountingTime.GenericYear.Year" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.GenericYear.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.AccountingTime.UnitOfTime">
            <summary>
            Represents a unit of time, such as a month, quarter, or year.
            </summary>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.op_Equality(OBeautifulCode.AccountingTime.UnitOfTime,OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.op_Inequality(OBeautifulCode.AccountingTime.UnitOfTime,OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.Equals(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.op_LessThan(OBeautifulCode.AccountingTime.UnitOfTime,OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> is less than another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than operator.</param>
            <param name="right">The object to the right of the less-than operator.</param>
            <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.op_GreaterThan(OBeautifulCode.AccountingTime.UnitOfTime,OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> is greater than another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than operator.</param>
            <param name="right">The object to the right of the greater-than operator.</param>
            <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.op_LessThanOrEqual(OBeautifulCode.AccountingTime.UnitOfTime,OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> is less than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.op_GreaterThanOrEqual(OBeautifulCode.AccountingTime.UnitOfTime,OBeautifulCode.AccountingTime.UnitOfTime)">
            <summary>
            Determines whether an object of type <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> is greater than or equal to another object of that type.
            </summary>
            <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
            <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
            <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.CompareTo(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.CompareToForRelativeSortOrder(OBeautifulCode.AccountingTime.UnitOfTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.DeepCloneInternal">
            <summary>
            Creates a new object that is a deep clone of this instance.
            </summary>
            <returns>
            A new object that is a deep clone of this instance.
            </returns>
        </member>
        <member name="M:OBeautifulCode.AccountingTime.UnitOfTime.ToString">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.AccountingTime.UnitOfTime.UnitOfTimeKind">
            <summary>
            Gets the kind of the unit-of-time.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.UnitOfTime.UnitOfTimeGranularity">
            <summary>
            Gets the granularity of the unit-of-time.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.IAmAConcreteUnitOfTime">
            <summary>
            Identifies a <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> that's concrete.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.IAmBoundedTime">
            <summary>
            Identifies a <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> that's bounded.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.IAmUnboundedTime">
            <summary>
            Identifies a <see cref="T:OBeautifulCode.AccountingTime.UnitOfTime"/> that's unbounded.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.IHaveAMonth">
            <summary>
            Exposes a month.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.IHaveAMonth.MonthNumber">
            <summary>
            Gets the month number.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.IHaveAYear">
            <summary>
            Exposes a year.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.IHaveAYear.Year">
            <summary>
            Gets the year.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.IHaveAQuarter">
            <summary>
            Exposes a quarter.
            </summary>
        </member>
        <member name="P:OBeautifulCode.AccountingTime.IHaveAQuarter.QuarterNumber">
            <summary>
            Gets the quarter number.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.MonthNumber">
            <summary>
            A month number.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Invalid">
            <summary>
            An invalid month.
            </summary>
            <remarks>
            This is required so that there is a default value for the enum.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.One">
            <summary>
            Month 1.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Two">
            <summary>
            Month 2.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Three">
            <summary>
            Month 3.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Four">
            <summary>
            Month 4.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Five">
            <summary>
            Month 5.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Six">
            <summary>
            Month 6.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Seven">
            <summary>
            Month 7.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Eight">
            <summary>
            Month 8.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Nine">
            <summary>
            Month 9.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Ten">
            <summary>
            Month 10.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Eleven">
            <summary>
            Month 11.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthNumber.Twelve">
            <summary>
            Month 12.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.QuarterNumber">
            <summary>
            A quarter number.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.QuarterNumber.Invalid">
            <summary>
            An invalid quarter.
            </summary>
            <remarks>
            This is required so that there is a default value for the enum.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.QuarterNumber.Q1">
            <summary>
            First quarter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.QuarterNumber.Q2">
            <summary>
            Second quarter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.QuarterNumber.Q3">
            <summary>
            Third quarter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.QuarterNumber.Q4">
            <summary>
            Fourth quarter.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekMethodology">
            <summary>
            Determines the methodology used to identify the last day of the accounting year, in a 52-53 week accounting period system.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekMethodology.Unknown">
            <summary>
            Unknown (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekMethodology.LastOccurrenceInAnchorMonth">
            <summary>
            Accounting year ends on whatever date the chosen day of the week last occurs in the anchor month.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.FiftyTwoFiftyThreeWeekMethodology.ClosestToLastDayOfAnchorMonth">
            <summary>
            Accounting year ends on the chosen day of week that is nearest to the last day of the anchor month.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.MonthOfYear">
            <summary>
            Represents a month.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.Invalid">
            <summary>
            Invalid month.
            </summary>
            <remarks>
            This is required so that there is a default value for the enum.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.January">
            <summary>
            Month of January.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.February">
            <summary>
            Month of February.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.March">
            <summary>
            Month of March.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.April">
            <summary>
            Month of April.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.May">
            <summary>
            Month of May.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.June">
            <summary>
            Month of June.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.July">
            <summary>
            Month of July.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.August">
            <summary>
            Month of August.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.September">
            <summary>
            Month of September.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.October">
            <summary>
            Month of October.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.November">
            <summary>
            Month of November.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.MonthOfYear.December">
            <summary>
            Month of December.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.UnitOfTimeKind">
            <summary>
            The kind of unit-of-time.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.UnitOfTimeKind.Invalid">
            <summary>
            Invalid kind.
            </summary>
            <remarks>
            This is required so that there is a default value for the enum.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.UnitOfTimeKind.Calendar">
            <summary>
            Represents a unit of time tied to the (gregorian) calendar.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.UnitOfTimeKind.Fiscal">
            <summary>
            Represents a unit of time in the context of some company's fiscal year.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.UnitOfTimeKind.Generic">
            <summary>
            Represents a generic unit of time, without any context.
            </summary>
        </member>
        <member name="T:OBeautifulCode.AccountingTime.UnitOfTimeGranularity">
            <summary>
            The granularity of a unit-of-time.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Invalid">
            <summary>
            Invalid granularity.
            </summary>
            <remarks>
            This is required so that there is a default value for the enum.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Day">
            <summary>
            Day-level granularity.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Month">
            <summary>
            Month-level granularity.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Quarter">
            <summary>
            Quarter-level granularity.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Year">
            <summary>
            Year-level granularity.
            </summary>
        </member>
        <member name="F:OBeautifulCode.AccountingTime.UnitOfTimeGranularity.Unbounded">
            <summary>
            Unbounded granularity.
            </summary>
        </member>
    </members>
</doc>
