<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OBeautifulCode.Serialization</name>
    </assembly>
    <members>
        <member name="T:OBeautifulCode.Cloning.Recipes.CloningExtensions">
            <summary>
            Extension methods to clone objects of various types.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone``1(``0)">
            <summary>
            Deep clones an arbitrary value.
            </summary>
            <typeparam name="T">The type of the value to deep clone.</typeparam>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.  If value is null, returns null.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.String)">
            <summary>
            Deep clones a <see cref="T:System.String"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.Version)">
            <summary>
            Deep clones a <see cref="T:System.Version"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Cloning.Recipes.CloningExtensions.DeepClone(System.Uri)">
            <summary>
            Deep clones a <see cref="T:System.Uri"/> value.
            </summary>
            <param name="value">The value to deep clone.</param>
            <returns>
            A deep clone of the specified value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause">
            <summary>
            Standard justifications for analysis suppression.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_SeeOtherSuppressionMessages">
            <summary>
            See the other suppression message(s) applied within the same context.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_AgreeWithAssessmentAndNeedsRefactoring">
            <summary>
            We agree with the assessment.  This code needs refactoring but we cannot justify spending time on this right now.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_NatureOfTypeNecessitatesIgnoringAllWarnings">
            <summary>
            The nature of this type necessitates that we ignore all warnings.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA_ALL_NotApplicable">
            <summary>
            This warning detects a situation that is not applicable to this code.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1000_DoNotDeclareStaticMembersOnGenericTypes_StaticPropertyReturnsInstanceOfContainingGenericClassAndIsConvenientAndMostDiscoverableWhereDeclared">
            <summary>
            A static property returns an instance of the generic class that contains the property.  The property exists for convenience in creating and configuring the instance.  It is most discoverable where it is, in-context of the class being instantiated.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1002_DoNotExposeGenericLists_GenericListRequiredForTesting">
            <summary>
            A generic list is required in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1004_GenericMethodsShouldProvideTypeParameter_OnlyInputsToMethodAreTypesAndItsMoreConciseToCallMethodUseGenericTypeParameters">
            <summary>
            The only input(s) to the method are Types.  It's more concise to call the method using generic types parameters instead of a parameter signature with parameters of type Type (e.g. MyMethod&lt;MyType&gt;() instead of MyMethod(Type myType)).
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1005_AvoidExcessiveParametersOnGenericTypes_SpecifiedParametersRequiredForNeededFunctionality">
            <summary>
            The specified paramters are required to achieve the needed functionality.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1014_MarkAssembliesWithClsCompliant_ConsoleExeDoesNotNeedToBeClsCompliant">
            <summary>
            Console executable does not need the [assembly: CLSCompliant(true)] as it should not be shared as an assembly for reference.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1020_AvoidNamespacesWithFewTypes_OptimizeForLogicalGroupingOfTypes">
            <summary>
            We are optimizing for the logical grouping of types rather than the number of types in a namepace.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1021_AvoidOutParameters_OutParameterRequiredForTryMethod">
            <summary>
            An out parameter is required for a Try...() method that attempts to perform some operation, returning true when successful and setting the out parameter to the result of the operation or returning false and leaving the out parameter uninitialized (e.g. dictionary.TryGetValue(key, int out result) ).
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1027_MarkEnumsWithFlags_EnumValuesArePurposefullyNonContiguous">
            <summary>
            This is not a flags enum.  Enum values are purposefully non-contiguous.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1032_ImplementStandardExceptionConstructors_ExceptionUsedInternallyAndConstructorsEnsureRequiredInfoAvailableWhenCaught">
            <summary>
            This Exception is only used internally and the constructor(s) ensure that when the Exception is caught, it contains the required information.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1034_NestedTypesShouldNotBeVisible_VisibleNestedTypeRequiredForTesting">
            <summary>
            A visible nested type is required in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1036_OverrideMethodsOnComparableTypes_TypeCreatedForTestsThatRequireComparableTypeButDoNotUseTypeToPerformComparisons">
            <summary>
            The type exists for unit tests that require a comparable type, but do not use the type to perform any comparisons.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1040_AvoidEmptyInterfaces_NeedToIdentifyGroupOfTypesAndPreferInterfaceOverAttribute">
            <summary>
            When we need to identify a group of types, we prefer the use of an empty interface over an attribute because it's easier to use and results in cleaner code.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1051_DoNotDeclareVisibleInstanceFields_TypeUsedInTestingThatRequiresInstanceFieldToBeVisible">
            <summary>
            The type is used for test code that requires the instance field to be visible.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1054_UriParametersShouldNotBeStrings_PreferToRepresentUrlAsString">
            <summary>
            In this case we prefer to represent the URL as a string.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1056_UriPropertiesShouldNotBeStrings_PreferToRepresentUrlAsString">
            <summary>
            In this case we prefer to represent the URL as a string.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1065_DoNotRaiseExceptionsInUnexpectedLocations_ThrowNotSupportedExceptionForUnreachableCodePath">
            <summary>
            It's ok to throw NotSupportedException for an unreachable code path.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1065_DoNotRaiseExceptionsInUnexpectedLocations_ThrowNotImplementedExceptionWhenForcedToSpecifyMemberThatWillNeverBeUsedInTesting">
            <summary>
            It's ok to throw NotImplementedException when a base type or implementing an interface forces us to create a member that will never be used in testing.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1308_NormalizeStringsToUppercase_PreferGuidLowercase">
            <summary>
            We prefer to read <see cref="T:System.Guid" />'s string representation as lowercase.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1502_AvoidExcessiveComplexity_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment that this method as excessively complex.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1505_AvoidUnmaintainableCode_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment that this code is unmaintainable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1506_AvoidExcessiveClassCoupling_DisagreeWithAssessment">
            <summary>
            We disagree with the assessment this type or method is excessively coupled.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1702_CompoundWordsShouldBeCasedCorrectly_AnalyzerIsIncorrectlyDetectingCompoundWords">
            <summary>
            The analyzer is incorrectly detecting compound words.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1704_IdentifiersShouldBeSpelledCorrectly_SpellingIsCorrectInContextOfTheDomain">
            <summary>
            The spelling of the identifier is correct in-context of the domain.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1709_IdentifiersShouldBeCasedCorrectly_CasingIsAsPreferred">
            <summary>
            The casing is as preferred.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1710_IdentifiersShouldHaveCorrectSuffix_ExceptionBaseClassShouldEndWithBase">
            <summary>
            An Exception base class should end in 'Base' (as is the convention for all base classes), not 'Exception'.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1710_IdentifiersShouldHaveCorrectSuffix_NameDirectlyExtendedOrImplementedTypeAddedAsSuffixForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier is suffixed with the name of the Type that it directly extends or implements to improves readability and comprehension of unit tests whre the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1711_IdentifiersShouldNotHaveIncorrectSuffix_TypeNameAddedAsSuffixForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier is suffixed with it's Type name to improve readability and comprehension of unit tests where the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1714_FlagsEnumsShouldHavePluralNames_TheNameIsPlural">
            <summary>
            The name is plural.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndNoGoodAlternative">
            <summary>
            The type name adds clarity to the identifier and there is no good alternative.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity">
            <summary>
            The type name adds clarity to the identifier and the alternatives degrade the clarity of the identifier.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddedToIdentifierForTestsWhereTypeIsPrimaryConcern">
            <summary>
            The identifier includes it's Type name to improve readability and comprehension of unit tests where the Type is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1726_UsePreferredTerms_FlagsAddedForTestsWhereEnumKindIsPrimaryConcern">
            <summary>
            The identifier includes 'Flags' to improve readability and comprehension of unit tests where the kind of Enum is a primary concern of those tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags">
            <summary>
            The name of the Type of the identifier uses the term 'Flags' and so it's appropriate to use that term in the the name of the identifier.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1804_RemoveUnusedLocals_UsedAsWorkaroundForConditionalBreakpointThatCannotBeSet">
            <summary>
            In some cases, the debugger raises an error because it cannot set a conditional breakpoint.  A local is introduced to simplify the evaluation of the breakpoint's condition.  It's only purpose is to allow a conditional breakpoint in proximity of the breakpoint that cannot be set.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1810_InitializeReferenceTypeStaticFieldsInline_FieldsDeclaredInCodeGeneratedPartialTestClass">
            <summary>
            The static field(s) are declared in a code generated partial test class that should not be alterated.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1811_AvoidUncalledPrivateCode_MethodIsWiredIntoClapAsVerb">
            <summary>
            The method is wired into CLAP, a framework for command-line parsing, as a verb.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1811_AvoidUncalledPrivateCode_PropertyExistsForCompleteness">
            <summary>
            The property exists for completeness.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_ClassIsWiredIntoClapInProgramCs">
            <summary>
            The class is wired into CLAP, a framework for command-line parsing, in Program.cs.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_SerializationConfigurationClassInstantedBySerializer">
            <summary>
            The class derives from SerializationConfigurationBase and is instantiated by a Serializer that is configured using the type of that class.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1812_AvoidUninstantiatedInternalClasses_ClassExistsToUseItsTypeInUnitTests">
            <summary>
            The class exists because it's Type is used in unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1815_OverrideEqualsAndOperatorEqualsOnValueTypes_TypeUsedForTestsThatRequireTypeToNotBeEquatable">
            <summary>
            The type is being used in testing and we explicitly do not want the type to be equatable because it has bearing on the tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1819_PropertiesShouldNotReturnArrays_DataPayloadsAreCommonlyRepresentedAsByteArrays">
            <summary>
            Data payloads are commonly represented as a byte arrays.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA1819_PropertiesShouldNotReturnArrays_ArrayPropertyRequiredForTesting">
            <summary>
            An array property is required for unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2000_DisposeObjectsBeforeLosingScope_DisposableObjectIsMethodReturnObject">
            <summary>
            The disposable object is the method's return object.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2000_DisposeObjectsBeforeLosingScope_MethodCreatesDisposableObjectButItCannotBeDisposedBecauseReturnObjectRequiresDisposableObjectToBeFullyIntact">
            <summary>
            The method creates a dispoable object, but it cannot be disposed because the return object requires the disposable object to be fully intact.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2104_DoNotDeclareReadOnlyMutableReferenceTypes_TypeIsImmutable">
            <summary>
            The type is immutable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2201_DoNotRaiseReservedExceptionTypes_UsedForUnitTesting">
            <summary>
            The reserved exception is being used in unit test code; there is no real caller that will be impacted.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2202_DoNotDisposeObjectsMultipleTimes_AnalyzerIsIncorrectlyFlaggingObjectAsBeingDisposedMultipleTimes">
            <summary>
            The analyzer is incorectly flagging an object as being disposed multiple times.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2214_DoNotCallOverridableMethodsInConstructors_OverriddenMethodDoesNotRelyOnInitializationNorOtherConfigurationInConstructor">
            <summary>
            The overridden method does not relies on initialization nor other configuration in the constructor.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2227_CollectionPropertiesShouldBeReadOnly_PublicInterfaceNeverExposesTheObject">
            <summary>
            The public interface of the system associated with this object never exposes this object.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2227_CollectionPropertiesShouldBeReadOnly_SetterIsRequiredForTesting">
            <summary>
            A setter is required for unit tests.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2237_MarkISerializableTypesWithSerializable_UsedForTestingWithNoIntentionToSerialize">
            <summary>
            The type is used in unit tests with no intention to serialize.
            </summary>
        </member>
        <member name="F:OBeautifulCode.CodeAnalysis.Recipes.ObcSuppressBecause.CA2237_MarkISerializableTypesWithSerializable_ExceptionOnlyUsedInternallyAndWillNeverBeSerialized">
            <summary>
            The Exception is only used internally; it will never be serialized.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Collection.Recipes.CollectionExtensions">
            <summary>
            Helper methods for operating on objects of type <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.CollectionExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds the elements of the specified <see cref="T:System.Collections.IEnumerable"/> to an <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
            <param name="collection">The collection to add to.</param>
            <param name="valuesToAdd">
            The <see cref="T:System.Collections.IEnumerable"/> whose elements should be added to the <see cref="T:System.Collections.ICollection"/>.
            The <see cref="T:System.Collections.IEnumerable"/> itself cannot be a null reference, but it can contain elements that are a null reference.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="valuesToAdd"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.Collection.Recipes.EnumerableExtensions">
            <summary>
            Helper methods for operating on objects of type <see cref="T:System.Collections.IEnumerable"/> and <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.GetCombinations``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Gets all combinations of items in a specified set of items.
            </summary>
            <remarks>
            Adapted from <a href="https://stackoverflow.com/a/41642733/356790" />.
            </remarks>
            <typeparam name="T">The type of items in the set.</typeparam>
            <param name="values">The set of values.</param>
            <param name="minimumItems">Optional minimum number of items in each combination.  Default is 1.</param>
            <param name="maximumItems">Optional maximum number of items in each combination.  Default is no maximum limit.</param>
            <returns>
            All possible combinations for the input set, constrained by the specified <paramref name="maximumItems"/> and <paramref name="minimumItems"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minimumItems"/> is less than 1.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumItems"/> is less than <paramref name="minimumItems"/>"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.GetLongestCommonPrefix(System.Collections.Generic.IReadOnlyCollection{System.String})">
            <summary>
            Gets the longest string that is a prefix of all of the specified strings.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/58265152/356790" />.
            </remarks>
            <param name="values">The value to evaluate for a common prefix.</param>
            <returns>
            The longest string that is a prefix of all of the specified strings.
            If any value is null, returns null as the common prefix.
            Otherwise, if there is no common prefix, returns an empty string.
            If only one value is specified, then the value itself is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="values"/> is empty.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.RandomizeElements``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Puts the elements of a specified enumerable into a new enumerable, in random order.
            </summary>
            <param name="value">The enumerable.</param>
            <returns>
            A new enumerable having all of the elements of the specified enumerable, but in random order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.SymmetricDifference(System.Collections.IEnumerable,System.Collections.IEnumerable)">
            <summary>
            Gets the symmetric difference of two sets using the default equality comparer.
            The symmetric difference is defined as the set of elements which are in one of the sets, but not in both.
            </summary>
            <remarks>
            If one set has duplicate items when evaluated using the comparer, then the resulting symmetric difference will only
            contain one copy of the the duplicate item and only if it doesn't appear in the other set.
            </remarks>
            <param name="value">The first enumerable.</param>
            <param name="secondSet">The second enumerable to compare against the first.</param>
            <returns>IEnumerable(T) with the symmetric difference of the two sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="secondSet"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.SymmetricDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets the symmetric difference of two sets using an equality comparer.
            The symmetric difference is defined as the set of elements which are in one of the sets, but not in both.
            </summary>
            <remarks>
            If one set has duplicate items when evaluated using the comparer, then the resulting symmetric difference will only
            contain one copy of the the duplicate item and only if it doesn't appear in the other set.
            </remarks>
            <typeparam name="TSource">The type of elements in the collection.</typeparam>
            <param name="value">The first enumerable.</param>
            <param name="secondSet">The second enumerable to compare against the first.</param>
            <param name="comparer">Optional equality comparer to use to compare elements.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the symmetric difference of the two sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="secondSet"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.ToCsv(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a common separated values (CSV) string from the individual strings in an <see cref="T:System.Collections.IEnumerable"/>,
            making CSV treatments where needed (double quotes around strings with commas, etc.).
            </summary>
            <param name="value">The enumerable to transform into a CSV string.</param>
            <param name="nullValueEncoding">Optional value to use when encoding null elements.  Defaults to the empty string.</param>
            <remarks>
            CSV treatments: <a href="http://en.wikipedia.org/wiki/Comma-separated_values"/>.
            </remarks>
            <returns>
            Returns a string that contains each element in the input enumerable,
            separated by a comma and with the proper escaping.
            If the enumerable is empty, returns null.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.ToDelimitedString(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Concatenates the individual values in an <see cref="T:System.Collections.IEnumerable"/> with a given delimiter
            separating the individual values.
            </summary>
            <param name="value">The enumerable to concatenate.</param>
            <param name="delimiter">The delimiter to use between elements in the enumerable.</param>
            <remarks>
            If an element of the IEnumerable is null, then its treated like an empty string.
            </remarks>
            <returns>
            Returns a string that contains each element in the input enumerable, separated by the given delimiter.
            If the enumerable is empty, then this method returns null.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="delimiter"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.ToNewLineDelimited(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a string with the values in a given <see cref="T:System.Collections.IEnumerable"/>, separated by a newline.
            </summary>
            <param name="value">The enumerable to concatenate.</param>
            <remarks>
            If an element of the IEnumerable is null, then its treated like an empty string.
            </remarks>
            <returns>
            Returns a string that contains each element in the input enumerable, separated by a newline.
            If the enumerable is empty, then this method returns null.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Collection.Recipes.EnumerableExtensions.ToNonGenericDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Converts a generic dictionary to a non-generic dictionary.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <param name="value">The dictionary to convert.</param>
            <returns>
            The specified generic dictionary converted to a non-generic dictionary.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/>is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> contains duplicate keys.</exception>
        </member>
        <member name="T:OBeautifulCode.Compression.Recipes.CompressorFactory">
            <summary>
            Get the correct <see cref="T:OBeautifulCode.Compression.ICompressAndDecompress" /> implementation based on the kind.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Compression.Recipes.CompressorFactory.Instance">
            <summary>
            Gets the singleton entry point to the code.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Compression.Recipes.CompressorFactory.BuildCompressor(OBeautifulCode.Compression.CompressionKind)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Compression.Recipes.DotNetZipCompressor">
            <summary>
            Build in dot net implementation of <see cref="T:OBeautifulCode.Compression.ICompressAndDecompress"/>.
            Implementation from: <a href="https://stackoverflow.com/questions/40909052/using-gzip-to-compress-decompress-an-array-of-bytes" />.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Compression.Recipes.DotNetZipCompressor.CompressionKind">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Compression.Recipes.DotNetZipCompressor.CompressBytes(System.Byte[])">
            <summary>
            Compresses the provided byte array.
            </summary>
            <param name="uncompressedBytes">Byte array to compress.</param>
            <returns>
            Compressed version of the supplied byte array.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Compression.Recipes.DotNetZipCompressor.DecompressBytes(System.Byte[])">
            <summary>
            Decompresses the provided byte array.
            </summary>
            <param name="compressedBytes">Byte array to decompress.</param>
            <returns>
            Decompressed version of the supplied byte array.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Compression.Recipes.DotNetZipCompressor.OBeautifulCode#Compression#ICompress#CompressBytes(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Compression.Recipes.DotNetZipCompressor.OBeautifulCode#Compression#IDecompress#DecompressBytes(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Compression.Recipes.NullCompressor">
            <summary>
            Null implementation of <see cref="T:OBeautifulCode.Compression.ICompressAndDecompress"/>.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Compression.Recipes.NullCompressor.CompressionKind">
            <inheritdoc cref="T:OBeautifulCode.Compression.ICompressAndDecompress"/>
        </member>
        <member name="M:OBeautifulCode.Compression.Recipes.NullCompressor.CompressBytes(System.Byte[])">
            <inheritdoc cref="T:OBeautifulCode.Compression.ICompressAndDecompress"/>
        </member>
        <member name="M:OBeautifulCode.Compression.Recipes.NullCompressor.DecompressBytes(System.Byte[])">
            <inheritdoc cref="T:OBeautifulCode.Compression.ICompressAndDecompress"/>
        </member>
        <member name="T:OBeautifulCode.Enum.Recipes.EnumExtensions">
            <summary>
            Adds some convenient extension methods to enums.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetDefinedEnumValues``1">
            <summary>
            Gets the members/values of a specified enum.
            </summary>
            <typeparam name="TEnum">The type of enum.</typeparam>
            <returns>
            The members/values of the specified enum.
            For flags enums, returns all individual flags and all combined flags that are defined in the enum.
            </returns>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetDefinedEnumValues(System.Type)">
            <summary>
            Gets the members/values of a specified enum.
            </summary>
            <param name="enumType">The enum type.</param>
            <returns>
            The members/values of the specified enum.
            For flags enums, returns all individual flags and all combined flags that are defined in the enum.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.IsFlagsEnum``1">
            <summary>
            Determines if the specified enum is a flags enum.
            </summary>
            <typeparam name="TEnum">The type of enum.</typeparam>
            <returns>
            true if the specified enum is a flags enum, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.IsFlagsEnum(System.Type)">
            <summary>
            Determines if the specified enum is a flags enum.
            </summary>
            <param name="enumType">The enum type.</param>
            <returns>
            true if the specified enum is a flags enum, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetAllPossibleEnumValues``1">
            <summary>
            Gets all possible enum values.
            For a flags enum, this means all possible combination of flags,
            regardless of whether the combination is defined in the enum itself.
            </summary>
            <typeparam name="TEnum">The type of enum.</typeparam>
            <returns>
            All possible enum values.
            </returns>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetAllPossibleEnumValues(System.Type)">
            <summary>
            Gets all possible enum values.
            For a flags enum, this means all possible combination of flags,
            regardless of whether the combination is defined in the enum itself.
            </summary>
            <param name="enumType">The enum type.</param>
            <returns>
            All possible enum values.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetFlagsCombinedWherePossible(System.Enum)">
            <summary>
            Gets the flags of a flags enum, with a preference for returning combined flags
            instead of individual flags where the enum value uses combined flags.
            </summary>
            <param name="value">The enum value to decompose into it's flags.</param>
            <remarks>
            Adapted from: <a href="http://stackoverflow.com/a/4171168/356790" />.
            </remarks>
            <returns>
            The flags of the specified enum, with combined flags instead of individual flags where possible.
            No bit will be repeated.  Thus, if two combined flags are represented in the value and they
            have an overlapping individual flag, only one of those combined flags will be returned and
            the other will be decomposed into it's non-overlapping individual flags.
            If value is 0, then a collection with only the 0 value is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetFlagsCombinedWherePossible``1(System.Enum)">
            <summary>
            Gets the flags of a flags enum, with a preference for returning combined flags
            instead of individual flags where the enum value uses combined flags.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The enum value to decompose into it's flags.</param>
            <remarks>
            Adapted from: <a href="http://stackoverflow.com/a/4171168/356790" />.
            </remarks>
            <returns>
            The flags of the specified enum, with combined flags instead of individual flags where possible.
            No bit will be repeated.  Thus, if two combined flags are represented in the value and they
            have an overlapping individual flag, only one of those combined flags will be returned and
            the other will be decomposed into it's non-overlapping individual flags.
            If value is 0, then a collection with only the 0 value is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.HasFlagOverlap(System.Enum,System.Enum)">
            <summary>
            Checks if there is any overlap between the two <see cref="T:System.FlagsAttribute" /> enumerations.
            </summary>
            <param name="first">First to check.</param>
            <param name="second">Second to check.</param>
            <returns>Value indicating whether there is any overlap.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="second"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetIndividualFlags(System.Type)">
            <summary>
            Gets the individual flags of a flags enum type.
            </summary>
            <param name="enumType">The enum type.</param>
            <returns>
            The individuals flags of the specified flags enum type (includes 0).
            If <paramref name="enumType"/> is not a flags enum then all enum values are returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetIndividualFlags``1">
            <summary>
            Gets the individual flags of a flags enum type.
            </summary>
            <typeparam name="TEnum">The type of enum.</typeparam>
            <returns>
            The individuals flags of the specified flags enum type (includes 0).
            If <typeparamref name="TEnum"/> is not a flags enum then all enum values are returned.
            </returns>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetIndividualFlags(System.Enum)">
            <summary>
            Gets the individual flags of a flags enum value.
            </summary>
            <param name="value">The enum value to decompose into it's individual flags.</param>
            <remarks>
            Adapted from: <a href="http://stackoverflow.com/a/4171168/356790" />.
            </remarks>
            <returns>
            The individuals flags of the specified flags enum value.
            If value is 0, then a collection with only the 0 value is returned.
            If the enum is not a flags enum then a collection with the enum value itself is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.GetIndividualFlags``1(System.Enum)">
            <summary>
            Gets the individual flags of a flags enum value.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The enum value to decompose into it's individual flags.</param>
            <remarks>
            Adapted from: <a href="http://stackoverflow.com/a/4171168/356790" />.
            </remarks>
            <returns>
            The individuals flags of the specified flags enum value.
            If value is 0, then a collection with only the 0 value is returned.
            If the enum is not a flags enum then a collection with the enum value itself is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not of type <see cref="T:System.Enum"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.ToEnum``1(System.String,System.Boolean)">
            <summary>
            Parses and converts to the specified string to an enum value.
            </summary>
            <remarks>
            [Flags] Colors { None=0, Red = 1, Green = 2, Blue = 4 }
            '0'          => None
            '2'          => Green
            '7'          => Red | Green | Blue
            'Blue'       => Blue
            'blue'       => Blue (if ignoreCase = true)
            'Red, Green' => Red | Green
            'Red,Green'  => Red | Green
            'red,green'  => Red | Green (if ignoreCase = true)
            </remarks>
            <typeparam name="TEnum">The type of enum.</typeparam>
            <param name="value">The string value to convert.</param>
            <param name="ignoreCase">
            Optional value indicating whether to operate in case sensitive or case insensitive mode.
            Default is operate in case sensitive mode.
            Use <c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.
            </param>
            <returns>
            The enum member/value that corresponds to the specified string value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> is white space.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> does not represent an enumeration.</exception>
            <exception cref="T:System.ArgumentException">Cannot convert the specified value to an enum member of the <typeparamref name="TEnum"/> enum.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.ToEnum(System.String,System.Type,System.Boolean)">
            <summary>
            Parses and converts to the specified string to an enum value.
            </summary>
            <remarks>
            [Flags] Colors { None=0, Red = 1, Green = 2, Blue = 4 }
            '0'          => None
            '2'          => Green
            '7'          => Red | Green | Blue
            'Blue'       => Blue
            'blue'       => Blue (if ignoreCase = true)
            'Red, Green' => Red | Green
            'Red,Green'  => Red | Green
            'red,green'  => Red | Green (if ignoreCase = true)
            </remarks>
            <param name="value">The string value to convert.</param>
            <param name="enumType">The type of the enum.</param>
            <param name="ignoreCase">
            Optional value indicating whether to operate in case sensitive or case insensitive mode.
            Default is operate in case sensitive mode.
            Use <c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.
            </param>
            <returns>
            The enum member/value that corresponds to the specified string value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> is white space.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> does not represent an enumeration.</exception>
            <exception cref="T:System.ArgumentException">Cannot convert the specified value to an enum member of the <paramref name="enumType"/> enum.</exception>
        </member>
        <member name="M:OBeautifulCode.Enum.Recipes.EnumExtensions.BitwiseOr(System.Enum,System.Enum)">
            <summary>
            Performs a bitwise OR on the specified enum values.
            </summary>
            <param name="value1">The first enum value.</param>
            <param name="value2">The second enum value.</param>
            <returns>
            The result of performing a bitwise OR operation on the specified enum values.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value1"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="value2"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value1"/> is not a flags enum.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value1"/> Type != <paramref name="value2"/> Type.</exception>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer">
            <summary>
            Compares two byte arrays for equality.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer.Equals(System.Byte[],System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ByteArrayEqualityComparer.GetHashCode(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer">
            <summary>
            Compares two <see cref="T:System.DateTime"/>, fixing .NET's default implementation where two objects
            having the same <see cref="P:System.DateTime.Ticks"/> but different <see cref="P:System.DateTime.Kind"/> are
            considered equal.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer.Equals(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DateTimeEqualityComparer.GetHashCode(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of dictionary keys.</typeparam>
            <typeparam name="TValue">The type of dictionary values.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2.Equals(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.DictionaryEqualityComparer`2.GetHashCode(System.Collections.Generic.IDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/14675741/356790" />.
            </remarks>
            <typeparam name="T">The type of objects to enumerate.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.#ctor(OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1"/> class.
            </summary>
            <param name="enumerableEqualityComparerStrategy">The strategy to use when comparing two <see cref="T:System.Collections.Generic.IEnumerable`1"/> for equality.</param>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.Equals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparer`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy">
            <summary>
            Determines the strategy to use when comparing two <see cref="T:System.Collections.Generic.IEnumerable`1"/> for equality.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy.SequenceEqual">
            <summary>
            Use <see cref="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsSequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.EnumerableEqualityComparerStrategy.UnorderedEqual">
            <summary>
            Use <see cref="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsUnorderedEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EqualityComparerHelper">
            <summary>
            Helper methods related to <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets the equality comparer to use for the specified type.
            </summary>
            <typeparam name="T">The type of the objects being compared.</typeparam>
            <param name="comparer">Optional comparer passed into the calling method.  Default is null, which instructs this method to determine the comparer.  If not null, then the specified comparer is returned.</param>
            <returns>
            The equality comparer to use for the specified type.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.EqualityExtensions">
            <summary>
            Extension methods that test for equality between two objects.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsEqualTo``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares objects for equality.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
            <param name="item1">The first object to compare.</param>
            <param name="item2">The second object to compare.</param>
            <param name="comparer">Optional equality comparer to use to compare the objects.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two objects are equal
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsDictionaryEqualTo``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionaries.</typeparam>
            <typeparam name="TValue">The type of values in the dictionaries.</typeparam>
            <param name="item1">The first <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="item2">The second <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="valueComparer">Optional equality comparer to use to compare values.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source dictionaries are null.
            - false if one or the other is null.
            - false if the dictionaries are of different length.
            - true if the two dictionaries are of equal length and their values are equal for the same keys.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsReadOnlyDictionaryEqualTo``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionaries.</typeparam>
            <typeparam name="TValue">The type of values in the dictionaries.</typeparam>
            <param name="item1">The first <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="item2">The second <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="valueComparer">Optional equality comparer to use to compare values.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source dictionaries are null.
            - false if one or the other is null.
            - false if the dictionaries are of different length.
            - true if the two dictionaries are of equal length and their values are equal for the same keys.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsSequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two dictionaries for equality.
            </summary>
            <typeparam name="TElement">The type of the elements of the input sequences.</typeparam>
            <param name="item1">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to <paramref name="item2"/>.</param>
            <param name="item2">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to the first sequence.</param>
            <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source sequences are null.
            - false if one or the other is null.
            - true if the two sequences are of equal length and their corresponding elements are equal according to <paramref name="elementComparer"/>.
            - otherwise, false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.EqualityExtensions.IsUnorderedEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if two enumerables have the exact same elements in any order.
            Every unique element in the first set has to appear in the second set the same number of times it appears in the first.
            </summary>
            <typeparam name="TElement">The type of the elements of the input sequences.</typeparam>
            <param name="item1">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to <paramref name="item2"/>.</param>
            <param name="item2">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare to the first sequence.</param>
            <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to call <see cref="M:OBeautifulCode.Equality.Recipes.EqualityComparerHelper.GetEqualityComparerToUse``1(System.Collections.Generic.IEqualityComparer{``0})"/>.</param>
            <returns>
            - true if the two source sequences are null.
            - false if one or the other is null.
            - false if there is any symmetric difference.
            - true if the two sequences both contain the same number of elements for each unique element.
            - otherwise, false.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.HashCodeHelper">
            <summary>
            Provides methods to help with generating hash codes for structures and classes. This handles
            value types, nullable type, and objects.
            </summary>
            <remarks>
            Adapted from NodaTime: <a href="https://github.com/nodatime/nodatime/blob/master/src/NodaTime/Utility/HashCodeHelper.cs"/>.
            The basic usage pattern is as follows.
            <example>
            <code>
             public override int GetHashCode() => HashCodeHelper.Initialize().Hash(Field1).Hash(Field2).Hash(Field3).Value;
            </code>
            </example>
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.HashCodeHelper.HashCodeMultiplier">
            <summary>
            The multiplier for each value.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Equality.Recipes.HashCodeHelper.HashCodeInitializer">
            <summary>
            The initial hash value.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> class.
            </summary>
            <param name="value">The hash code value.</param>
        </member>
        <member name="P:OBeautifulCode.Equality.Recipes.HashCodeHelper.Value">
            <summary>
            Gets the hash code value.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Initialize">
            <summary>
            Returns the initial value for a hash code.
            </summary>
            <returns>The initial integer wrapped in a <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> value.</returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Initialize(System.Int32)">
            <summary>
            Returns the initial value for a hash code.
            </summary>
            <param name="seedValue">Seed value to initialize with (often the hash code from a base class using it's base properties).</param>
            <returns>The initial integer wrapped in a <see cref="T:OBeautifulCode.Equality.Recipes.HashCodeHelper"/> value.</returns>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.HashCodeHelper.Hash``1(``0)">
            <summary>
            Adds the hash code for the given item to the current hash code and returns the new hash code.
            </summary>
            <typeparam name="T">The type of the item being hashed.</typeparam>
            <param name="item">The item to hash.</param>
            <returns>The new hash code.</returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1">
            <summary>
            An equality comparer backed by a lambda.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1"/> class.
            </summary>
            <param name="equalsFunc">The function to use to determine whether two objects of type <typeparamref name="T"/> are equal.</param>
            <param name="getHashCodeFunc">OPTIONAL function to get the hash code for an object of type <typeparamref name="T"/> in context of this equality comparer.  DEFAULT is to have <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"/> throw <see cref="T:System.NotSupportedException"/>.</param>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.LambdaBackedEqualityComparer`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.NativeMethods">
            <summary>
            P/invoke method.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NativeMethods.memcmp(System.Byte[],System.Byte[],System.Int64)">
            <summary>
            Compares two byte arrays.
            </summary>
            <param name="b1">The first byte array.</param>
            <param name="b2">The second byte array.</param>
            <param name="count">The length of the bytes.</param>
            <returns>
            0 if the byte arrays are equal.
            Less than 0 if the first byte array is less than the second byte array.
            Greater than 0 if the first byte array is greater than the second byte array.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer">
            <summary>
            Compares two <see cref="T:System.Nullable`1"/>, fixing .NET's default implementation where two objects
            having the same <see cref="P:System.DateTime.Ticks"/> but different <see cref="P:System.DateTime.Kind"/> are
            considered equal.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer.Equals(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.NullableDateTimeEqualityComparer.GetHashCode(System.Nullable{System.DateTime})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer">
            <summary>
            Compares two objects equality.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer.Equals(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ObjectEqualityComparer.GetHashCode(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for any <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of dictionary keys.</typeparam>
            <typeparam name="TValue">The type of dictionary values.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2.Equals(System.Collections.Generic.IReadOnlyDictionary{`0,`1},System.Collections.Generic.IReadOnlyDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Equality.Recipes.ReadOnlyDictionaryEqualityComparer`2.GetHashCode(System.Collections.Generic.IReadOnlyDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Math.Recipes.ThreadSafeRandom">
            <summary>
            Represents a thread-safe pseudo-random number generator,
            a device that produces a sequence of numbers that meet
            certain statistical requirements for randomness.
            </summary>
            <remarks>
            Adapted from:
            <a href="http://blogs.msdn.com/b/pfxteam/archive/2009/02/19/9434171.aspx"/>
            <a href="http://codeblog.jonskeet.uk/2009/11/04/revisiting-randomness/"/>
            System.Random is not thread-safe, hence the need for this class.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Lock">
            <summary>
            Lock object for access to global random number generator.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Math.Recipes.ThreadSafeRandom.random">
            <summary>
            A single random number generator for the app domain,
            used to seed thread-specific random number generators.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Reseed(System.Int32)">
            <summary>
            Reseeds the random number generator.
            </summary>
            <param name="seed">
            A number used to calculate a starting value for the pseudo-random number sequence.
            If a negative number is specified, the absolute value of the number is used.
            </param>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Next">
            <summary>
            Returns a nonnegative random integer.
            </summary>
            <remarks>
            Random.Next generates a random number whose value ranges from zero to less than <see cref="F:System.Int32.MaxValue"/>.
            To generate a random number whose value ranges from zero to some other positive number, use the <see cref="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Next(System.Int32)"/> method overload.
            To generate a random number within a different range, use the <see cref="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Next(System.Int32,System.Int32)"/> method overload.
            </remarks>
            <returns>
            A 32-bit signed integer greater than or equal to zero and less than MaxValue.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Next(System.Int32)">
            <summary>
            Returns a nonnegative random integer that is less than the specified maximum.
            </summary>
            <param name="maxValue">The exclusive upper bound of the random number to be generated. maxValue must be greater than or equal to zero.</param>
            <returns>
            A 32-bit signed integer greater than or equal to zero, and less than maxValue; that is, the range of return values
            ordinarily includes zero but not maxValue. However, if maxValue equals zero, maxValue is returned.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than zero.</exception>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random integer that is within a specified range.
            </summary>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The exclusive upper bound of the random number returned. maxValue must be greater than or equal to minValue.</param>
            <remarks>
            Unlike the other overloads of the Next method, which return only non-negative values, this method can return a negative random integer.
            </remarks>
            <returns>
            A 32-bit signed integer greater than or equal to minValue and less than maxValue; that is, the range of
            return values includes minValue but not maxValue. If minValue equals maxValue, minValue is returned.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minValue"/> is greater than <paramref name="maxValue"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers.
            </summary>
            <param name="buffer">An array of bytes to contain random numbers.</param>
            <remarks>
            Each element of the array of bytes is set to a random number greater than or equal to zero, and less than or equal to MaxValue.
            To generate a cryptographically secured random number suitable for creating a random password,
            for example, use a method such as RNGCryptoServiceProvider.GetBytes.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Math.Recipes.ThreadSafeRandom.NextDouble">
            <summary>
            Returns a random floating-point number between 0.0 and 1.0.
            </summary>
            <remarks>
            This method is the public version of the protected method, Sample.
            </remarks>
            <returns>
            A double-precision floating point number greater than or equal to 0.0, and less than 1.0.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.AccessModifier">
            <summary>
            The supported access modifiers, in order of least to greatest access.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.Unknown">
            <summary>
            Unknown (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.Private">
            <summary>
            Private access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private" />.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.PrivateProtected">
            <summary>
            Private protected access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private-protected" />.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.Protected">
            <summary>
            Protected access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected" />.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.ProtectedInternal">
            <summary>
            Protected internal access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal" />.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.Internal">
            <summary>
            Internal access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/internal" />.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AccessModifier.Public">
            <summary>
            Public access: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public" />.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.AssemblyHelper">
            <summary>
            Provides useful methods for extracting information from and
            interacting with assemblies using reflection.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.GetCodeBaseAsPathInsteadOfUri(System.Reflection.Assembly)">
            <summary>
            Gets the <see cref="P:System.Reflection.Assembly.CodeBase" /> as a real file path instead of a <see cref="T:System.Uri" /> so it can be used with common <see cref="N:System.IO" /> operations.
            </summary>
            <param name="assembly">Assembly to extend functionality of.</param>
            <returns>CodeBase as real path.</returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.OpenEmbeddedResourceStream(System.Reflection.Assembly,System.String,OBeautifulCode.Reflection.Recipes.CompressionMethod)">
            <summary>
            Retrieves an embedded resource's stream.
            </summary>
            <param name="assembly">Calling assembly.</param>
            <param name="resourceName">Name of the resource in the calling assembly.</param>
            <param name="decompressionMethod">
            The compression algorithm and/or archive file format that was used to compress the resource.
            This is used to open a decompressed stream.
            </param>
            <returns>Returns the specified manifest resource as a stream.</returns>
            <exception cref="T:System.ArgumentNullException">assembly is null.</exception>
            <exception cref="T:System.ArgumentNullException">resourceName is null.</exception>
            <exception cref="T:System.ArgumentException">resourceName is whitspace.</exception>
            <exception cref="T:System.InvalidOperationException">Resource was not found in the calling assembly.</exception>
            <exception cref="T:System.InvalidOperationException">The resource was not an embedded resource (that is, non-linked).</exception>
            <exception cref="T:System.NotImplementedException">Resource length is greater than Int64.MaxValue.</exception>
            <exception cref="T:System.IO.InvalidDataException">When compression method is Gzip, but the resource was not compressed using Gzip.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.OpenEmbeddedResourceStream(System.String,System.Boolean,OBeautifulCode.Reflection.Recipes.CompressionMethod)">
            <summary>
            Retrieves a stream for an embedded resource.
            </summary>
            <param name="resourceName">Name of the resource in the calling assembly.</param>
            <param name="addCallerNamespace">
            Determines whether to add the namespace of the calling method to the resource name.
            If false, then the resource name is used as-is.
            If true, then the resource name is prepended with the fully qualified namespace of the calling method, followed by a period
            (e.g. if resource name = "MyFile.txt" then it changed to something like "MyNamespace.MySubNamespace.MyFile.txt").
            </param>
            <param name="decompressionMethod">
            The compression algorithm and/or archive file format that was used to compress the resource.
            This is used to open a decompressed stream.
            </param>
            <returns>Returns the specified manifest resource as a stream.</returns>
            <exception cref="T:System.ArgumentNullException">resourceName is null.</exception>
            <exception cref="T:System.ArgumentException">resourceName is whitspace.</exception>
            <exception cref="T:System.InvalidOperationException">Resource was not found in the calling assembly.</exception>
            <exception cref="T:System.InvalidOperationException">The resource was not an embedded resource (that is, non-linked).</exception>
            <exception cref="T:System.NotImplementedException">Resource length is greater than Int64.MaxValue.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.ReadEmbeddedResourceAsString(System.String,System.Boolean,OBeautifulCode.Reflection.Recipes.CompressionMethod)">
            <summary>
            Reads an embedded resource from the calling assembly and returns as string.
            </summary>
            <param name="resourceName">Name of the resource in the calling assembly.</param>
            <param name="addCallerNamespace">
            Determines whether to add the namespace of the calling method to the resource name.
            If false, then the resource name is used as-is.
            If true, then the resource name is prepended with the fully qualified namespace of the calling method, followed by a period
            (e.g. if resource name = "MyFile.txt" then it changed to something like "MyNamespace.MySubNamespace.MyFile.txt").
            </param>
            <param name="decompressionMethod">
            The compression algorithm and/or archive file format that was used to compress the resource.
            This is used to determine how the resource should be decompressed.
            </param>
            <remarks>
            Adapted from article "Create String Variables from Embedded Resources Files" on The Code Project
            <a href="http://www.codeproject.com/KB/cs/embeddedresourcestrings.aspx"/>
            Resource information is returned only if the resource is visible to the caller, or the caller has ReflectionPermission.
            This method returns null if a private resource in another assembly is accessed and the caller does not have ReflectionPermission with the ReflectionPermissionFlag.MemberAccess flag.
            </remarks>
            <returns>Returns the specified manifest resource as a string.</returns>
            <exception cref="T:System.ArgumentNullException">resourceName is null.</exception>
            <exception cref="T:System.ArgumentException">resourceName is white space.</exception>
            <exception cref="T:System.InvalidOperationException">Resource was not found in the calling assembly.</exception>
            <exception cref="T:System.InvalidOperationException">The resource was not an embedded resource (that is, non-linked).</exception>
            <exception cref="T:System.NotImplementedException">Resource length is greater than Int64.MaxValue.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.ReadEmbeddedResourceAsBytes(System.String,System.Boolean,OBeautifulCode.Reflection.Recipes.CompressionMethod)">
            <summary>
            Reads an embedded resource from the calling assembly and returns as a byte array.
            </summary>
            <param name="resourceName">Name of the resource in the calling assembly.</param>
            <param name="addCallerNamespace">
            Determines whether to add the namespace of the calling method to the resource name.
            If false, then the resource name is used as-is.
            If true, then the resource name is prepended with the fully qualified namespace of the calling method, followed by a period
            (e.g. if resource name = "MyFile.txt" then it changed to something like "MyNamespace.MySubNamespace.MyFile.txt").
            </param>
            <param name="decompressionMethod">
            The compression algorithm and/or archive file format that was used to compress the resource.
            This is used to determine how the resource should be decompressed.
            </param>
            <returns>
            Returns the specified manifest resource as a byte array.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="resourceName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="resourceName"/> is white space.</exception>
            <exception cref="T:System.InvalidOperationException">Resource was not found in the calling assembly.</exception>
            <exception cref="T:System.InvalidOperationException">The resource was not an embedded resource (that is, non-linked).</exception>
            <exception cref="T:System.NotImplementedException">Resource length is greater than Int64.MaxValue.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.GetTypesFromAssemblies(System.Collections.Generic.IReadOnlyCollection{System.Reflection.Assembly})">
            <summary>
            Gets all types defined within a set of assemblies.
            </summary>
            <remarks>
            If you want to get all loaded types, then pass-in the result of AssemblyLoader.GetLoadedAssemblies().
            </remarks>
            <param name="assemblies">The assemblies.</param>
            <returns>
            The types defined within the specified assemblies.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyHelper.ResolveResourceName(System.String,System.Boolean)">
            <summary>
            Resolves a resource name.
            </summary>
            <param name="resourceName">The supplied resource name.</param>
            <param name="addCallerNamespace">
            Determines whether to add the namespace of the calling method to the resource name.
            If false, then the resource name is used as-is.
            If true, then the resource name is prepended with the fully qualified namespace of the calling method, followed by a period
            (e.g. if resource name = "MyFile.txt" then it changed to something like "MyNamespace.MySubNamespace.MyFile.txt").
            </param>
            <returns>
            The resolved resource name.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.AssemblyLoader">
            <summary>
            Helper that will load all the assemblies in a directory and wire up all the necessary <see cref="T:System.AppDomain" /> logic to allow them to be reflected into.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultAssemblyFileExtensionsWithoutPeriodToLoad">
            <summary>
            Default assembly file extensions to process; ONLY the file extension not including the period e.g. "dll" NOT ".dll".
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultSymbolFileExtensionsWithoutPeriodToLoad">
            <summary>
            Default symbol file extensions to process; ONLY the file extension not including the period e.g. "pdb" NOT ".pdb".
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultAssemblyFileNameRegexBlacklist">
            <summary>
            Default list of regular expressions to evaluate against each file name and skip loading on matches.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.FilePathToAssemblyMap">
            <summary>
            Gets a map of the file paths discovered to the <see cref="T:System.Reflection.Assembly" /> loaded.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.SymbolFilePaths">
            <summary>
            Gets a list of the discovered symbol file paths.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DirectoryPath">
            <summary>
            Gets the directory path to discover assemblies in.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.LoadRecursively">
            <summary>
            Gets a value indicating whether or not to discover recursively within the directory.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.AssemblyFileExtensionsWithoutPeriodToLoad">
            <summary>
            Gets the assembly file extensions to process; ONLY the file extension not including the period e.g. "dll" NOT ".dll".
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.SymbolFileExtensionsWithoutPeriodToConsider">
            <summary>
            Gets the symbol file extensions to process; ONLY the file extension not including the period e.g. "pdb" NOT ".pdb".
            </summary>
        </member>
        <member name="P:OBeautifulCode.Reflection.Recipes.AssemblyLoader.AssemblyFileNameRegexBlacklist">
            <summary>
            Gets the list of regular expressions to evaluate against each file name and skip loading on matches.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyLoader.GetLoadedAssemblies">
            <summary>
            Gets the currently loaded assemblies (excluding dynamic ones).
            </summary>
            <remarks>
            If you want to get all types, then pass-in the result of this call into AssemblyHelper.GetTypesFromAssemblies().
            </remarks>
            <returns>Currently loaded assemblies.</returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyLoader.CreateAndLoadFromDirectory(System.String,System.Action{System.String},System.Boolean,System.Collections.Generic.IReadOnlyCollection{System.String},System.Collections.Generic.IReadOnlyCollection{System.String},System.Collections.Generic.IReadOnlyCollection{System.String},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Factory method to build an initialized <see cref="T:OBeautifulCode.Reflection.Recipes.AssemblyLoader" />.
            </summary>
            <param name="directoryPath">Directory path to discover and load assemblies from.</param>
            <param name="logger">Optional logger action to log progress and messages; DEFAULT is none.</param>
            <param name="loadRecursively">Optional value indicating whether or not to discover recursively within the directory; DEFAULT is true.</param>
            <param name="assemblyFileExtensionsWithoutDotToLoad">Optional list of assembly file extensions to process; ONLY the file extension not including the period e.g. "dll" NOT ".dll"; DEFAULT is <see cref="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultAssemblyFileExtensionsWithoutPeriodToLoad" />.</param>
            <param name="symbolFileExtensionsWithoutPeriodToConsider">Optional list of symbol file extensions to process; ONLY the file extension not including the period e.g. "pdb" NOT ".pdb"; DEFAULT is <see cref="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultSymbolFileExtensionsWithoutPeriodToLoad" />.</param>
            <param name="assemblyFileNameRegexBlacklist">Optional list of regular expressions to evaluate against each file name and skip loading on matches; DEFAULT is <see cref="F:OBeautifulCode.Reflection.Recipes.AssemblyLoader.DefaultAssemblyFileNameRegexBlacklist" />.</param>
            <param name="suppressFileLoadException">Optionally suppress <see cref="T:System.IO.FileLoadException"/>.</param>
            <param name="suppressBadImageFormatException">Optionally suppress <see cref="T:System.BadImageFormatException"/>.</param>
            <param name="suppressReflectionTypeLoadException">Optionally suppress <see cref="T:System.Reflection.ReflectionTypeLoadException"/>.</param>
            <returns>Initialized <see cref="T:OBeautifulCode.Reflection.Recipes.AssemblyLoader" /> this needs to be in scope and is disposable so keep this alive at your most top level while reflecting.</returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyLoader.Initialize(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initializes the manager by configuring <see cref="T:System.AppDomain" /> hooks and discovering then loading the assemblies in the given path.
            </summary>
            <param name="suppressFileLoadException">Optionally suppress <see cref="T:System.IO.FileLoadException"/>.</param>
            <param name="suppressBadImageFormatException">Optionally suppress <see cref="T:System.BadImageFormatException"/>.</param>
            <param name="suppressReflectionTypeLoadException">Optionally suppress <see cref="T:System.Reflection.ReflectionTypeLoadException"/>.</param>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.AssemblyLoader.Dispose">
            <inheritdoc cref="T:System.IDisposable" />
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.BindingFlagsFor">
            <summary>
            Contains some pre-configured <see cref="T:System.Reflection.BindingFlags"/>.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredAndInheritedMembers">
            <summary>
            Finds all (public, protected, internal, private) instance and static members that are declared at the level of the specified type's hierarchy or inherited.
            Note that when an interface implements another interface (and so on), those implemented interfaces are NOT considered to be inherited.
            <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)"/>
            Note that private members in specified type's inheritance path are NOT inherited.  Public, internal, and protected members are.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredAndInheritedInstanceMembers">
            <summary>
            Finds all (public, protected, internal, private) instance (not static) members that are declared at the level of the specified type's hierarchy or inherited.
            Note that when an interface implements another interface (and so on), those implemented interfaces are NOT considered to be inherited.
            <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)"/>
            Note that private members in specified type's inheritance path are NOT inherited.  Public, internal, and protected members are.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredAndInheritedStaticMembers">
            <summary>
            Finds all static (not instance) members that are declared at the level of the specified type's hierarchy or inherited.
            Note that when an interface implements another interface (and so on), those implemented interfaces are NOT considered to be inherited.
            <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)"/>
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredAndInheritedMembers">
            <summary>
            Finds public (not protected, not internal, not private) instance and public static members that are declared at the level of the specified type's hierarchy or inherited.
            Note that when an interface implements another interface (and so on), those implemented interfaces are NOT considered to be inherited.
            <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)"/>
            Note that private members in specified type's inheritance path are NOT inherited.  Public, internal, and protected members are.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredAndInheritedInstanceMembers">
            <summary>
            Finds public (not protected, not internal, not private) instance (not static) members that are declared at the level of the specified type's hierarchy or inherited.
            Note that when an interface implements another interface (and so on), those implemented interfaces are NOT considered to be inherited.
            <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)"/>
            Note that private members in specified type's inheritance path are NOT inherited.  Public, internal, and protected members are.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredAndInheritedStaticMembers">
            <summary>
            Finds public (not protected, not internal, not private) static (not instance) members that are declared at the level of the specified type's hierarchy or inherited.
            Note that private members in specified type's inheritance path are NOT inherited.  Public, internal, and protected members are.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredButNotInheritedMembers">
            <summary>
            Finds all (public, protected, internal, private) instance and static members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredButNotInheritedInstanceMembers">
            <summary>
            Finds all (public, protected, internal, private) instance (not static) members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.AllDeclaredButNotInheritedStaticMembers">
            <summary>
            Finds all (public, protected, internal, private) static (not instance) members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredButNotInheritedMembers">
            <summary>
            Finds public (not protected, not internal, not private) instance or static members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredButNotInheritedInstanceMembers">
            <summary>
            Finds public (not protected, not internal, not private) instance (not static) members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.BindingFlagsFor.PublicDeclaredButNotInheritedStaticMembers">
            <summary>
            Finds public (not protected, not internal, not private) static (not instance) members that are declared at the level of the specified type's hierarchy (not inherited).
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.CompressionMethod">
            <summary>
            Determines the compression algorithm and/or archive file format used to compress a resource.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.CompressionMethod.None">
            <summary>
            The resource is not compressed.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.CompressionMethod.Gzip">
            <summary>
            The resource is compressed using the gzip file format,
            using the DEFLATE algorithm.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy">
            <summary>
            Specifies the strategy to use when matching constructors and properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy.Invalid">
            <summary>
            Invalid (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy.AllConstructorParametersHaveMatchingProperty">
            <summary>
            Include constructors where every constructor parameter matches to a property.
            If there a default (parameterless) constructor, it will be considered a match
            regardless of the properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy.AllConstructorParametersHaveMatchingPropertyWithNoUnmatchedProperties">
            <summary>
            Include constructors where every constructor parameter matches to a property
            and there are no unmatched properties.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers">
            <summary>
            Scopes the search for members based on access modifiers.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.Public">
            <summary>
            Include public members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.Internal">
            <summary>
            Include internal members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.ProtectedInternal">
            <summary>
            Include internal members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.Protected">
            <summary>
            Include protected members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PrivateProtected">
            <summary>
            Include private protected members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.Private">
            <summary>
            Include private members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PublicGet">
            <summary>
            Include properties with a public getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.InternalGet">
            <summary>
            Include properties with a internal getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.ProtectedInternalGet">
            <summary>
            Include properties with a protected internal getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.ProtectedGet">
            <summary>
            Include properties with a protected getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PrivateProtectedGet">
            <summary>
            Include properties with a private protected getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PrivateGet">
            <summary>
            Include properties with a private getter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PublicSet">
            <summary>
            Include properties with a public setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.InternalSet">
            <summary>
            Include properties with a internal setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.ProtectedInternalSet">
            <summary>
            Include properties with a protected internal setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.ProtectedSet">
            <summary>
            Include properties with a protected setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PrivateProtectedSet">
            <summary>
            Include properties with a private protected setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.PrivateSet">
            <summary>
            Include properties with a private setter.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAccessModifiers.All">
            <summary>
            Include members having any supported access modifier.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberAttributes">
            <summary>
            Scopes the search for members based on the presence or absence of certain attributes on those members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAttributes.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAttributes.CompilerGenerated">
            <summary>
            Include compiler-generated members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAttributes.NotCompilerGenerated">
            <summary>
            Include members that are not compiler-generated.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberAttributes.All">
            <summary>
            Include members having or not having all special attributes.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberKinds">
            <summary>
            Scopes the search for members based on the kind of member.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.Field">
            <summary>
            Include fields.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.Property">
            <summary>
            Include properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.Constructor">
            <summary>
            Include constructors.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.Method">
            <summary>
            Include methods.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.Event">
            <summary>
            Include events.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.NestedType">
            <summary>
            Include nested types.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberKinds.All">
            <summary>
            Include all kinds of members.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberMutability">
            <summary>
            Scopes the search for members based on mutability.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.Applicable">
            <summary>
            Include members where mutability is applicable (i.e. fields and properties).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.NotApplicable">
            <summary>
            Include members where mutability is not applicable (i.e. constructors, methods, events).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.Readable">
            <summary>
            Include readable properties and all fields, otherwise not applicable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.Writable">
            <summary>
            Include writable members.
            This is only applicable to fields (readonly and const fields are NOT considered writable) and properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.NotWritable">
            <summary>
            Include members that cannot be written-to.
            This is only applicable to fields (readonly and const fields are considered to be not writable) and properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.NotReadable">
            <summary>
            Include properties that are not readable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.ReadOnlyOrConst">
            <summary>
            Include members that cannot be written-to.
            This is only applicable to fields (readonly and const) and properties.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.WriteOnly">
            <summary>
            Include properties that are not readable.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberMutability.All">
            <summary>
            Include members where mutability is not applicable and where applicable,
            include members with any kind of mutability.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberOwners">
            <summary>
            Scopes the search for members based on who owns the member.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberOwners.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberOwners.Instance">
            <summary>
            Include members owned by an object.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberOwners.Static">
            <summary>
            Include members owned by the type itself.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberOwners.All">
            <summary>
            Include members owned by an object or owned by the type itself.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.MemberRelationships">
            <summary>
            Scopes the search for members based on their relationship to a specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.None">
            <summary>
            None (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInType">
            <summary>
            Include members declared in the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.InheritedByType">
            <summary>
            Include members inherited by the specified type.
            Private members of base types are not inherited and would not be
            returned when using this flag; <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInAncestorTypes"/>.
            </summary>
            <remarks>
            Inherited members' <see cref="P:System.Reflection.MemberInfo.ReflectedType"/> will be the specified type,
            NOT the <see cref="P:System.Reflection.MemberInfo.DeclaringType"/>.  There is a subtle but consequential
            difference between the members returned when this flag is set versus those returned
            when <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInAncestorTypes"/> is set
            (if both are set, then only <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInAncestorTypes"/> is used).
            Because the <see cref="P:System.Reflection.MemberInfo.ReflectedType"/> type is different, the members
            may have different property values.  For example, if a base class contains a public
            property with a private setter, the <see cref="P:System.Reflection.PropertyInfo.SetMethod"/> will be
            null using <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.InheritedByType"/>, and not null when using <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInAncestorTypes"/>.
            The property will NOT be considered <see cref="F:OBeautifulCode.Reflection.Recipes.MemberMutability.Writable"/> when
            <see cref="P:System.Reflection.PropertyInfo.SetMethod"/> is null.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInAncestorTypes">
            <summary>
            Include members declared in all ancestor types.
            This would include private members of base types.
            </summary>
            <remarks>
            This flag supersedes <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.InheritedByType"/>.
            Unlike <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.InheritedByType"/>, members declared in ancestor types will
            have a <see cref="P:System.Reflection.MemberInfo.ReflectedType"/> that equals <see cref="P:System.Reflection.MemberInfo.DeclaringType"/>
            See remarks for <see cref="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.InheritedByType"/> about why/when this matters.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInImplementedInterfaceTypes">
            <summary>
            Include members declared in all interfaces implemented by the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredOrInherited">
            <summary>
            Include members declared in or inherited by the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInTypeOrAncestorTypes">
            <summary>
            Include members that are declared in the specified type or declared in all ancestor types.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.MemberRelationships.DeclaredInTypeOrImplementedInterfaces">
            <summary>
            Include members that are declared in the specified type or are declared in all interfaces implemented by the specified type.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.OrderMembersBy">
            <summary>
            Specifies how to order members in a method that returns members.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.OrderMembersBy.None">
            <summary>
            None (default).  No particular order.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.OrderMembersBy.MemberName">
            <summary>
            Order by member name.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.OrderMembersBy.DeclaringTypeDerivationPath">
            <summary>
            Order by the declaring type derivation path
            (e.g. members declared in type.BaseType.BaseType, followed by type.BaseType, followed by the type itself).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Reflection.Recipes.OrderMembersBy.DeclaringTypeDerivationPathThenByMemberName">
            <summary>
            Order first by the declaring type derivation path
            (e.g. members declared in type.BaseType.BaseType, followed by type.BaseType, followed by the type itself)
            and then by member name within each of these.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Reflection.Recipes.ReflectionHelper">
            <summary>
            Provides useful methods related to reflection.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttribute``1(System.Type)">
            <summary>
            Gets the specified type of attribute, applied to a specified type.
            </summary>
            <typeparam name="TAttribute">The type of the attribute to return.</typeparam>
            <param name="type">The type to scope the attribute search to.</param>
            <returns>
            The attribute of type <typeparamref name="TAttribute"/> that has been applied
            to <paramref name="type"/> or null if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="type"/> has multiple attributes of type <typeparamref name="TAttribute"/>.  Consider calling <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributes``1(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributes``1(System.Type)">
            <summary>
            Gets all attributes of a specified type that have been applied to some type.
            Only useful when the attribute is configured such that more one instance can be applied.
            </summary>
            <remarks>
            adapted from <a href="http://stackoverflow.com/a/2656211/356790"/>.
            </remarks>
            <typeparam name="TAttribute">The type of the attributes to return.</typeparam>
            <param name="type">The type to scope the attribute search to.</param>
            <returns>
            A collection all attributes of the specified type that have been applied to the specified
            enum value or an empty collection if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributeOnEnumValue``1(System.Object)">
            <summary>
            Gets the specified type of attribute, applied to a specific enum value.
            </summary>
            <typeparam name="TAttribute">The type of the attribute to return.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <returns>
            An attribute object of the specified type that has been applied to the specified
            enum value or null if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumValue"/> is not an Enum.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="enumValue"/> has multiple attributes of type <typeparamref name="TAttribute"/>.  Consider calling <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributesOnEnumValue``1(System.Enum)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributeOnEnumValue``1(System.Enum)">
            <summary>
            Gets the specified type of attribute, applied to a specific enum value.
            </summary>
            <typeparam name="TAttribute">The type of the attribute to return.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <returns>
            An attribute object of the specified type that has been applied to the specified
            enum value or null if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="enumValue"/> has multiple attributes of type <typeparamref name="TAttribute"/>.  Consider calling <see cref="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributesOnEnumValue``1(System.Enum)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributesOnEnumValue``1(System.Object)">
            <summary>
            Gets all attributes of the specified type that have been applied to a specific enum value.
            Only useful when the attribute is configured such that more one instance can be applied to an enum value.
            </summary>
            <typeparam name="TAttribute">The type of the attributes to return.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <returns>
            A collection all attributes of the specified type that have been applied to the specified
            enum value or an empty collection if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumValue"/> is not an Enum.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetAttributesOnEnumValue``1(System.Enum)">
            <summary>
            Gets all attributes of the specified type that have been applied to a specific enum value.
            Only useful when the attribute is configured such that more one instance can be applied to an enum value.
            </summary>
            <remarks>
            adapted from <a href="http://stackoverflow.com/a/9276348/356790"/>.
            </remarks>
            <typeparam name="TAttribute">The type of the attributes to return.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <returns>
            A collection all attributes of the specified type that have been applied to the specified
            enum value or an empty collection if no such attribute has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasAttribute``1(System.Type,System.Boolean)">
            <summary>
            Determines if an attribute of a specified type that have been applied to some type.
            </summary>
            <typeparam name="TAttribute">The type of the attributes to search for.</typeparam>
            <param name="type">The type to scope the attribute search to.</param>
            <param name="throwOnMultiple">
            Optional.  Determines if method should throw when multiple instances of the specified
            attribute have been applied to the specified type.  Default is true
            (it's typically unlikely that multiple attributes of the same type are applied to a type).
            </param>
            <returns>
            True if the attribute has been applied to the specified type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="throwOnMultiple"/> is true and <paramref name="type"/> has multiple attributes of type <typeparamref name="TAttribute"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasAttributeOnEnumValue``1(System.Object,System.Boolean)">
            <summary>
            Determines if an attribute of the specified type has been applied to a specific enum value.
            </summary>
            <typeparam name="TAttribute">The type of the attributes to search for.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <param name="throwOnMultiple">
            Optional.  Determines if method should throw when multiple instances of the specified
            attribute have been applied to the specified enum value.  Default is true
            (it's typically unlikely that multiple attributes of the same type are applied to an enum value).
            </param>
            <returns>
            True if the attribute has been applied to the specified enum value, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="enumValue"/> is not an Enum.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="throwOnMultiple"/> is true and <paramref name="enumValue"/> has multiple attributes of type <typeparamref name="TAttribute"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasAttributeOnEnumValue``1(System.Enum,System.Boolean)">
            <summary>
            Determines if an attribute of the specified type that has been applied to a specific enum value.
            </summary>
            <typeparam name="TAttribute">The type of the attributes to search for.</typeparam>
            <param name="enumValue">The enum value to scope the attribute search to.</param>
            <param name="throwOnMultiple">
            Optional.  Determines if method should throw when multiple instances of the specified
            attribute have been applied to the specified enum value.  Default is true
            (it's typically unlikely that multiple attributes of the same type are applied to an enum value).
            </param>
            <returns>
            True if the attribute has been applied to the specified enum value, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumValue"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetConstructorsFiltered(System.Type,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberAttributes,OBeautifulCode.Reflection.Recipes.OrderMembersBy)">
            <summary>
            Gets the constructors of the specified type,
            with various options to control the scope of constructors included and optionally order the constructors.
            </summary>
            <param name="type">The type.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
            <returns>
            The constructors in the specified order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.Construct(System.Type,System.Object[])">
            <summary>
            Constructs an object of the specified type.
            </summary>
            <param name="type">The type of object to construct.</param>
            <param name="parameters">
            An array of arguments that match in number, order, and type the parameters of the constructor to invoke.
            If an empty array or null, the constructor that takes no parameters (the default constructor) is invoked.
            </param>
            <returns>
            A reference to the newly created object.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.Exception">Various exceptions thrown by <see cref="M:System.Activator.CreateInstance(System.Type,System.Object[])"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.Construct``1(System.Object[])">
            <summary>
            Constructs an object of the specified type.
            </summary>
            <typeparam name="T">The type of object to create.</typeparam>
            <param name="parameters">
            An array of arguments that match in number, order, and type the parameters of the constructor to invoke.
            If an empty array or null, the constructor that takes no parameters (the default constructor) is invoked.
            </param>
            <returns>
            A reference to the newly created object.
            </returns>
            <exception cref="T:System.Exception">Any exception thrown by <see cref="M:System.Activator.CreateInstance(System.Type,System.Object[])"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.Construct``1(System.Type,System.Object[])">
            <summary>
            Constructs an object of the specified type.
            </summary>
            <typeparam name="T">The return type.</typeparam>
            <param name="type">The type of object to construct.</param>
            <param name="parameters">
            An array of arguments that match in number, order, and type the parameters of the constructor to invoke.
            If an empty array or null, the constructor that takes no parameters (the default constructor) is invoked.
            </param>
            <returns>
            A reference to the newly created object.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.Exception">Any exception thrown by <see cref="M:System.Activator.CreateInstance(System.Type,System.Object[])"/>.</exception>
            <exception cref="T:System.InvalidCastException">The created object could not be cast to a <typeparamref name="T"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetConstructorsMatchedToProperties(System.Type,System.Collections.Generic.IReadOnlyCollection{System.Reflection.PropertyInfo},OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberRelationships)">
            <summary>
            Finds constructors having parameters that correspond to a set of properties, matching on name (case-insensitive) and type.
            </summary>
            <remarks>
            For type matching, we check that a constructor parameter type can be assigned it's corresponding property's type
            and vice-versa.  If either direction succeeds, we consider it a match.
            </remarks>
            <param name="classType">The class type.</param>
            <param name="properties">The properties.</param>
            <param name="matchStrategy">Determines which constructors will be deemed as matching.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for constructors based on access modifiers.  DEFAULT is to include public constructors.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for constructors based on their relationship to <paramref name="classType"/>.  DEFAULT is to include constructors declared on the type.</param>
            <returns>
            The matching constructors, or an empty collection if there are no matches.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="classType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="classType"/> is not a class.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="properties"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="properties"/> has a null element.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="properties"/> contains two or more members with the same name.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="matchStrategy"/> is <see cref="F:OBeautifulCode.Reflection.Recipes.ConstructorsMatchedToPropertiesStrategy.Invalid"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsDefaultConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Determines if the specified constructor is the default (parameterless) constructor.
            </summary>
            <param name="constructor">The constructor.</param>
            <returns>
            true if the specified constructor is the default (parameterless) constructor; otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetTypesHaving``1(System.Reflection.Assembly,System.Func{``0,System.Boolean})">
            <summary>
            Gets all types in an assembly that have an attribute of a specified type.
            </summary>
            <typeparam name="TAttribute">The type of attribute to search for.</typeparam>
            <param name="assembly">The assembly to search.</param>
            <param name="attributeFilter">
            Optional.  When provided, requires that this filter
            return true when attributes of the specified type are passed-in,
            before the type having the specified attribute is returned.
            </param>
            <returns>
            The types in an assembly where the specified attribute has been
            applied at least one, or an empty collection if none of the
            types in the assembly have that attribute.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetEnumValuesHaving``2(System.Func{``1,System.Boolean})">
            <summary>
            Gets all values/members of an enum that have an attribute of a specified type.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <typeparam name="TAttribute">The type of attribute to search for.</typeparam>
            <param name="attributeFilter">
            Optional.  When provided, requires that this filter
            return true when attributes of the specified type are passed-in,
            before the enum value having the specified attribute is returned.
            </param>
            <returns>
            The values/members of a specified enum values where the specified
            attribute has been applied at least one, or an empty collection if none of the specified
            enum values have that attribute.
            </returns>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not an enum.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetEnumValuesHaving``1(System.Type,System.Func{``0,System.Boolean})">
            <summary>
            Gets all values/members of an enum that have an attribute of a specified type.
            </summary>
            <typeparam name="TAttribute">The type of attribute to search for.</typeparam>
            <param name="enumType">The type of the enum.</param>
            <param name="attributeFilter">
            Optional.  When provided, requires that this filter
            return true when attributes of the specified type are passed-in,
            before the enum value having the specified attribute is returned.
            </param>
            <returns>
            The values/members of a specified enum values where the specified
            attribute has been applied at least one, or an empty collection if none of the specified
            enum values have that attribute.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> is not an enum.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetFieldsFiltered(System.Type,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes,OBeautifulCode.Reflection.Recipes.OrderMembersBy)">
            <summary>
            Gets the fields of the specified type,
            with various options to control the scope of fields included and optionally order the fields.
            </summary>
            <param name="type">The type.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
            <returns>
            The fields in the specified order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetFieldFiltered(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes,System.Boolean)">
            <summary>
            Gets the <see cref="T:System.Reflection.FieldInfo"/> for the specified field.
            </summary>
            <param name="type">The type.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="throwIfNotFound">OPTIONAL value indicating whether to throw if no fields are found.  DEFAULT is to throw..</param>
            <returns>
            The <see cref="T:System.Reflection.FieldInfo"/> or null if no fields are found and <paramref name="throwIfNotFound"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints and <paramref name="throwIfNotFound"/> is true.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetFieldValue``1(System.Object,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a field.
            </summary>
            <typeparam name="T">The type of the field.</typeparam>
            <param name="item">The object.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the field.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The field does not have a get method.</exception>
            <exception cref="T:System.InvalidCastException">The field is not of the specified type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetFieldValue(System.Object,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a field.
            </summary>
            <param name="item">The object.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the field.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The field does not have a get method.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetStaticFieldValue``1(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a static field.
            </summary>
            <typeparam name="T">The type of the field.</typeparam>
            <param name="type">The type that contains the field.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the field.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The field does not have a get method.</exception>
            <exception cref="T:System.InvalidCastException">The field is not of the specified type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetStaticFieldValue(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a field on a static type.
            </summary>
            <param name="type">The type that contains the field.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the field.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The field does not have a get method.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasField(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Determines if a type has a field of the specified field name.
            </summary>
            <param name="type">The type to check.</param>
            <param name="fieldName">The name of the field to check for.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            true if the type has a field of the specified field name, false if not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsConstField(System.Reflection.FieldInfo)">
            <summary>
            Determines if the specified field is const (not readonly).
            </summary>
            <param name="fieldInfo">The field.</param>
            <returns>
            true if the specified field is const (not readonly), otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsNotWritableField(System.Reflection.FieldInfo)">
            <summary>
            Determines if the specified field is not writable (is readonly or const).
            </summary>
            <param name="fieldInfo">The field.</param>
            <returns>
            true if the specified field is not writable, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsReadOnlyField(System.Reflection.FieldInfo)">
            <summary>
            Determines if the specified field is readonly (not const).
            </summary>
            <param name="fieldInfo">The field.</param>
            <returns>
            true if the specified field is readonly (not const), otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsReadOnlyOrConstField(System.Reflection.FieldInfo)">
            <summary>
            Determines if the specified field is readonly or const.
            </summary>
            <param name="fieldInfo">The field.</param>
            <returns>
            true if the specified field is readonly or const, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsWritableField(System.Reflection.FieldInfo)">
            <summary>
            Determines if the specified field is writable (not readonly and not const).
            </summary>
            <param name="fieldInfo">The field.</param>
            <returns>
            true if the specified field is writable, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.SetFieldValue(System.Object,System.String,System.Object,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Sets a field's value.
            </summary>
            <param name="item">The object.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="value">The value to set the field to.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign null to the field's type.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign <paramref name="value"/> type to the field's type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.SetStaticFieldValue(System.Type,System.String,System.Object,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Sets a static field's value.
            </summary>
            <param name="type">The type that contains the field.</param>
            <param name="fieldName">The name of the field.</param>
            <param name="value">The value to set the field to.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign null to the field's type.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign <paramref name="value"/> type to the field's type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetMembersFiltered(System.Type,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberKinds,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes,OBeautifulCode.Reflection.Recipes.OrderMembersBy)">
            <summary>
            Gets the members (fields, properties, constructors, methods, and events) of the specified type,
            with various options to control the scope of members included and optionally order the members.
            </summary>
            <param name="type">The type.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberKinds">OPTIONAL value that scopes the search for members based on the kind of member.  DEFAULT is to include all kinds of members.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
            <returns>
            The members in the specified order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsCompilerGenerated(System.Reflection.MemberInfo)">
            <summary>
            Determines if the specified member is compiler-generated.
            </summary>
            <param name="memberInfo">The member info.</param>
            <returns>
            True if the member is compiler-generated, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetUnderlyingType(System.Reflection.MemberInfo)">
            <summary>
            Gets the underlying type of the specified <see cref="T:System.Reflection.MemberInfo"/>.
            </summary>
            <param name="memberInfo">The member info.</param>
            <returns>
            The underlying type of the specified <see cref="T:System.Reflection.MemberInfo"/>.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetMethodsFiltered(System.Type,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberAttributes,OBeautifulCode.Reflection.Recipes.OrderMembersBy)">
            <summary>
            Gets the methods of the specified type,
            with various options to control the scope of methods included and optionally order the methods.
            </summary>
            <param name="type">The type.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
            <returns>
            The methods in the specified order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetInterfaceDeclaredAndImplementedMethods(System.Type)">
            <summary>
            Gets the specified interface type's methods along with the methods of all implemented interfaces.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <returns>
            The methods declared on the specified interface along with the methods of all implemented interfaces.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="interfaceType"/> is not an interface type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetMethodFiltered(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberAttributes,System.Boolean)">
            <summary>
            Gets the <see cref="T:System.Reflection.MethodInfo"/> for the specified method.
            </summary>
            <param name="type">The type.</param>
            <param name="methodName">The name of the method.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="throwIfNotFound">OPTIONAL value indicating whether to throw if no methods are found.  DEFAULT is to throw..</param>
            <returns>
            The <see cref="T:System.Reflection.MethodInfo"/> or null if no methods are found and <paramref name="throwIfNotFound"/> is false
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="methodName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="methodName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no method named <paramref name="methodName"/> on the object type using the specified binding constraints and <paramref name="throwIfNotFound"/> is true.</exception>
            <exception cref="T:System.ArgumentException">There is more than one method named <paramref name="methodName"/> on the object type using the specified binding constraints.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasMethod(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Determines if a type has a method of the specified method name.
            </summary>
            <param name="type">The type to check.</param>
            <param name="methodName">The name of the method to check for.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            true if the type has a method of the specified method name, false if not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="methodName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="methodName"/> is whitespace.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetPropertiesFiltered(System.Type,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes,OBeautifulCode.Reflection.Recipes.OrderMembersBy)">
            <summary>
            Gets the properties of the specified type,
            with various options to control the scope of properties included and optionally order the properties.
            </summary>
            <param name="type">The type.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
            <returns>
            The properties in the specified order.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetPropertyFiltered(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes,System.Boolean)">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the specified property.
            </summary>
            <param name="type">The type.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <param name="throwIfNotFound">OPTIONAL value indicating whether to throw if no properties are found.  DEFAULT is to throw..</param>
            <returns>
            The <see cref="T:System.Reflection.PropertyInfo"/> or null if no properties are found and <paramref name="throwIfNotFound"/> is false
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints and <paramref name="throwIfNotFound"/> is true.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetPropertyValue``1(System.Object,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a property.
            </summary>
            <typeparam name="T">The type of the property.</typeparam>
            <param name="item">The object.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the property.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The property does not have a get method.</exception>
            <exception cref="T:System.InvalidCastException">The property is not of the specified type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetPropertyValue(System.Object,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a property.
            </summary>
            <param name="item">The object.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the property.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The property does not have a get method.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetStaticPropertyValue``1(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a static property.
            </summary>
            <typeparam name="T">The type of the property.</typeparam>
            <param name="type">The type that contains the property.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the property.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The property does not have a get method.</exception>
            <exception cref="T:System.InvalidCastException">The property is not of the specified type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.GetStaticPropertyValue(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Gets the value of a property on a static type.
            </summary>
            <param name="type">The type that contains the property.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            The value of the property.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">The property does not have a get method.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.HasProperty(System.Type,System.String,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Determines if a type has a property of the specified property name.
            </summary>
            <param name="type">The type to check.</param>
            <param name="propertyName">The name of the property to check for.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <returns>
            true if the type has a property of the specified property name, false if not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsNotWritableProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is not writable (is read-only).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is not writable, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsNotReadableProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is not readable (is write-only).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is not readable, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsReadableProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is readable (has a getter).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is readable, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsReadOnlyProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is a read-only (has no setter).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is read-only, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsReadOnlyAutoProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is a read-only auto property
            (i.e. MyProperty { get; }).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is a read-only auto-property, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsWritableProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is writable (has a setter).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is writable, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.IsWriteOnlyProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is a write-only (has no getter).
            </summary>
            <param name="propertyInfo">The property.</param>
            <returns>
            true if the specified property is write-only, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.SetPropertyValue(System.Object,System.String,System.Object,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberOwners,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Sets a property's value.
            </summary>
            <param name="item">The object.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="value">The value to set the property to.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign null to the property's type.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign <paramref name="value"/> type to the property's type.</exception>
        </member>
        <member name="M:OBeautifulCode.Reflection.Recipes.ReflectionHelper.SetStaticPropertyValue(System.Type,System.String,System.Object,OBeautifulCode.Reflection.Recipes.MemberRelationships,OBeautifulCode.Reflection.Recipes.MemberAccessModifiers,OBeautifulCode.Reflection.Recipes.MemberMutability,OBeautifulCode.Reflection.Recipes.MemberAttributes)">
            <summary>
            Sets a static property's value.
            </summary>
            <param name="type">The type that contains the property.</param>
            <param name="propertyName">The name of the property.</param>
            <param name="value">The value to set the property to.</param>
            <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
            <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
            <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
            <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
            <exception cref="T:System.ArgumentException">There is no property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.ArgumentException">There is more than one property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign null to the property's type.</exception>
            <exception cref="T:System.InvalidCastException">Unable to assign <paramref name="value"/> type to the property's type.</exception>
        </member>
        <member name="T:OBeautifulCode.String.Recipes.StringExtensions">
            <summary>
            Adds some convenient extension methods to strings.
            </summary>
        </member>
        <member name="F:OBeautifulCode.String.Recipes.StringExtensions.DateTimeKindToPreferredFormatStringMap">
            <summary>
            Specifies a map of <see cref="T:System.DateTimeKind"/> to the preferred format string to use for that kind.
            </summary>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.AppendMissing(System.String,System.String)">
            <summary>
            Appends one string to the another (base) if the base string
            doesn't already end with the string to append.
            </summary>
            <param name="value">The base string.</param>
            <param name="shouldEndWith">The string to append.</param>
            <remarks>
            If the string to append is the empty string, this method will always return the base string.
            </remarks>
            <returns>
            The inputted string where the last character is a backslash.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="shouldEndWith"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.FromCsv(System.String,System.String)">
            <summary>
            Parses a CSV string and returns the values.
            </summary>
            <param name="value">The CSV to parse.</param>
            <param name="nullValueEncoding">Optional value indicating how nulls are encoded.  Defaulted to null, which results in a list that never contains null.</param>
            <returns>
            Returns the values contained within a CSV.
            If <paramref name="value"/> is null, returns an empty list.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.IsAlphanumeric(System.String)">
            <summary>
            Determines if a string is alpha numeric.
            </summary>
            <param name="value">The string to evaluate.</param>
            <remarks>
            An empty string ("") is considered alpha-numeric.
            </remarks>
            <returns>
            Returns true if the string is alpha-numeric, false if not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.IsAlphabetic(System.String)">
            <summary>
            Determines if a string is alphabetic.
            </summary>
            <param name="value">The string to evaluate.</param>
            <remarks>
            An empty string ("") is considered alphabetic.
            </remarks>
            <returns>
            Returns true if the string is alphabetic, false if not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.IsAsciiPrintable(System.String)">
            <summary>
            Determines if a string is in the ASCII printable character set.
            </summary>
            <param name="value">The string to evaluate.</param>
            <remarks>
            An empty string ("") is considered to be in the printable set.
            </remarks>
            <returns>
            Returns true if all of the characters in the string are printable; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ReplaceCaseInsensitive(System.String,System.String,System.String)">
            <summary>
            Performs a fast case-insensitive string replacement.
            </summary>
            <remarks>
            adapted from <a href="http://www.codeproject.com/KB/string/fastestcscaseinsstringrep.aspx"/>
            If newValue is null, all occurrences of oldValue are removed.
            </remarks>
            <param name="value">the string being searched.</param>
            <param name="oldValue">string to be replaced.</param>
            <param name="newValue">string to replace all occurrences of oldValue.</param>
            <returns>
            A string where the case-insensitive string replacement has been applied.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="oldValue"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="oldValue"/> is an empty string.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ReplaceTokens(System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Replaces tokens in a specified string value with the specified replacement values.
            </summary>
            <remarks>
            DO NOT use this method if your replacement values contain tokens themselves.
            This method does not process tokens in any guaranteed order.
            </remarks>
            <param name="value">The string containing tokens to replace.</param>
            <param name="tokenToReplacementValueMap">
            A map of the case-sensitive tokens to their replacement values.
            If a replacement value is null, an empty string will be used.
            </param>
            <returns>
            The result of replacing all tokens in <paramref name="value"/> with their replacement value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="tokenToReplacementValueMap"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.SplitIntoChunksOfLength(System.String,System.Int32)">
            <summary>
            Splits a string into chunks of a specified length.
            </summary>
            <param name="value">The string to split.</param>
            <param name="lengthPerChunk">The length of each chunk when splitting the specified string.</param>
            <returns>
            <paramref name="value"/> split into an ordered list of chunks, where each chunk is of length <paramref name="lengthPerChunk"/>.
            If the length of <paramref name="value"/> cannot be evenly divided by <paramref name="lengthPerChunk"/>, then the last
            chunk will contain less characters.  No characters are truncated.  If <paramref name="value"/> is the empty string
            then an empty list is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengthPerChunk"/> is &lt;= 0.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToAlphanumeric(System.String)">
            <summary>
            Converts the specified string to an alpha-numeric string
            by removing all non-alpha-numeric characters.
            </summary>
            <param name="value">The string to convert.</param>
            <remarks>
            An empty string ("") is considered alpha-numeric.
            </remarks>
            <returns>
            The specified string with all non-alpha-numeric characters removed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToAsciiBytes(System.String)">
            <summary>
            Encodes all characters in a given string to an array of bytes encoded in ASCII.
            </summary>
            <param name="value">The string to encode.</param>
            <returns>byte array representing the string in ASCII.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToBytes(System.String,System.Text.Encoding)">
            <summary>
            Converts a string to a byte-array with a given encoding.
            </summary>
            <param name="value">The string to encode.</param>
            <param name="encoding">The encoding to use.</param>
            <returns>byte array representing the string in a given encoding.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="encoding"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToCsvSafe(System.String)">
            <summary>
            Makes a string safe to insert as a value into a
            comma separated values (CSV) object such as a file.
            </summary>
            <remarks>
            Here are the rules for making a string CSV safe:
            <a href="http://en.wikipedia.org/wiki/Comma-separated_values" />.
            </remarks>
            <param name="value">The string to make safe.</param>
            <returns>
            Returns a string that is safe to insert into a CSV object.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToLowerTrimmed(System.String)">
            <summary>
            Converts a string to lower-case and removes all leading and
            trailing white-space characters, using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <returns>The string converted to lower-case with all leading and trailing white-space characters removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToLowerTrimmed(System.String,System.Globalization.CultureInfo)">
            <summary>
            Converts a string to lower-case and removes all leading and
            trailing white-space characters, using the specified <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <param name="cultureInfo">Provides information about the specific culture.</param>
            <returns>The string converted to lower-case with all leading and trailing white-space characters removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="cultureInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUpperTrimmed(System.String)">
            <summary>
            Converts a string to upper-case and removes all leading and
            trailing white-space characters, using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <returns>The string converted to upper-case with all leading and trailing white-space characters removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUpperTrimmed(System.String,System.Globalization.CultureInfo)">
            <summary>
            Converts a string to upper-case and removes all leading and
            trailing white-space characters, using the specified <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <param name="cultureInfo">Provides information about the specific culture.</param>
            <returns>The string converted to upper-case with all leading and trailing white-space characters removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="cultureInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToLowerFirstCharacter(System.String)">
            <summary>
            Converts the first character of the specified string to lower-case, using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <returns>The string with the first character converted to lower-case.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToLowerFirstCharacter(System.String,System.Globalization.CultureInfo)">
            <summary>
            Converts the first character of the specified string to lower-case, using the specified <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <param name="cultureInfo">Provides information about the specific culture.</param>
            <returns>The string with the first character converted to lower-case.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="cultureInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.SByte)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.SByte},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Byte)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Byte},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Int16)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Int16},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.UInt16)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.UInt16},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Int32)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.UInt32)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.UInt32},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Int64)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Int64},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.UInt64)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.UInt64},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Single)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Single},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Double)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Double},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Decimal)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Decimal},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Guid)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.Guid},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.DateTime)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The invariant culture string representation of the specified value.
            </returns>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToStringInvariantPreferred(System.Nullable{System.DateTime},System.Boolean)">
            <summary>
            Gets the preferred string representation of a specified value using the invariant culture.
            </summary>
            <param name="value">The value.</param>
            <param name="throwIfNull">OPTIONAL value that determines whether to throw if <paramref name="value"/> is null.  DEFAULT is to throw.</param>
            <returns>
            The invariant culture string representation of the specified value or null if <paramref name="value"/> is null and <paramref name="throwIfNull"/> is false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null and <paramref name="throwIfNull"/> is true.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUpperFirstCharacter(System.String)">
            <summary>
            Converts the first character of the specified string to upper-case, using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <returns>The string with the first character converted to upper-case.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUpperFirstCharacter(System.String,System.Globalization.CultureInfo)">
            <summary>
            Converts the first character of the specified string to upper-case, using the specified <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="value">The string to operate on.</param>
            <param name="cultureInfo">Provides information about the specific culture.</param>
            <returns>The string with the first character converted to upper-case.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="cultureInfo"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUnicodeBytes(System.String)">
            <summary>
            Encodes all characters in a given string to an array of bytes encoded in unicode.
            </summary>
            <param name="value">The string to encode.</param>
            <returns>byte array representing the string in unicode.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.String.Recipes.StringExtensions.ToUtf8Bytes(System.String)">
            <summary>
            Encodes all characters in a given string to an array of bytes encoded in UTF-8.
            </summary>
            <param name="value">The string to encode.</param>
            <returns>byte array representing the string in UTF-8.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.ArrayKind">
            <summary>
            Specifies the kind of array.
            </summary>
            <remarks>
            See <a href="https://stackoverflow.com/questions/60859850/how-to-determine-if-rank-1-array-is-a-vector-or-multidimensional-array?noredirect=1#comment107679655_60859850"/>.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.None">
            <summary>
            Not an array.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.Vector">
            <summary>
            A vector array.  Can only have a single dimension.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ArrayKind.Multidimensional">
            <summary>
            A multidimensional array.  Can have 1 to 32 dimensions.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.AssemblyExtensions">
            <summary>
            Type-related extension methods on type <see cref="T:OBeautifulCode.Type.Recipes.AssemblyExtensions"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.AssemblyExtensions.GetEnumTypes(System.Reflection.Assembly)">
            <summary>
            Gets the enum types defined in the specified assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>
            The enum types defined in the specified assembly.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.AssemblyExtensions.GetPublicEnumTypes(System.Reflection.Assembly)">
            <summary>
            Gets the public enum types defined in the specified assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>
            The public enum types defined in the specified assembly.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.AssemblyExtensions.GetInterfaceTypes(System.Reflection.Assembly)">
            <summary>
            Gets the interface types defined in the specified assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>
            The interface types defined in the specified assembly.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.AssemblyExtensions.GetPublicInterfaceTypes(System.Reflection.Assembly)">
            <summary>
            Gets the public interface types defined in the specified assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>
            The public interface types defined in the specified assembly.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.ToStringReadableOptions">
            <summary>
            Options for generating a readability-optimized string representation of a type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.None">
            <summary>
            None (default).
            Use this option to generate the most succinct representation of the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.IncludeNamespace">
            <summary>
            Include the namespace of the type.
            If the type is generic then also include the namespace of all generic argument types.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringReadableOptions.IncludeAssemblyDetails">
            <summary>
            Include details (name and version) about the assembly that contains the type.
            If the type is generic then also include details about the assembly that contains
            all of the generic argument types.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions">
            <summary>
            Options for generating a XML doc compatible string representation of a type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions.None">
            <summary>
            None (default).
            Use this option to generate the most succinct representation of the specified type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Type.Recipes.ToStringXmlDocOptions.IncludeNamespace">
            <summary>
            Include the namespace of the type.
            If the type is generic then also include the namespace of all generic argument types.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Type.Recipes.TypeExtensions">
            <summary>
            Extension methods on type <see cref="T:System.Type"/>.
            </summary>
            <remarks>
            These resources helped:
            <a href="https://stackoverflow.com/questions/13012733/difference-between-type-isgenerictypedefinition-and-type-containsgenericparamete" />.
            <a href="https://stackoverflow.com/questions/2173107/what-exactly-is-an-open-generic-type-in-net" />.
            <a href="https://stackoverflow.com/questions/1735035/generics-open-and-closed-constructed-types" />.
            <a href="https://stackoverflow.com/questions/25811514/detect-if-a-generic-type-is-open" />.
            <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
            <a href="https://stackoverflow.com/questions/31772922/difference-between-isgenerictype-and-isgenerictypedefinition" />.
            <a href="https://stackoverflow.com/questions/59144791/if-type-isgenericparameter-true-will-type-containsgenericparameters-true?noredirect=1#comment104515860_59144791" />.
            <a href="https://stackoverflow.com/questions/59141721/why-is-the-basetype-of-a-generic-type-definition-not-itself-a-generic-type-defin?noredirect=1#comment104515814_59141721" />.
            </remarks>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetArrayKind(System.Type)">
            <summary>
            Determines the kind of array that the specified type is.
            </summary>
            <param name="type">The type.</param>
            <returns>
            The kind of array of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedEnumerableElementType(System.Type)">
            <summary>
            Gets the type of the elements of a specified closed Enumerable type.
            </summary>
            <param name="type">The closed Enumerable type.</param>
            <returns>
            The type of the elements of the specified closed Enumerable type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Enumerable type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedDictionaryKeyType(System.Type)">
            <summary>
            Gets the type of the keys of a specified closed Dictionary type.
            </summary>
            <param name="type">The closed Dictionary type.</param>
            <returns>
            The type of the keys of the specified closed Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Dictionary type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedDictionaryValueType(System.Type)">
            <summary>
            Gets the type of the values of a specified closed Dictionary type.
            </summary>
            <param name="type">The closed Dictionary type.</param>
            <returns>
            The type of the values of the specified closed Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed Dictionary type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemCollectionElementType(System.Type)">
            <summary>
            Gets the type of the elements of the specified closed <see cref="N:System"/> Collection type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Collection type.</param>
            <returns>
            The type of the elements of the specified closed <see cref="N:System"/> Collection type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Collection type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemCollectionType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemDictionaryKeyType(System.Type)">
            <summary>
            Gets the type of the keys of the specified closed <see cref="N:System"/> Dictionary type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Dictionary type.</param>
            <returns>
            The type of the keys of the specified closed <see cref="N:System"/> Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Dictionary type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetClosedSystemDictionaryValueType(System.Type)">
            <summary>
            Gets the type of the values of the specified closed <see cref="N:System"/> Dictionary type.
            </summary>
            <param name="type">The closed <see cref="N:System"/> Dictionary type.</param>
            <returns>
            The type of the values of the specified closed <see cref="N:System"/> Dictionary type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a closed <see cref="N:System"/> Dictionary type.  See <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetGenericTypeDefinitionOrSpecifiedType(System.Type)">
            <summary>
            Gets the generic type definition of a specified type if the type is generic
            but not a generic type definition, otherwise returns the specified type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            If the specified type is a generic type but not a generic type definition then the
            generic type definition is returned, otherwise the specified type is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.GetInheritancePath(System.Type)">
            <summary>
            Gets the types in the inheritance path starting from the specified type's
            <see cref="P:System.Type.BaseType"/> and ending in a type with no <see cref="P:System.Type.BaseType"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            The <see cref="P:System.Type.BaseType"/> of <paramref name="type"/>, followed by that type's
            <see cref="P:System.Type.BaseType"/>, and so on until a type has no <see cref="P:System.Type.BaseType"/>
            (that property returns null).
            If <paramref name="type"/> has no <see cref="P:System.Type.BaseType"/>, then this method returns
            an empty list.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not assignable to <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.EnumerableInterfaceType"/>.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasDefaultConstructor(System.Type)">
            <summary>
            Determines if the specified type has a default (public parameterless) constructor.
            </summary>
            <param name="type">Type to check.</param>
            <returns>
            A value indicating whether or not the type has a default (public parameterless) constructor.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasBaseType(System.Type)">
            <summary>
            Determines if the specified type has a base type.
            </summary>
            <returns>
            true if the specified type has a base type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasObjectAsBaseType(System.Type)">
            <summary>
            Determines if the base type of the specified type is object.
            </summary>
            <returns>
            true if the base type of the specified type is object, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer``1">
            <summary>
            Determines if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> will return a
            working (non-throwing) comparer for the specified type.
            </summary>
            <remarks>
            See remarks in <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer(System.Type)"/>.
            </remarks>
            <typeparam name="T">The type.</typeparam>
            <returns>
            true if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> returns a working (non-throwing)
            comparer for the specified type, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.HasWorkingDefaultComparer(System.Type)">
            <summary>
            Determines if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> will return a
            working (non-throwing) comparer for the specified type.
            </summary>
            <remarks>
            <see cref="P:System.Collections.Generic.Comparer`1.Default" /> will always return some comparer for
            any given closed type.  However, that comparer, when used, will or will no
            throw based on the type itself.  If the type implements or inherits <see cref="T:System.IComparable`1"/>
            where T is itself, then the comparer will ultimately use that implementation.
            We say "ultimately" here and below because a wrapper object is used.
            If the type is nullable and the underlying type implements or inherits <see cref="T:System.IComparable`1"/>
            where T is the underlying type, then the comparer will ultimately use that implementation.
            Finally, if the the type, when boxed, implements or inherits <see cref="T:System.IComparable"/> then the comparer
            will ultimately use that implementation.  If not, then, upon using the comparer to compare two
            objects, an exception will be thrown.
            It's further important to note that this method is NOT simply checking whether the specified
            type is assignable to <see cref="T:System.IComparable`1"/>.  For example:
            typeof(IComparable&lt;string&gt;).HasWorkingDefaultComparer() == false
            That's because that type doesn't implement IComparable&lt;IComparable&lt;string&gt;&gt;
            per the heuristic described above.  That said, any type that is assignable to <see cref="T:System.IComparable"/>
            will return true per the heuristic above.  For example:
            typeof(IComparable).HasWorkingDefaultComparer() == true.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if <see cref="P:System.Collections.Generic.Comparer`1.Default"/> returns a working (non-throwing)
            comparer for the specified type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="type"/> is an open type.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsAssignableTo(System.Type,System.Type,System.Boolean)">
            <summary>
            Determines if a type if assignable to another type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/questions/74616/how-to-detect-if-type-is-another-generic-type/1075059#1075059" />.
            </remarks>
            <param name="type">The current type.</param>
            <param name="otherType">The type to check for ability to assign to.</param>
            <param name="treatGenericTypeDefinitionAsAssignableTo">If <paramref name="otherType"/> is a generic type definition, specifies whether the method should treat that type as if a closed type can be assigned to it (e.g. IsAssignableTo(List&lt;int&gt;, List&lt;&gt;)).</param>
            <returns>
            true if <paramref name="type"/> can be assigned to <paramref name="otherType"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherType"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="type"/> is an open type.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="otherType"/> is an open type, but not a generic type definition.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedTypeAssignableToNull(System.Type)">
            <summary>
            Determines if the specified type is closed and assignable to null.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/1770232/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is closed and assignable to null, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousType(System.Type)">
            <summary>
            Determines if a type is a closed anonymous type.
            </summary>
            <param name="type">Type to check.</param>
            <returns>A value indicating whether or not the type provided is a closed anonymous type.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousTypeFastCheck(System.Type)">
            <summary>
            Determines if a type is a closed anonymous type using a faster, but potentially
            less accurate heuristic than <see cref="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedAnonymousType(System.Type)"/>.
            </summary>
            <param name="type">Type to check.</param>
            <returns>A value indicating whether or not the type provided is a closed anonymous type.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedGenericType(System.Type)">
            <summary>
            Determines if the specified type is a closed generic type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed generic type; otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedNonAnonymousClassType(System.Type)">
            <summary>
            Determines if the specified type is a class type, that's not anonymous, and is closed.
            </summary>
            <remarks>
            This is basically asking, "Is this a class type that can be constructed/new-ed up?".
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a class type, non-anonymous, and closed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedNullableType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Nullable`1"/> type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Nullable`1"/> type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="N:System"/> collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemDictionaryType(System.Type)">
            <summary>
            Determines if the specified type is a closed version one of one of the
            following <see cref="N:System"/> Dictionary generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemDictionaryGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="N:System"/> dictionary type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemEnumerableType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemKeyValuePairType(System.Type)">
            <summary>
            Determines if the specified type is a closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemOrderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following ordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemOrderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed, ordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsClosedSystemUnorderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is a closed version of one of the
            following unordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemUnorderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is a closed, unordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsNullableType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Nullable`1"/> type.
            </summary>
            <remarks>Adapted from: <a href="https://stackoverflow.com/a/41281601/356790" />.</remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Nullable`1"/> type, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemType(System.Type)">
            <summary>
            Determines if the specified type is in the <see cref="N:System"/> namespace.
            </summary>
            <remarks>
            An array is considered a system type.
            A ValueTuple is considered a system type.
            A generic type parameter is considered a system type.
            An anonymous type is not considered a system type.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is in the <see cref="N:System"/> namespace, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="N:System"/> collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemDictionaryType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version one of one of the
            following <see cref="N:System"/> Dictionary generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemDictionaryGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="N:System"/> dictionary type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemEnumerableType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Collections.Generic.IEnumerable`1"/>; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemKeyValuePairType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemOrderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following ordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemOrderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed, ordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsSystemUnorderedCollectionType(System.Type)">
            <summary>
            Determines if the specified type is an open or closed version of one of the
            following unordered <see cref="N:System"/> Collection generic type definitions:
            <see cref="F:OBeautifulCode.Type.Recipes.TypeExtensions.SystemUnorderedCollectionGenericTypeDefinitions"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is an open or closed, unordered <see cref="N:System"/> Collection type; otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.IsTypeAssignableToNull(System.Type)">
            <summary>
            Determines if the specified type is assignable to null.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/1770232/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            true if the specified type is assignable to null, otherwise false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.MakeGenericTypeOrNull(System.Type,System.Type[])">
            <summary>
            Substitutes the elements of an array of types for the type parameters of the current
            generic type definition and returns a <see cref="T:System.Type"/> object representing the resulting constructed type
            or null if the operation cannot be performed.
            </summary>
            <param name="type">The generic type definition.</param>
            <param name="typeArguments">An array of types to be substituted for the type parameters of <paramref name="type"/>.</param>
            <returns>
            A <see cref="T:System.Type"/> representing the constructed type formed by substituting the
            elements of <paramref name="typeArguments"/> for the type parameters of <paramref name="type"/> or null
            if the operation cannot be performed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringCompilable(System.Type,System.Boolean)">
            <summary>
            Gets a compilable, readability-optimized string representation of the specified type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
            Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
            </remarks>
            <param name="type">The type.</param>
            <param name="throwIfNoCompilableStringExists">Optional value indicating whether to throw a <see cref="T:System.NotSupportedException"/> if there's no compilable representation of the specified type.</param>
            <returns>
            A compilable, readability-optimized string representation of the specified type
            OR
            null if there is no compilable representation and <paramref name="throwIfNoCompilableStringExists"/> is true.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic open constructed type, which is not supported.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic parameter.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringReadable(System.Type,OBeautifulCode.Type.Recipes.ToStringReadableOptions)">
            <summary>
            Gets a readability-optimized string representation of the specified type.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
            Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
            Helpful breakdown of generics: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
            </remarks>
            <param name="type">The type.</param>
            <param name="options">The options to use when generating the string representation.</param>
            <returns>
            A readability-optimized string representation of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringXmlDoc(System.Type,System.Boolean,OBeautifulCode.Type.Recipes.ToStringXmlDocOptions)">
            <summary>
            Gets an XML-doc compatible string representation of the specified type.
            </summary>
            <param name="type">The type.</param>
            <param name="throwIfNoCompatibleStringExists">Optional value indicating whether to throw a <see cref="T:System.NotSupportedException"/> if there's no compatible string representation of the specified type.</param>
            <param name="options">The options to use when generating the string representation.</param>
            <returns>
            A XML-doc compatible string representation of the specified type.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.ToStringWithoutGenericComponent(System.Type)">
            <summary>
            Gets a string representation of the specified type without the generic component.
            For example, Dictionary&lt;string, string&gt; would be represented as 'Dictionary'.
            </summary>
            <remarks>
            Adapted from: <a href="https://stackoverflow.com/a/6386234/356790" />.
            </remarks>
            <param name="type">The type.</param>
            <returns>
            A string representation of the specified type with the generic component stripped out.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Type.Recipes.TypeExtensions.TryMakeGenericType(System.Type,System.Type@,System.Type[])">
            <summary>
            Substitutes the elements of an array of types for the type parameters of the current
            generic type definition and returns a <see cref="T:System.Type"/> object representing the resulting constructed type.
            </summary>
            <param name="type">The generic type definition.</param>
            <param name="genericType">A <see cref="T:System.Type"/> representing the constructed type formed by substituting the elements of <paramref name="typeArguments"/> for the type parameters of <paramref name="type"/> or null if the operation cannot be performed.</param>
            <param name="typeArguments">An array of types to be substituted for the type parameters of <paramref name="type"/>.</param>
            <returns>
            true if the type was successfully constructed; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcNullableDateTimeStringSerializer">
            <summary>
            String serializer for <see cref="T:System.Nullable`1"/> />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcNullableDateTimeStringSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcNullableDateTimeStringSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcNullableDateTimeStringSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcAlwaysThrowingSerializer">
            <summary>
            Serializer that always throws (<see cref="T:System.NotSupportedException"/>).
            </summary>
            <remarks>
            This is useful in testing to prove that a serializer is never called.
            </remarks>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcAlwaysThrowingSerializer.SerializationConfigurationType">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcAlwaysThrowingSerializer.SerializationKind">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcAlwaysThrowingSerializer.SerializerRepresentation">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcAlwaysThrowingSerializer.SerializeToBytes(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcAlwaysThrowingSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcAlwaysThrowingSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcAlwaysThrowingSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcAlwaysThrowingSerializer.Deserialize``1(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcAlwaysThrowingSerializer.Deserialize(System.Byte[],System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcSimplifyingSerializer">
            <summary>
            Where possible, simplifies the serialization process by short-cutting certain trivial types
            to improve for time (using a more direct approach, e.g. int.Parse) and space (removing superfluous encoding);
            otherwise falls-back on a specified serializer.
            </summary>
            <remarks>
            The serializer shortcuts null to/from string and byte.
            This serializer shortcuts these types (including Nullable where applicable) to/from string: string, Guid, bool, DateTime, sbyte, byte, short, ushort, int, uint, long, ulong, float, double, decimal.
            The serializer shortcuts byte[] to/from byte[].
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Serialization.ObcSimplifyingSerializer.StringSimplifiedTypes">
            <summary>
            The types that this serializer will shortcut.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSimplifyingSerializer.#ctor(OBeautifulCode.Serialization.ISerializer)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.ObcSimplifyingSerializer"/> class.
            </summary>
            <param name="fallbackSerializer">The serializer to use when the serializer cannot shortcut a type.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcSimplifyingSerializer.FallbackSerializer">
            <summary>
            Gets the serializer to use when the serializer cannot shortcut a type.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcSimplifyingSerializer.SerializationConfigurationType">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcSimplifyingSerializer.SerializationKind">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcSimplifyingSerializer.SerializerRepresentation">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSimplifyingSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSimplifyingSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSimplifyingSerializer.Deserialize``1(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSimplifyingSerializer.Deserialize(System.Byte[],System.Type)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSimplifyingSerializer.SerializeToBytes(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSimplifyingSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcVersionStringSerializer">
            <summary>
            String serializer for <see cref="T:System.Version"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcVersionStringSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcVersionStringSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcVersionStringSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcSecureStringStringSerializer">
            <summary>
            String serializer for <see cref="T:System.Security.SecureString"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSecureStringStringSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSecureStringStringSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSecureStringStringSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.SecureStringExtensions">
            <summary>
            Extension methods on <see cref="T:System.Security.SecureString"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.SecureStringExtensions.ToSecureString(System.String)">
            <summary>
            Converts the source string into a secure string. Caller should dispose of the secure string appropriately.
            </summary>
            <param name="source">The source string.</param>
            <returns>A secure version of the source string.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SecureStringExtensions.ToInsecureString(System.Security.SecureString)">
            <summary>
            Converts the source secure string into a standard insecure string.
            </summary>
            <param name="source">The source secure string.</param>
            <returns>
            The standard insecure string.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.IHaveSerializerRepresentation">
            <summary>
            Represents a serializer that has a <see cref="P:OBeautifulCode.Serialization.IHaveSerializerRepresentation.SerializerRepresentation"/>.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.IHaveSerializerRepresentation.SerializerRepresentation">
            <summary>
            Gets the <see cref="P:OBeautifulCode.Serialization.IHaveSerializerRepresentation.SerializerRepresentation"/>.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.INamedPropertyBagObjectValuesDeserialize">
            <summary>
            Interface to deserialize an object from a property bag,
            keyed on property name with the property values represented in objects.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.INamedPropertyBagObjectValuesDeserialize.Deserialize``1(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Deserializes the property bag into the specified <typeparamref name="T"/>.
            </summary>
            <param name="serializedPropertyBag">The property bag to deserialize.</param>
            <typeparam name="T">Type to deserialize into.</typeparam>
            <returns>
            The deserialized object.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.INamedPropertyBagObjectValuesDeserialize.Deserialize(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object},System.Type)">
            <summary>
            Deserializes the property bag into an object.
            </summary>
            <param name="serializedPropertyBag">The property bag to deserialize.</param>
            <param name="type">Type to deserialize into.</param>
            <returns>
            The deserialized object.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.IOrdinalPropertyBagStringValuesSerializeAndDeserialize">
            <summary>
            Interface to serialize and deserialize an object to a property bag,
            keyed on the properties' ordinal positions with the property values represented in strings.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.IOrdinalPropertyBagObjectValuesSerializeAndDeserialize">
            <summary>
            Interface to serialize and deserialize an object to a property bag,
            keyed on the properties' ordinal positions with the property values represented in objects.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.INamedPropertyBagObjectValuesSerializeAndDeserialize">
            <summary>
            Interface to serialize and deserialize an object to a property bag,
            keyed on property name with the property values represented in objects.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.IOrdinalPropertyBagObjectValuesDeserialize">
            <summary>
            Interface to deserialize an object from a property bag,
            keyed on the properties' ordinal positions with the property values represented in objects.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.IOrdinalPropertyBagObjectValuesDeserialize.Deserialize``1(System.Collections.Generic.IReadOnlyDictionary{System.Int32,System.Object})">
            <summary>
            Deserializes the property bag into the specified <typeparamref name="T"/>.
            </summary>
            <param name="serializedPropertyBag">The property bag to deserialize.</param>
            <typeparam name="T">Type to deserialize into.</typeparam>
            <returns>
            The deserialized object.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.IOrdinalPropertyBagObjectValuesDeserialize.Deserialize(System.Collections.Generic.IReadOnlyDictionary{System.Int32,System.Object},System.Type)">
            <summary>
            Deserializes the property bag into an object.
            </summary>
            <param name="serializedPropertyBag">The property bag to deserialize.</param>
            <param name="type">Type to deserialize into.</param>
            <returns>
            The deserialized object.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.IOrdinalPropertyBagStringValuesDeserialize">
            <summary>
            Interface to deserialize an object from a property bag,
            keyed on the properties' ordinal positions with the property values represented in strings.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.IOrdinalPropertyBagStringValuesDeserialize.Deserialize``1(System.Collections.Generic.IReadOnlyDictionary{System.Int32,System.String})">
            <summary>
            Deserializes the property bag into the specified <typeparamref name="T"/>.
            </summary>
            <param name="serializedPropertyBag">The property bag to deserialize.</param>
            <typeparam name="T">Type to deserialize into.</typeparam>
            <returns>
            The deserialized object.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.IOrdinalPropertyBagStringValuesDeserialize.Deserialize(System.Collections.Generic.IReadOnlyDictionary{System.Int32,System.String},System.Type)">
            <summary>
            Deserializes the property bag into an object.
            </summary>
            <param name="serializedPropertyBag">The property bag to deserialize.</param>
            <param name="type">Type to deserialize into.</param>
            <returns>
            The deserialized object.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.IOrdinalPropertyBagStringValuesSerialize">
            <summary>
            Interface to serialize an object to a property bag,
            keyed on the properties' ordinal positions with the property values represented in strings.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.IOrdinalPropertyBagStringValuesSerialize.SerializeToOrdinalPropertyBagWithStringValues(System.Object)">
            <summary>
            Serializes an object into a property bag (<see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>).
            </summary>
            <param name="objectToSerialize">Object to serialize.</param>
            <returns>
            The property bag.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.IOrdinalPropertyBagObjectValuesSerialize">
            <summary>
            Interface to serialize an object to a property bag,
            keyed on the properties' ordinal positions with the property values represented in objects.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.IOrdinalPropertyBagObjectValuesSerialize.SerializeToOrdinalPropertyBagWithObjectValues(System.Object)">
            <summary>
            Serializes an object into a property bag (<see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>).
            </summary>
            <param name="objectToSerialize">Object to serialize.</param>
            <returns>
            The property bag.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.INamedPropertyBagObjectValuesSerialize">
            <summary>
            Interface to serialize an object to a property bag,
            keyed on property name with the property values represented in objects.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.INamedPropertyBagObjectValuesSerialize.SerializeToNamedPropertyBagWithObjectValues(System.Object)">
            <summary>
            Serializes an object into a property bag (<see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>).
            </summary>
            <param name="objectToSerialize">Object to serialize.</param>
            <returns>
            The property bag.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.ISerializer">
            <summary>
            Interface to serialize and deserialize to and from a byte array or string, with the ability to create a <see cref="T:OBeautifulCode.Serialization.SerializerRepresentation"/>.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.BinaryDescribedSerialization">
            <summary>
            <see cref="T:OBeautifulCode.Serialization.DescribedSerializationBase"/> with a binary payload.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Serialization.SerializerRepresentation,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.BinaryDescribedSerialization"/> class.
            </summary>
            <param name="payloadTypeRepresentation">The type of object serialized.</param>
            <param name="serializerRepresentation">The serializer used to generate the payload.</param>
            <param name="serializedPayload">The serialized payload.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.BinaryDescribedSerialization.SerializedPayload">
            <summary>
            Gets the serialized payload.
            </summary>
            <remarks>
            We are intentionally choosing a byte[] over an IReadOnlyList{byte} for performance
            reasons.  The typical usages of this data require a byte array and not a List.
            A List incurs the cost of frequent conversion to a byte[].
            </remarks>
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.GetSerializationFormat">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.GetSerializedPayloadAsEncodedString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.GetSerializedPayloadAsEncodedBytes">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.op_Equality(OBeautifulCode.Serialization.BinaryDescribedSerialization,OBeautifulCode.Serialization.BinaryDescribedSerialization)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.BinaryDescribedSerialization"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.op_Inequality(OBeautifulCode.Serialization.BinaryDescribedSerialization,OBeautifulCode.Serialization.BinaryDescribedSerialization)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.BinaryDescribedSerialization"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.Equals(OBeautifulCode.Serialization.BinaryDescribedSerialization)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.DeepCloneWithPayloadTypeRepresentation(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.DeepCloneWithSerializerRepresentation(OBeautifulCode.Serialization.SerializerRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.DeepCloneWithSerializedPayload(System.Byte[])">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Serialization.BinaryDescribedSerialization.SerializedPayload" />.
            </summary>
            <param name="serializedPayload">The new <see cref="P:OBeautifulCode.Serialization.BinaryDescribedSerialization.SerializedPayload" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Serialization.BinaryDescribedSerialization" /> using the specified <paramref name="serializedPayload" /> for <see cref="P:OBeautifulCode.Serialization.BinaryDescribedSerialization.SerializedPayload" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.BinaryDescribedSerialization.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.DescribedSerializationBase">
            <summary>
            A portable object that contains all the information required to deserialize
            some contained/subject object: the serialized payload of the subject object,
            the type of the subject object, and the serializer that was used to serialize the subject object.
            </summary>
            <remarks>
            This provides the ability to persist, transport, and route
            (e.g. make decisions based on properties of this object)
            an object through code layers that do not the object type loaded, while
            enabling a consumer having the object and the serializer loaded,
            to deserialize the object.
            </remarks>
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.op_Equality(OBeautifulCode.Serialization.DescribedSerializationBase,OBeautifulCode.Serialization.DescribedSerializationBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.DescribedSerializationBase"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.op_Inequality(OBeautifulCode.Serialization.DescribedSerializationBase,OBeautifulCode.Serialization.DescribedSerializationBase)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.DescribedSerializationBase"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.Equals(OBeautifulCode.Serialization.DescribedSerializationBase)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.DeepCloneWithPayloadTypeRepresentation(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Serialization.DescribedSerializationBase.PayloadTypeRepresentation" />.
            </summary>
            <param name="payloadTypeRepresentation">The new <see cref="P:OBeautifulCode.Serialization.DescribedSerializationBase.PayloadTypeRepresentation" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Serialization.DescribedSerializationBase" /> using the specified <paramref name="payloadTypeRepresentation" /> for <see cref="P:OBeautifulCode.Serialization.DescribedSerializationBase.PayloadTypeRepresentation" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.DeepCloneWithSerializerRepresentation(OBeautifulCode.Serialization.SerializerRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Serialization.DescribedSerializationBase.SerializerRepresentation" />.
            </summary>
            <param name="serializerRepresentation">The new <see cref="P:OBeautifulCode.Serialization.DescribedSerializationBase.SerializerRepresentation" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Serialization.DescribedSerializationBase" /> using the specified <paramref name="serializerRepresentation" /> for <see cref="P:OBeautifulCode.Serialization.DescribedSerializationBase.SerializerRepresentation" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.DeepCloneInternal">
            <summary>
            Creates a new object that is a deep clone of this instance.
            </summary>
            <returns>
            A new object that is a deep clone of this instance.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.ToString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Serialization.SerializerRepresentation)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.DescribedSerializationBase"/> class.
            </summary>
            <param name="payloadTypeRepresentation">The type of object serialized.</param>
            <param name="serializerRepresentation">The serializer used to generate the payload.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.DescribedSerializationBase.PayloadTypeRepresentation">
            <summary>
            Gets the type of object serialized.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.DescribedSerializationBase.SerializerRepresentation">
            <summary>
            Gets the representation of the serializer used to generate the payload.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.GetSerializationFormat">
            <summary>
            Gets the format that the object was serialized into.
            </summary>
            <returns>
            The format that the object was serialized into.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.GetSerializedPayloadAsEncodedString">
            <summary>
            Gets the serialized payload encoded as a string.
            </summary>
            <remarks>
            <see cref="T:OBeautifulCode.Serialization.StringDescribedSerialization"/> will pass-through the payload.
            <see cref="T:OBeautifulCode.Serialization.BinaryDescribedSerialization"/> will Base64-encode the bytes.
            </remarks>
            <returns>
            The serialized payload encoded as a string.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DescribedSerializationBase.GetSerializedPayloadAsEncodedBytes">
            <summary>
            Gets the serialized payload encoded as a byte array.
            </summary>
            <remarks>
            <see cref="T:OBeautifulCode.Serialization.StringDescribedSerialization"/> will UTF-8 encode the payload.
            <see cref="T:OBeautifulCode.Serialization.BinaryDescribedSerialization"/> will pass-through the payload.
            </remarks>
            <returns>
            The serialized payload encoded as a string.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.StringDescribedSerialization">
            <summary>
            <see cref="T:OBeautifulCode.Serialization.DescribedSerializationBase"/> with a string payload.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.#ctor(OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Serialization.SerializerRepresentation,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.StringDescribedSerialization"/> class.
            </summary>
            <param name="payloadTypeRepresentation">The type of object serialized.</param>
            <param name="serializerRepresentation">The serializer used to generate the payload.</param>
            <param name="serializedPayload">The serialized payload.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.StringDescribedSerialization.SerializedPayload">
            <summary>
            Gets the serialized payload.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.GetSerializationFormat">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.GetSerializedPayloadAsEncodedString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.GetSerializedPayloadAsEncodedBytes">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.op_Equality(OBeautifulCode.Serialization.StringDescribedSerialization,OBeautifulCode.Serialization.StringDescribedSerialization)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.StringDescribedSerialization"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.op_Inequality(OBeautifulCode.Serialization.StringDescribedSerialization,OBeautifulCode.Serialization.StringDescribedSerialization)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.StringDescribedSerialization"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.Equals(OBeautifulCode.Serialization.StringDescribedSerialization)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.DeepCloneWithPayloadTypeRepresentation(OBeautifulCode.Representation.System.TypeRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.DeepCloneWithSerializerRepresentation(OBeautifulCode.Serialization.SerializerRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.DeepCloneWithSerializedPayload(System.String)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Serialization.StringDescribedSerialization.SerializedPayload" />.
            </summary>
            <param name="serializedPayload">The new <see cref="P:OBeautifulCode.Serialization.StringDescribedSerialization.SerializedPayload" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Serialization.StringDescribedSerialization" /> using the specified <paramref name="serializedPayload" /> for <see cref="P:OBeautifulCode.Serialization.StringDescribedSerialization.SerializedPayload" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.DeepCloneInternal">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.StringDescribedSerialization.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcLambdaBackedStringSerializer">
            <summary>
            String serializer that is backed by <see cref="T:System.Func`2" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcLambdaBackedStringSerializer.#ctor(System.Func{System.Object,System.String},System.Func{System.String,System.Type,System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.ObcLambdaBackedStringSerializer"/> class.
            </summary>
            <param name="serializeString">Serialize object to string.</param>
            <param name="deserializeString">Deserialize object from string.</param>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcLambdaBackedStringSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcLambdaBackedStringSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcLambdaBackedStringSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer">
            <summary>
            Serializer that is backed by a <see cref="T:OBeautifulCode.Serialization.IStringSerializeAndDeserialize"/>.
            </summary>
            <remarks>
            Binary serialization will be the UTF-8 byte representation of the resulting string of the backing serializer.
            </remarks>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.#ctor(OBeautifulCode.Serialization.IStringSerializeAndDeserialize,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer"/> class.
            </summary>
            <param name="backingStringSerializer">Backing string serializer.</param>
            <param name="id">Optional identifier to be stored in metadata of <see cref="P:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.SerializerRepresentation"/>.  DEFAULT is null.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.Encoding">
            <summary>
            Gets the encoding for binary serialization.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.BackingStringSerializer">
            <summary>
            Gets the backing string serializer.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.SerializationConfigurationType">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.SerializationKind">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.SerializerRepresentation">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.SerializeToBytes(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.Deserialize``1(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcStringSerializerBackedSerializer.Deserialize(System.Byte[],System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcSimplifyingSerializerFactory">
            <summary>
            A serializer factory that wraps the serializers built by a backing factory with an <see cref="T:OBeautifulCode.Serialization.ObcSimplifyingSerializer"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSimplifyingSerializerFactory.#ctor(OBeautifulCode.Serialization.ISerializerFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.ObcSimplifyingSerializerFactory"/> class.
            </summary>
            <param name="backingSerializerFactory">The backing serializer factory.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcSimplifyingSerializerFactory.BackingSerializerFactory">
            <summary>
            Gets the backing serializer factory.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSimplifyingSerializerFactory.BuildSerializer(OBeautifulCode.Serialization.SerializerRepresentation,OBeautifulCode.Type.VersionMatchStrategy)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.SerializerFactoryBase">
            <summary>
            Default implementation of <see cref="T:OBeautifulCode.Serialization.ISerializerFactory" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerFactoryBase.#ctor(OBeautifulCode.Compression.ICompressorFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.SerializerFactoryBase"/> class.
            </summary>
            <param name="compressorFactory">The compressor factory to use.  Set to null to use <see cref="P:OBeautifulCode.Compression.Recipes.CompressorFactory.Instance"/>.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializerFactoryBase.CompressorFactory">
            <summary>
            Gets the compressor factory to use.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerFactoryBase.BuildSerializer(OBeautifulCode.Serialization.SerializerRepresentation,OBeautifulCode.Type.VersionMatchStrategy)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerFactoryBase.WrapInCompressingSerializerIfAppropriate(OBeautifulCode.Serialization.ISerializer,OBeautifulCode.Compression.CompressionKind)">
            <summary>
            Wraps the specified serializer in a <see cref="T:OBeautifulCode.Serialization.ObcCompressingSerializer"/> if appropriate.
            </summary>
            <param name="serializer">The serializer.</param>
            <param name="compressionKind">The kind of compression to use.</param>
            <returns>
            The specified serializer, wrapped in a <see cref="T:OBeautifulCode.Serialization.ObcCompressingSerializer"/> if it's appropriate given
            the specified <paramref name="compressionKind"/>.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcCompressingSerializer">
            <summary>
            A serializer that compresses after serialization and decompresses before de-serialization.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcCompressingSerializer.#ctor(OBeautifulCode.Serialization.ISerializer,OBeautifulCode.Compression.ICompressor)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.ObcCompressingSerializer"/> class.
            </summary>
            <param name="serializer">The underlying serializer to use.</param>
            <param name="compressor">The compressor to use.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcCompressingSerializer.Serializer">
            <summary>
            Gets the underlying serializer to use.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcCompressingSerializer.Compressor">
            <summary>
            Gets the compressor to use.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcCompressingSerializer.SerializationConfigurationType">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcCompressingSerializer.SerializationKind">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcCompressingSerializer.SerializerRepresentation">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcCompressingSerializer.SerializeToBytes(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcCompressingSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcCompressingSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcCompressingSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcCompressingSerializer.Deserialize``1(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcCompressingSerializer.Deserialize(System.Byte[],System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.ProjectInfo">
            <summary>
            Project-related information.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.ProjectInfo.Namespace">
            <summary>
            The namespace used by types in this project.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.ProjectInfo.Assembly">
            <summary>
            The assembly produced by this project.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.IIgnoreDefaultDependencies">
            <summary>
            Declares that <see cref="P:OBeautifulCode.Serialization.SerializationConfigurationBase.DefaultDependentSerializationConfigurationTypes"/> should be ignored.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.IStringSerialize">
            <summary>
            Interface to serialize to a string.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.IStringSerialize.SerializeToString(System.Object)">
            <summary>
            Serializes an object into a string.
            </summary>
            <param name="objectToSerialize">Object to serialize.</param>
            <returns>
            Serialized object into a string.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.IHaveSerializationKind">
            <summary>
            Interface to expose the <see cref="P:OBeautifulCode.Serialization.IHaveSerializationKind.SerializationKind" /> of serializer.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.IHaveSerializationKind.SerializationKind">
            <summary>
            Gets the <see cref="P:OBeautifulCode.Serialization.IHaveSerializationKind.SerializationKind" /> of the serializer.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.IStringDeserialize">
            <summary>
            Interface to deserialize from a string.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.IStringDeserialize.Deserialize``1(System.String)">
            <summary>
            Deserializes the string into an object.
            </summary>
            <param name="serializedString">String to deserialize.</param>
            <typeparam name="T">Type of object to deserialize.</typeparam>
            <returns>
            Deserialized string into object of specified type.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.IStringDeserialize.Deserialize(System.String,System.Type)">
            <summary>
            Deserializes the string into an object.
            </summary>
            <param name="serializedString">String to deserialize.</param>
            <param name="type">Type to deserialize into.</param>
            <returns>
            Deserialized string into object of specified type.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.INamedPropertyBagStringValuesDeserialize">
            <summary>
            Interface to deserialize an object from a property bag,
            keyed on property name with the property values represented in strings.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.INamedPropertyBagStringValuesDeserialize.Deserialize``1(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Deserializes the property bag into the specified <typeparamref name="T"/>.
            </summary>
            <param name="serializedPropertyBag">The property bag to deserialize.</param>
            <typeparam name="T">Type to deserialize into.</typeparam>
            <returns>
            The deserialized object.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.INamedPropertyBagStringValuesDeserialize.Deserialize(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String},System.Type)">
            <summary>
            Deserializes the property bag into an object.
            </summary>
            <param name="serializedPropertyBag">The property bag to deserialize.</param>
            <param name="type">Type to deserialize into.</param>
            <returns>
            The deserialized object.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.ISerialize">
            <summary>
            Interface to serialize to and from a byte array or string.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.IDeserialize">
            <summary>
            Interface to deserialize to and from a byte array or string.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.IBinaryDeserialize">
            <summary>
            Interface to deserialize from a byte array.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.IBinaryDeserialize.Deserialize``1(System.Byte[])">
            <summary>
            Deserializes the byte array into an object.
            </summary>
            <param name="serializedBytes">Byte array to deserialize.</param>
            <typeparam name="T">Type of object to deserialize.</typeparam>
            <returns>
            Deserialized bytes into object of specified type.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.IBinaryDeserialize.Deserialize(System.Byte[],System.Type)">
            <summary>
            Deserializes the byte array into an object.
            </summary>
            <param name="serializedBytes">Byte array to deserialize.</param>
            <param name="type">Type to deserialize into.</param>
            <returns>
            Deserialized bytes into object of specified type.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.IBinarySerialize">
            <summary>
            Interface to serialize to a byte array.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.IBinarySerialize.SerializeToBytes(System.Object)">
            <summary>
            Serializes an object into a byte array.
            </summary>
            <param name="objectToSerialize">Object to serialize.</param>
            <returns>
            Serialized object into a byte array.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.INamedPropertyBagStringValuesSerialize">
            <summary>
            Interface to serialize an object to a property bag,
            keyed on property name with the property values represented in strings.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.INamedPropertyBagStringValuesSerialize.SerializeToNamedPropertyBagWithStringValues(System.Object)">
            <summary>
            Serializes an object into a property bag (<see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>).
            </summary>
            <param name="objectToSerialize">Object to serialize.</param>
            <returns>
            The property bag.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.IHaveSerializationConfigurationType">
            <summary>
            Interface to expose the serialization configuration type.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.IHaveSerializationConfigurationType.SerializationConfigurationType">
            <summary>
            Gets serialization configuration type.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.DomainExtensions">
            <summary>
            Serialization-related extension methods.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.DomainExtensions.ToRepresentation(OBeautifulCode.Serialization.IHaveSerializerRepresentation)">
            <summary>
            Gets the representation of the specified serializer.
            </summary>
            <param name="serializer">The serializer.</param>
            <returns>
            The representation.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DomainExtensions.ToDescribedSerializationUsingSpecificFactory``1(``0,OBeautifulCode.Serialization.SerializerRepresentation,OBeautifulCode.Serialization.ISerializerFactory,OBeautifulCode.Serialization.SerializationFormat,OBeautifulCode.Type.VersionMatchStrategy)">
            <summary>
            Converts an object to a self described serialization to persist or share.
            </summary>
            <typeparam name="T">Type of object to serialize.</typeparam>
            <param name="objectToPackageIntoDescribedSerializationBase">Object to serialize.</param>
            <param name="serializerRepresentation">Representation of the serializer to use.</param>
            <param name="serializerFactory">Implementation of <see cref="T:OBeautifulCode.Serialization.ISerializerFactory" /> that can resolve the serializer.</param>
            <param name="serializationFormat">The serialization format to use.</param>
            <param name="assemblyVersionMatchStrategy">Optional assembly version match strategy for resolving the type of object as well as the configuration type if any; DEFAULT is <see cref="F:OBeautifulCode.Type.VersionMatchStrategy.AnySingleVersion" />.</param>
            <returns>
            Self described serialization.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DomainExtensions.ToDescribedSerializationUsingSpecificSerializer``1(``0,OBeautifulCode.Serialization.ISerializer,OBeautifulCode.Serialization.SerializationFormat)">
            <summary>
            Converts an object to a self described serialization to persist or share.
            </summary>
            <typeparam name="T">Type of object to serialize.</typeparam>
            <param name="objectToPackageIntoDescribedSerializationBase">Object to serialize.</param>
            <param name="serializer">Serializer to use.</param>
            <param name="serializationFormat">The serialization format to use.</param>
            <returns>
            Self described serialization.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DomainExtensions.DeserializePayloadUsingSpecificFactory``1(OBeautifulCode.Serialization.DescribedSerializationBase,OBeautifulCode.Serialization.ISerializerFactory,OBeautifulCode.Type.VersionMatchStrategy)">
            <summary>
            Converts a self described serialization back into it's object.
            </summary>
            <typeparam name="T">Expected return type.</typeparam>
            <param name="describedSerializationBase">Self described serialized object.</param>
            <param name="serializerFactory">Implementation of <see cref="T:OBeautifulCode.Serialization.ISerializerFactory" /> that can resolve the serializer.</param>
            <param name="assemblyVersionMatchStrategy">Optional assembly version match strategy for resolving the type of object as well as the configuration type if any; DEFAULT is <see cref="F:OBeautifulCode.Type.VersionMatchStrategy.AnySingleVersion" />.</param>
            <returns>
            Originally serialized object.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DomainExtensions.DeserializePayloadUsingSpecificFactory(OBeautifulCode.Serialization.DescribedSerializationBase,OBeautifulCode.Serialization.ISerializerFactory,OBeautifulCode.Type.VersionMatchStrategy)">
            <summary>
            Converts a self described serialization back into it's object.
            </summary>
            <param name="describedSerializationBase">Self described serialized object.</param>
            <param name="serializerFactory">Implementation of <see cref="T:OBeautifulCode.Serialization.ISerializerFactory" /> that can resolve the serializer.</param>
            <param name="assemblyVersionMatchStrategy">Optional assembly version match strategy for resolving the type of object as well as the configuration type if any; DEFAULT is <see cref="F:OBeautifulCode.Type.VersionMatchStrategy.AnySingleVersion" />.</param>
            <returns>
            Originally serialized object.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DomainExtensions.DeserializePayloadUsingSpecificSerializer``1(OBeautifulCode.Serialization.DescribedSerializationBase,OBeautifulCode.Serialization.IDeserialize,OBeautifulCode.Type.VersionMatchStrategy)">
            <summary>
            Converts a self described serialization back into it's object.
            </summary>
            <typeparam name="T">Expected return type.</typeparam>
            <param name="describedSerializationBase">Self described serialized object.</param>
            <param name="deserializer">Deserializer to use.</param>
            <param name="assemblyVersionMatchStrategy">Optional assembly version match strategy for resolving the type of object as well as the configuration type if any; DEFAULT is <see cref="F:OBeautifulCode.Type.VersionMatchStrategy.AnySingleVersion" />.</param>
            <returns>
            Originally serialized object.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DomainExtensions.DeserializePayloadUsingSpecificSerializer(OBeautifulCode.Serialization.DescribedSerializationBase,OBeautifulCode.Serialization.IDeserialize,OBeautifulCode.Type.VersionMatchStrategy)">
            <summary>
            Converts a self described serialization back into it's object.
            </summary>
            <param name="describedSerializationBase">Self described serialized object.</param>
            <param name="deserializer">Deserializer to use.</param>
            <param name="assemblyVersionMatchStrategy">Optional assembly version match strategy for resolving the type of object as well as the configuration type if any; DEFAULT is <see cref="F:OBeautifulCode.Type.VersionMatchStrategy.AnySingleVersion" />.</param>
            <returns>
            Originally serialized object.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DomainExtensions.ResolveDefaultIntoActionableRelatedTypesToInclude(System.Type)">
            <summary>
            Resolves <see cref="F:OBeautifulCode.Serialization.RelatedTypesToInclude.Default"/> into
            an actionable <see cref="T:OBeautifulCode.Serialization.RelatedTypesToInclude"/> for the specified type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            An actionable <see cref="T:OBeautifulCode.Serialization.RelatedTypesToInclude"/> resolved for the specified type,
            when <see cref="F:OBeautifulCode.Serialization.RelatedTypesToInclude.Default"/> is specified.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.DynamicTypePlaceholder">
            <summary>
            Type to use as a placeholder to control dynamic serialization/de-serialization.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.DynamicTypePlaceholder.op_Equality(OBeautifulCode.Serialization.DynamicTypePlaceholder,OBeautifulCode.Serialization.DynamicTypePlaceholder)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.DynamicTypePlaceholder"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DynamicTypePlaceholder.op_Inequality(OBeautifulCode.Serialization.DynamicTypePlaceholder,OBeautifulCode.Serialization.DynamicTypePlaceholder)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.DynamicTypePlaceholder"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.DynamicTypePlaceholder.Equals(OBeautifulCode.Serialization.DynamicTypePlaceholder)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.DynamicTypePlaceholder.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.DynamicTypePlaceholder.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.DynamicTypePlaceholder.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.DynamicTypePlaceholder.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.DynamicTypePlaceholder.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.IBinarySerializeAndDeserialize">
            <summary>
            Interface to serialize and deserialize to and from a byte array.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.INamedPropertyBagStringValuesSerializeAndDeserialize">
            <summary>
            Interface to serialize and deserialize an object to a property bag,
            keyed on property name with the property values represented in strings.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.ISerializeAndDeserialize">
            <summary>
            Interface to serialize and deserialize to and from a byte array or string.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.ISerializerFactory">
            <summary>
            Abstract factory interface for building serializers.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ISerializerFactory.BuildSerializer(OBeautifulCode.Serialization.SerializerRepresentation,OBeautifulCode.Type.VersionMatchStrategy)">
            <summary>
            Builds the correct implementation of <see cref="T:OBeautifulCode.Serialization.ISerializer" /> based on the description.
            </summary>
            <param name="serializerRepresentation">Representation of the serializer.</param>
            <param name="assemblyVersionMatchStrategy">Optional assembly version match strategy for resolving the type of object as well as the configuration type if any; DEFAULT is <see cref="F:OBeautifulCode.Type.VersionMatchStrategy.AnySingleVersion" />.</param>
            <returns>
            Correct implementation of <see cref="T:OBeautifulCode.Serialization.ISerializer" /> based on the description.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.ISerializeToString">
            <summary>
            Interface to serialize itself to a string.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ISerializeToString.SerializeToString">
            <summary>
            Serialize to a string.
            </summary>
            <returns>String version of object.</returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.IStringSerializeAndDeserialize">
            <summary>
            Interface to serialize and deserialize to and from a string.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.SerializerRepresentation">
            <summary>
            Model object that represents a serializer so you can persist and share the definition and rehydrate the serializer later.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.op_Equality(OBeautifulCode.Serialization.SerializerRepresentation,OBeautifulCode.Serialization.SerializerRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.SerializerRepresentation"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.op_Inequality(OBeautifulCode.Serialization.SerializerRepresentation,OBeautifulCode.Serialization.SerializerRepresentation)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.SerializerRepresentation"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.Equals(OBeautifulCode.Serialization.SerializerRepresentation)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.Clone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.DeepCloneWithSerializationKind(OBeautifulCode.Serialization.SerializationKind)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.SerializationKind" />.
            </summary>
            <param name="serializationKind">The new <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.SerializationKind" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Serialization.SerializerRepresentation" /> using the specified <paramref name="serializationKind" /> for <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.SerializationKind" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.DeepCloneWithSerializationConfigType(OBeautifulCode.Representation.System.TypeRepresentation)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.SerializationConfigType" />.
            </summary>
            <param name="serializationConfigType">The new <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.SerializationConfigType" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Serialization.SerializerRepresentation" /> using the specified <paramref name="serializationConfigType" /> for <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.SerializationConfigType" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.DeepCloneWithCompressionKind(OBeautifulCode.Compression.CompressionKind)">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.CompressionKind" />.
            </summary>
            <param name="compressionKind">The new <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.CompressionKind" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Serialization.SerializerRepresentation" /> using the specified <paramref name="compressionKind" /> for <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.CompressionKind" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.DeepCloneWithMetadata(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Deep clones this object with a new <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.Metadata" />.
            </summary>
            <param name="metadata">The new <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.Metadata" />.  This object will NOT be deep cloned; it is used as-is.</param>
            <returns>New <see cref="T:OBeautifulCode.Serialization.SerializerRepresentation" /> using the specified <paramref name="metadata" /> for <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.Metadata" /> and a deep clone of every other property.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.ToString">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializerRepresentation.#ctor(OBeautifulCode.Serialization.SerializationKind,OBeautifulCode.Representation.System.TypeRepresentation,OBeautifulCode.Compression.CompressionKind,System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.SerializerRepresentation"/> class.
            </summary>
            <param name="serializationKind">The <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.SerializationKind" /> to serialize into.</param>
            <param name="compressionKind">Optional <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.CompressionKind" /> to use; DEFAULT is None.</param>
            <param name="serializationConfigType">Optional representation of the type of the serialization configuration to use; DEFAULT is null.</param>
            <param name="metadata">Optional metadata to put, especially useful for custom serializer factory; DEFAULT is empty.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializerRepresentation.SerializationKind">
            <summary>
            Gets the <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.SerializationKind" /> to serialize into.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializerRepresentation.SerializationConfigType">
            <summary>
            Gets the <see cref="T:OBeautifulCode.Representation.System.TypeRepresentation" /> of the type of the serialization configuration.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializerRepresentation.CompressionKind">
            <summary>
            Gets the <see cref="P:OBeautifulCode.Serialization.SerializerRepresentation.CompressionKind" /> to use.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializerRepresentation.Metadata">
            <summary>
            Gets a map of metadata for custom use.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.RegistrationDetails">
            <summary>
            Details about the registration of a type.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.RegistrationDetails.#ctor(OBeautifulCode.Serialization.TypeToRegister,OBeautifulCode.Serialization.SerializationConfigurationType)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.RegistrationDetails"/> class.
            </summary>
            <param name="typeToRegister">The type to register.</param>
            <param name="serializationConfigurationType">The type of the registering serialization configuration.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.RegistrationDetails.TypeToRegister">
            <summary>
            Gets the type to register.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.RegistrationDetails.SerializationConfigurationType">
            <summary>
            Gets the type of the registering serialization configuration.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.RegistrationTime">
            <summary>
            Specifies the time when a registration occurs.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.RegistrationTime.Unknown">
            <summary>
            Unknown (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.RegistrationTime.Initialization">
            <summary>
            Registration is happening during initialization.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.RegistrationTime.PostInitialization">
            <summary>
            Registration is happening post-initialization.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.TypeToIncludeOrigin">
            <summary>
            Identifies the source of a type that is included when registering some other type.
            The included type is registered as well.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.TypeToIncludeOrigin.Unknown">
            <summary>
            Unknown (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.TypeToIncludeOrigin.GettingMemberTypes">
            <summary>
            The type to include was introduced when processing <see cref="P:OBeautifulCode.Serialization.TypeToRegister.MemberTypesToInclude"/>.
            (<see cref="T:OBeautifulCode.Serialization.MemberTypesToInclude"/>).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.TypeToIncludeOrigin.GettingRelatedTypes">
            <summary>
            The type to include was introduced when processing <see cref="P:OBeautifulCode.Serialization.TypeToRegister.RelatedTypesToInclude"/>.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.VersionlessOpenTypeConsolidatingTypeEqualityComparer">
            <summary>
            Compares two objects of type <see cref="T:System.Type"/> for equality, ignoring assembly version
            and treating two open types that are not equal but effectively the same type as equal.
            </summary>
            <remarks>
            an example of the need for this comparer:
            class Parent{T} { }
            class Child{T} : Parent{T} { }
            typeof(Child{T}).BaseType != typeof(Parent{T})
            VersionlessOpenTypeConsolidatingTypeEqualityComparer.Instance.Equals(typeof(Child{T}).BaseType, typeof(Parent{T})) == true.
            </remarks>
        </member>
        <member name="F:OBeautifulCode.Serialization.VersionlessOpenTypeConsolidatingTypeEqualityComparer.Instance">
            <summary>
            An instance.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.VersionlessOpenTypeConsolidatingTypeEqualityComparer.Equals(System.Type,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.VersionlessOpenTypeConsolidatingTypeEqualityComparer.GetHashCode(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.SerializationConfigurationBase">
            <summary>
            Common configuration base across all kinds of serialization.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.InternallyRequiredTypes">
            <summary>
            Gets the types that need to be registered for any and all serialization.
            </summary>
            <remarks>
            All of the model types within these subsystems will be picked-up as
            descendants of <see cref="T:OBeautifulCode.Type.IModel"/>, which is a public interface type
            in OBC.Type, and thus specified below.
            </remarks>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.InternallyRequiredNamespacePrefixFilters">
            <summary>
            Gets the namespace prefix filters to use for the <see cref="P:OBeautifulCode.Serialization.SerializationConfigurationBase.InternallyRequiredTypes"/>.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.UnregisteredTypeEncounteredStrategy">
            <summary>
            Gets the strategy to use with when attempting to serialize or deserialize using this configuration and encountering a type that has not been registered.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.DependentSerializationConfigurationTypes">
            <summary>
            Gets the serialization configuration types that are needed for this serialization configuration to work.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.DefaultDependentSerializationConfigurationTypes">
            <summary>
            Gets the serialization configuration types that are required to be in-effect for <see cref="T:OBeautifulCode.Serialization.SerializationKind"/>-associated abstract inheritors,
            (e.g. BsonSerializationConfiguration) so that, in turn, their concrete inheritors (e.g. MyDomainBsonSerializationConfiguration)
            do not need to specify these dependencies and so that any and all serialization that utilizes such concrete inheritors will work as expected.
            These will be ignored for any serialization configuration that implements <see cref="T:OBeautifulCode.Serialization.IIgnoreDefaultDependencies"/>.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.TypesToRegister">
            <summary>
            Gets the types to register along with additional information about other types that this type should "pull-in"/discover for registration.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.TypeToRegisterNamespacePrefixFilters">
            <summary>
            Gets a set of namespace filters that determine whether a type (specified or discovered) is registered.
            The default filter includes only types whose namespace starts with the namespace of this serialization configuration object.
            If a type's namespace starts with any of the specified filters, then the type is registered.
            An empty set means that no filtering occurs; all types specified or discovered are registered.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.TypesPermittedToHaveUnregisteredMembers">
            <summary>
            Gets the types that are permitted to have unregistered members.
            These are typically types that are registered with custom serializers (e.g. IBsonSerializer, JsonConverter).
            <see cref="M:OBeautifulCode.Serialization.SerializationConfigurationBase.ThrowOnUnregisteredTypeIfAppropriate(System.Type,OBeautifulCode.Serialization.SerializationDirection,System.Object)"/> will not recurse through
            the members of these types.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationBase.BuildSerializationConfigurationType">
            <summary>
            Gets the serialization configuration type.
            </summary>
            <returns>
            The serialization configuration type.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationBase.BuildTypeToRegisterForPostInitializationRegistration(System.Type,System.Type,System.Type,OBeautifulCode.Serialization.MemberTypesToInclude,OBeautifulCode.Serialization.RelatedTypesToInclude)">
            <summary>
            Builds a <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/> to be used for post-initialization registration,
            which only occurs for closed generic types at serialization-time, because these
            runtime types are not discoverable during initialization.
            </summary>
            <param name="type">The type to register.</param>
            <param name="recursiveOriginType">The type whose recursive processing of <paramref name="memberTypesToInclude"/> and <paramref name="relatedTypesToInclude"/> resulted in the creation of this <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/>.</param>
            <param name="directOriginType">The type whose processing of <paramref name="memberTypesToInclude"/> and <paramref name="relatedTypesToInclude"/> directly resulted in the creation of this <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/>.</param>
            <param name="memberTypesToInclude">Specifies which member types of <paramref name="type"/> that should also be registered.</param>
            <param name="relatedTypesToInclude">Specifies which types related to <paramref name="type"/> that should also be registered.</param>
            <returns>
            The type to register wrapper.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationBase.ProcessRegistrationDetailsPriorToRegistration(OBeautifulCode.Serialization.RegistrationDetails,OBeautifulCode.Serialization.RegistrationTime)">
            <summary>
            Processes a <see cref="T:OBeautifulCode.Serialization.RegistrationDetails"/> prior to registration.
            </summary>
            <param name="registrationDetails">Details related to the registration.</param>
            <param name="registrationTime">The time of registration.</param>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationBase.FinalizeInitialization">
            <summary>
            Perform any final setup/logic in initialization.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.SerializationConfigurationBase"/> class.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.DescendantSerializationConfigurationTypeToInstanceMap">
            <summary>
            Gets a map of the descendant (children, grandchildren, etc.) serialization configuration types to their initialized instance.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.DependentSerializationConfigurationTypesWithDefaultsIfApplicable">
            <summary>
            Gets all specified dependent (child) configuration types, including all internal configuration types
            unless this this configuration type is <see cref="T:OBeautifulCode.Serialization.IIgnoreDefaultDependencies"/>.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.RegisteredTypeToRegistrationDetailsMap">
            <summary>
            Gets a map of registered type to the type of serialization configuration that registered that type.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationBase.SerializationConfigurationType">
            <summary>
            Gets the serialization configuration type of the current instance.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationBase.Initialize(System.Collections.Generic.IReadOnlyDictionary{OBeautifulCode.Serialization.SerializationConfigurationType,OBeautifulCode.Serialization.SerializationConfigurationBase})">
            <summary>
            Run configuration logic.
            </summary>
            <param name="descendantSerializationConfigurationTypeToInstanceMap">Map of descendant (children, grandchildren, etc.) configuration type to configured instance.</param>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationBase.IsRegisteredType(System.Type)">
            <summary>
            Determines if the specified type has been registered.
            </summary>
            <param name="type">The type.</param>
            <returns>
            true if the type has been registered, otherwise false.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationBase.ThrowOnUnregisteredTypeIfAppropriate(System.Type,OBeautifulCode.Serialization.SerializationDirection,System.Object)">
            <summary>
            Throw on an unregistered type, if appropriate given the <see cref="P:OBeautifulCode.Serialization.SerializationConfigurationBase.UnregisteredTypeEncounteredStrategy"/>.
            </summary>
            <param name="type">Type to check.</param>
            <param name="serializationDirection">The serialization direction.</param>
            <param name="objectToSerialize">OPTIONAL object to serialize if serializing.  DEFAULT is null, assumes deserialization.</param>
        </member>
        <member name="T:OBeautifulCode.Serialization.SerializationConfigurationType">
            <summary>
            A wrapper for a concrete serialization configuration type (derives from <see cref="T:OBeautifulCode.Serialization.SerializationConfigurationBase"/>).
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationType.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.SerializationConfigurationType"/> class.
            </summary>
            <param name="concreteSerializationConfigurationDerivativeType">The type of the concrete <see cref="T:OBeautifulCode.Serialization.SerializationConfigurationBase"/> derivative.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.SerializationConfigurationType.ConcreteSerializationConfigurationDerivativeType">
            <summary>
            Gets the type of the concrete <see cref="T:OBeautifulCode.Serialization.SerializationConfigurationBase"/> derivative.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationType.op_Equality(OBeautifulCode.Serialization.SerializationConfigurationType,OBeautifulCode.Serialization.SerializationConfigurationType)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.SerializationConfigurationType"/> are equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationType.op_Inequality(OBeautifulCode.Serialization.SerializationConfigurationType,OBeautifulCode.Serialization.SerializationConfigurationType)">
            <summary>
            Determines whether two objects of type <see cref="T:OBeautifulCode.Serialization.SerializationConfigurationType"/> are not equal.
            </summary>
            <param name="left">The object to the left of the equality operator.</param>
            <param name="right">The object to the right of the equality operator.</param>
            <returns>true if the two items are not equal; otherwise false.</returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationType.Equals(OBeautifulCode.Serialization.SerializationConfigurationType)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationType.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.SerializationConfigurationManager">
            <summary>
            Manager to create, initialize, and cache implementations of <see cref="T:OBeautifulCode.Serialization.SerializationConfigurationBase"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.SerializationConfigurationManager.GetOrAddSerializationConfiguration(OBeautifulCode.Serialization.SerializationConfigurationType)">
            <summary>
            Gets an existing, fully initialized serialization configuration or creates and fully initializes a new one if
            one does not already exist for the specified serialization configuration type.
            </summary>
            <param name="serializationConfigurationType">The serialization configuration type.</param>
            <returns>
            An initialized instance of the specified serialization configuration type.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.SerializationDirection">
            <summary>
            Direction of serialization.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationDirection.Unknown">
            <summary>
            Unknown direction.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationDirection.Serialize">
            <summary>
            Serializing object.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationDirection.Deserialize">
            <summary>
            Deserializing object.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.SerializationFormat">
            <summary>
            Format of serialization.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationFormat.Invalid">
            <summary>
            Invalid default option.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationFormat.String">
            <summary>
            String format.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationFormat.Binary">
            <summary>
            Binary format.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.SerializationKind">
            <summary>
            Format of serialization.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationKind.Invalid">
            <summary>
            Invalid default option.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationKind.Json">
            <summary>
            JSON format.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationKind.Bson">
            <summary>
            BSON format.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationKind.PropertyBag">
            <summary>
            Property bag (Dictionary{string, string} format.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationKind.Proprietary">
            <summary>
            Proprietary serialization, both sides must understand how it was serialized to work.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationKind.LambdaBacked">
            <summary>
            Wrapper to honor protocol using provided <see cref="T:System.Func`1" />'s.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializationKind.StringSerializerBacked">
            <summary>
            Wrapper to honor protocol using provided <see cref="T:OBeautifulCode.Serialization.IStringSerializeAndDeserialize" />.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.RelatedTypesToInclude">
            <summary>
            Specifies which related types to include when registering a type.
            The included related types will be registered as well.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.RelatedTypesToInclude.None">
            <summary>
            Do not include any other types.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.RelatedTypesToInclude.Default">
            <summary>
            For interfaces and abstract classes, include all types that are assignable to the type being registered, otherwise do not include any other types.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.RelatedTypesToInclude.Ancestors">
            <summary>
            Include all types that the type being registered is assignable to.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.RelatedTypesToInclude.Descendants">
            <summary>
            Include all types that are assignable to the type being registered.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.RelatedTypesToInclude.AncestorsAndDescendants">
            <summary>
            Include all types that the type being registered is assignable to and all types that are assignable to the type being registered.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.MemberTypesToInclude">
            <summary>
            Specifies which member types to include when registering a type.
            The included member types will be registered as well.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.MemberTypesToInclude.None">
            <summary>
            Do not include any of the member types.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.MemberTypesToInclude.DeclaredProperties">
            <summary>
            Include the types of all declared properties (public and non-public).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.MemberTypesToInclude.DeclaredFields">
            <summary>
            Include the types of all declared fields (public and non-public).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.MemberTypesToInclude.GenericArguments">
            <summary>
            Include the types of all generic arguments.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.MemberTypesToInclude.ArrayElement">
            <summary>
            Include the array element type.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.MemberTypesToInclude.All">
            <summary>
            Include all possible member types.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.TypeToRegister`1">
            <inheritdoc />
            <typeparam name="T">The type to register.</typeparam>
        </member>
        <member name="M:OBeautifulCode.Serialization.TypeToRegister`1.#ctor(OBeautifulCode.Serialization.MemberTypesToInclude,OBeautifulCode.Serialization.RelatedTypesToInclude)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.TypeToRegister`1"/> class.
            </summary>
            <param name="memberTypesToInclude">Specifies which member types of <typeparamref name="T"/> that should also be registered.</param>
            <param name="relatedTypesToInclude">Specifies which types related to <typeparamref name="T"/> that should also be registered.</param>
        </member>
        <member name="T:OBeautifulCode.Serialization.TypeToRegister">
            <summary>
            Specifies a type to register.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.TypeToRegister.#ctor(System.Type,OBeautifulCode.Serialization.MemberTypesToInclude,OBeautifulCode.Serialization.RelatedTypesToInclude)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/> class with a type that is it's own origin.
            </summary>
            <param name="type">The type to register.</param>
            <param name="memberTypesToInclude">Specifies which member types of <paramref name="type"/> that should also be registered.</param>
            <param name="relatedTypesToInclude">Specifies which types related to <paramref name="type"/> that should also be registered.</param>
        </member>
        <member name="M:OBeautifulCode.Serialization.TypeToRegister.#ctor(System.Type,System.Type,System.Type,OBeautifulCode.Serialization.MemberTypesToInclude,OBeautifulCode.Serialization.RelatedTypesToInclude)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/> class, specifying the origin types.
            </summary>
            <param name="type">The type to register.</param>
            <param name="recursiveOriginType">The type whose recursive processing of <paramref name="memberTypesToInclude"/> and <paramref name="relatedTypesToInclude"/> resulted in the creation of this <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/>.</param>
            <param name="directOriginType">The type whose processing of <paramref name="memberTypesToInclude"/> and <paramref name="relatedTypesToInclude"/> directly resulted in the creation of this <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/>.</param>
            <param name="memberTypesToInclude">Specifies which member types of <paramref name="type"/> that should also be registered.</param>
            <param name="relatedTypesToInclude">Specifies which types related to <paramref name="type"/> that should also be registered.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.TypeToRegister.Type">
            <summary>
            Gets the type to register.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.TypeToRegister.RecursiveOriginType">
            <summary>
            Gets the type whose recursive processing of <see cref="P:OBeautifulCode.Serialization.TypeToRegister.MemberTypesToInclude"/> and <see cref="P:OBeautifulCode.Serialization.TypeToRegister.RelatedTypesToInclude"/> resulted in the creation of this <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/>.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.TypeToRegister.DirectOriginType">
            <summary>
            Gets the type whose processing of <see cref="P:OBeautifulCode.Serialization.TypeToRegister.MemberTypesToInclude"/> and <see cref="P:OBeautifulCode.Serialization.TypeToRegister.RelatedTypesToInclude"/> directly resulted in the creation of this <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/>.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.TypeToRegister.MemberTypesToInclude">
            <summary>
            Gets a value that specifies which member types of <see cref="P:OBeautifulCode.Serialization.TypeToRegister.Type"/> that should also be registered.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.TypeToRegister.RelatedTypesToInclude">
            <summary>
            Gets a value that specifies which types related to <see cref="P:OBeautifulCode.Serialization.TypeToRegister.Type"/> that should also be registered.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.TypeToRegister.IsOriginatingType">
            <summary>
            Gets a value indicating whether this <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/> is it's own origin (was not spawned from some other <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.TypeToRegister.CreateSpawnedTypeToRegister(System.Type,OBeautifulCode.Serialization.TypeToIncludeOrigin)">
            <summary>
            Creates a <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/> that is spawned in processing the <see cref="P:OBeautifulCode.Serialization.TypeToRegister.MemberTypesToInclude"/> and <see cref="P:OBeautifulCode.Serialization.TypeToRegister.RelatedTypesToInclude"/> of this instance.
            </summary>
            <param name="type">The spawned type.</param>
            <param name="typeToIncludeOrigin">The <see cref="T:OBeautifulCode.Serialization.TypeToIncludeOrigin"/>.</param>
            <returns>
            The spawned <see cref="T:OBeautifulCode.Serialization.TypeToRegister"/>.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.TypeToRegister.ToString">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcSerializerBase">
            <summary>
            Serializer that utilizes a fully configured <see cref="T:OBeautifulCode.Serialization.SerializationConfigurationBase"/>.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSerializerBase.#ctor(OBeautifulCode.Serialization.SerializationConfigurationType)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.ObcSerializerBase"/> class.
            </summary>
            <param name="serializationConfigurationType">The serialization configuration type to use.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcSerializerBase.SerializationConfiguration">
            <summary>
            Gets the serialization configuration.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcSerializerBase.SerializationConfigurationType">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcSerializerBase.SerializationKind">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcSerializerBase.SerializerRepresentation">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSerializerBase.SerializeToBytes(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSerializerBase.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSerializerBase.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSerializerBase.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSerializerBase.Deserialize``1(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcSerializerBase.Deserialize(System.Byte[],System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.DateTimeParsingSettings">
            <summary>
            Settings for parsing a <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.DateTimeParsingSettings.DateTimeKind">
            <summary>
            Gets or sets the <see cref="P:OBeautifulCode.Serialization.DateTimeParsingSettings.DateTimeKind" /> to parse into.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.DateTimeParsingSettings.DateTimeStyles">
            <summary>
            Gets or sets the <see cref="P:OBeautifulCode.Serialization.DateTimeParsingSettings.DateTimeStyles"/> to use when parsing the string.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.DateTimeParsingSettings.FormatString">
            <summary>
            Gets or sets a format specifier that defines the required format for the string being parsed.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.SerializedDateTimeKind">
            <summary>
            Specifies the kind of serialized date time.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializedDateTimeKind.Unknown">
            <summary>
            Unknown (default).
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializedDateTimeKind.Utc">
            <summary>
            Universal kind, with seven decimal places after seconds.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializedDateTimeKind.UtcSixFs">
            <summary>
            Utc with only six (not seven) decimal places after seconds.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializedDateTimeKind.UtcFiveFs">
            <summary>
            Utc with only five (not seven) decimal places after seconds.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializedDateTimeKind.UtcFourFs">
            <summary>
            Utc with only four (not seven) decimal places after seconds.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializedDateTimeKind.UtcThreeFs">
            <summary>
            Utc with only three (not seven) decimal places after seconds.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializedDateTimeKind.UtcTwoFs">
            <summary>
            Utc with only two (not seven) decimal places after seconds.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializedDateTimeKind.UtcOneFs">
            <summary>
            Utc with only one (not seven) decimal places after seconds.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializedDateTimeKind.UtcZeroFs">
            <summary>
            Utc with zero (not seven) decimal places after seconds.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializedDateTimeKind.Unspecified">
            <summary>
            Unspecified kind.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.SerializedDateTimeKind.Local">
            <summary>
            Local kind.
            </summary>
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcDateTimeStringSerializer">
            <summary>
            String serializer for <see cref="T:System.DateTime" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcDateTimeStringSerializer.SerializeToString(System.DateTime)">
            <summary>
            Serializes a <see cref="T:System.DateTime"/> to a string.
            </summary>
            <param name="value">The value to serialize.</param>
            <returns>
            The serialized string.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcDateTimeStringSerializer.DeserializeToDateTime(System.String)">
            <summary>
            Deserializes a string into a <see cref="T:System.DateTime"/>.
            </summary>
            <param name="serializedString">Serialized string.</param>
            <returns>
            The deserialized <see cref="T:System.DateTime"/>.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcDateTimeStringSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcDateTimeStringSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcDateTimeStringSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer">
            <summary>
            String serializer for <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.DefaultKeyValueDelimiter">
            <summary>
            Default delimiter for specifying a key and value in a string.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.DefaultLineDelimiter">
            <summary>
            Default delimiter for specifying multiple entries in a single string.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.DefaultNullValueEncoding">
            <summary>
            Default encoding of NULLs.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer"/> class.
            </summary>
            <param name="keyValueDelimiter">Delimiter for the key and value.</param>
            <param name="lineDelimiter">Delimiter for the lines.</param>
            <param name="nullValueEncoding">Encoding for NULLs.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.KeyValueDelimiter">
            <summary>
            Gets the key value delimiter.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.LineDelimiter">
            <summary>
            Gets the line delimiter.
            </summary>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.NullValueEncoding">
            <summary>
            Gets the null encoding.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.SerializeDictionaryToString(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Serializes a dictionary to a string.
            </summary>
            <param name="dictionary">Dictionary to serialize.</param>
            <returns>
            String serialized dictionary.
            </returns>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcDictionaryStringStringSerializer.DeserializeToDictionary(System.String)">
            <summary>
            Deserialize the string to a dictionary of string, string.
            </summary>
            <param name="serializedString">String to deserialize.</param>
            <returns>
            Deserialized dictionary.
            </returns>
        </member>
        <member name="T:OBeautifulCode.Serialization.ObcLambdaBackedSerializer">
            <summary>
            Serializer that is backed by <see cref="T:System.Func`2" />.
            </summary>
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcLambdaBackedSerializer.#ctor(System.Func{System.Object,System.String},System.Func{System.String,System.Type,System.Object},System.Func{System.Object,System.Byte[]},System.Func{System.Byte[],System.Type,System.Object},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:OBeautifulCode.Serialization.ObcLambdaBackedSerializer"/> class.
            </summary>
            <param name="serializeString">Serialize object to string.</param>
            <param name="deserializeString">Deserialize object from string.</param>
            <param name="serializeBytes">Serialize object to bytes.</param>
            <param name="deserializeBytes">Deserialize object from bytes.</param>
            <param name="id">Optional identifier to be stored in metadata of <see cref="P:OBeautifulCode.Serialization.ObcLambdaBackedSerializer.SerializerRepresentation"/>.  DEFAULT is null.</param>
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcLambdaBackedSerializer.SerializationConfigurationType">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcLambdaBackedSerializer.SerializationKind">
            <inheritdoc />
        </member>
        <member name="P:OBeautifulCode.Serialization.ObcLambdaBackedSerializer.SerializerRepresentation">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcLambdaBackedSerializer.SerializeToBytes(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcLambdaBackedSerializer.SerializeToString(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcLambdaBackedSerializer.Deserialize``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcLambdaBackedSerializer.Deserialize(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcLambdaBackedSerializer.Deserialize``1(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:OBeautifulCode.Serialization.ObcLambdaBackedSerializer.Deserialize(System.Byte[],System.Type)">
            <inheritdoc />
        </member>
        <member name="T:OBeautifulCode.Serialization.UnregisteredTypeEncounteredStrategy">
            <summary>
            Enumeration of options on how to deal with an attempted operation on an object where the type has not been registered.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.UnregisteredTypeEncounteredStrategy.Attempt">
            <summary>
            Attempt an operation on an object without prior registration.
            </summary>
        </member>
        <member name="F:OBeautifulCode.Serialization.UnregisteredTypeEncounteredStrategy.Throw">
            <summary>
            Throw if an operation is attempted on an object without prior registration.
            </summary>
        </member>
    </members>
</doc>
